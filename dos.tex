\documentclass[10pt,twoside]{book}
\usepackage{a4}
\usepackage{times}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{forest}
%
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\textwidth}{15.2cm}
\setlength{\footskip}{1.6cm}
%\setlength{\footheight}{0.5cm}
\setlength{\topmargin}{0.0cm}
\setlength{\headheight}{0.5cm}
\setlength{\headsep}{1.5cm}
\setlength{\topskip}{0.5cm}
\setlength{\textheight}{21.8cm}
%
\usepackage{fancyhdr}
%\nonfrenchspacing
\usepackage{latexsym}
\usepackage{t1enc}
\usepackage[latin1]{inputenc}
\usepackage{index}
\usepackage{enumitem}
\pagestyle{headings}
\pagestyle{fancy}
%
\renewcommand{\labelitemi}{\raisebox{0.3ex}{\tiny $\Box$}}
%
%
\renewcommand{\sectionmark}[1]{%
\markboth{#1}{}}
\fancyhead{}
\fancyfoot{}
\fancyfoot[LE]{{\sf \thepage} \hspace{1em} {\sfi Rom Kernel Reference Manual: DOS}}
\fancyfoot[RO]{{\sfi \leftmark} \hspace{1em} {\sf \thepage}}
% Redefine the plain page style
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyfoot[LE]{{\sf \thepage} \hspace{1em} {\sfi Rom Kernel Reference Manual: DOS}}
  \fancyfoot[RO]{{\sfi \leftmark} \hspace{1em} {\sf \thepage}}
  \renewcommand{\headrulewidth}{2.0mm}
  \renewcommand{\footrulewidth}{0.0mm}
}
\renewcommand{\headrulewidth}{2.0mm}
\renewcommand{\footrulewidth}{0.0mm}
%
\newcommand{\sfi}{\sffamily\slshape}
\newcommand{\sfb}{\sffamily\bfseries}
\newcommand{\cnot}{\symbol{126}}
\setcounter{secnumdepth}{4}
\setlength{\LTpre}{0pt}
\setlength{\LTpost}{0pt}
%
%
\newcounter{rkrmtablecount}
%
\newenvironment{rkrmtable}[1]%
{%
\nopagebreak[5]%
\begin{center}%
\begin{minipage}{15.2cm}%
\begin{center}%
\refstepcounter{rkrmtablecount}
{\sfb Table \arabic{rkrmtablecount}: #1} \\[1ex]
\begin{tabular}{|ll|} \hline
}{%
\end{tabular}%
\end{center}%
\end{minipage}%
\end{center}%
}
%
\newenvironment{rkrmtabular}[1]%
{%
\nopagebreak[5]%
\begin{center}%
\refstepcounter{rkrmtablecount}
{\sfb Table \arabic{rkrmtablecount}: #1} \\[1ex]
}{%
\end{center}%
}
%
\newlength{\punchlinewidth}
\setlength{\punchlinewidth}{\textwidth}
\addtolength{\punchlinewidth}{-\rightmargin}
\addtolength{\punchlinewidth}{-\leftmargin}
\addtolength{\punchlinewidth}{-4.2pt}
%
\newlength{\jpgtablewidth}
\setlength{\jpgtablewidth}{\textwidth}
\addtolength{\jpgtablewidth}{-\rightmargin}
\addtolength{\jpgtablewidth}{-\leftmargin}
\addtolength{\jpgtablewidth}{-4.2pt}
%
%
\newcommand{\punchline}[2]{%
\bigskip{\setlength{\arrayrulewidth}{1mm}
\begin{tabular}{|p{\punchlinewidth}}
{\sfi #1}$\quad$#2
\end{tabular}
}\bigskip}

%
% Insert the page under the given key into the index.
\newcommand{\key}[1]{\index{#1@{\scriptsize{} #1}}}
% The same again, but make this the main entry.
\newcommand{\mkey}[1]{\index{#1@{\scriptsize{} #1}|emph}}
% An entry defining a library function call
\newcommand{\call}[1]{{\bf J2K::#1()\key{#1()}}}
\makeatletter
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.5em}}
\renewcommand*\l@subsection{\@dottedtocline{2}{1.8em}{3.7em}}
\makeatother
%
\makeindex
%
%
\begin{document}
\thispagestyle{empty}
\pagenumbering{roman}
\begin{center}
\vspace*{\fill}
{\Huge Amiga ROM Kernel Reference Manual\\}
\bigskip
{\Huge DOS\\}
\bigskip
{\huge\sc
Thomas Richter\\}
\bigskip
\end{center}
\bigskip
\vspace*{\fill}
\bigskip
{\small Copyright © 2023 by Thomas Richter, all rights reserved. This
publication is freely distributable under the restrictions stated below, but is
also Copyright © Thomas Richter.

Distribution of the publication by a commercial organization without written
permission from the author to any third party is prohibited if any payment is
made in connection with such distribution, whether directly (as in payment for a
copy of the publication) or indirectly (as in payment for some service related
to the Publication, or payment for some product or service that includes a
copy of the publication ``without charge''; these are only examples, and
not an exhaustive enumeration of prohibited activities).

However, the following methods of distribution involving payment shall not in
and of themselves be a violation of this restriction:
\begin{enumerate}
\item Distributing the Program on a physical data carrier (e.g. CD-ROM,
  DVD, USB-Stick, Disk...) provided that:
  \begin{enumerate}
  \item the Archive is reproduced entirely and verbatim on such data carrier,
    including especially this licence agreement;
  \item the data carrier is made available to the public for a nominal
    fee only, i.e. for a fee that covers the costs of the data carrier,
    and shipment of the data carrier;
  \item a data carrier with the Program installed is made available to the
    author for free except for shipment costs, and
  \item provided further that all information on said data carrier is
    redistributable for non-commercial purposes without charge.
  \end{enumerate}
\end{enumerate}

Redistribution of a modified version of the publication is prohibited in any
way, by any organization, regardless whether commercial or non-commercial.
Everything must be kept together, in original and unmodified form. }

\bigskip

{\small \sc Disclaimer: This publication is provided ``as is'' without any
warranty of any kind, either expressed or implied, including, but not limited
to, the implied warranties of merchantability and fitness for any particular
purpose. Further, the author does not warrant, guarantee, or make any
representation regarding the use of, or the results of the use of, the
information contained herein in term of correctness, accuracy, reliability,
currentness, or otherwise; the entire risk as to its quality and accuracy is
assumed solely by the user. Should the information prove inaccurate, the user
(and not the author) assumes the either cost of all necessary correction. In no
event will the author be liable for direct, indirect, incidental, or
consequential damages resulting from any defect or inaccuracy in this
publication, even if advised of the possibility of such damages. Some laws do
not allow the exclusion or limitation of implied warranties or liabilities for
incidental or consequential damages, so the above limitation or exclusion may
not apply.}

\bigskip

{\small {\it Amiga} is a registered trademark, {\it Amiga-DOS}, {\it Exec} and
{\it Kickstart} are registered trademarks of Amiga Intl. {\it Motorola} is a
registered trademark of Motorola, inc. {\it Unix} is a trademark of
the Open Group.}
\newpage
\vspace*{\fill}
\newpage
\tableofcontents
\pagenumbering{arabic}
%
%
\chapter{Introduction}
\section{Purpose}
The purpose of this manual is to provide a comprehensive documentation
of the AmigaDOS subsystem of the Amiga Operation System. This
subsystem is represented by the \emph{dos.library}, and it provides
services around files, file systems and stream-based input and
output. While the Amiga ROM Kernel Reference Manuals~\cite{rkrmlib}
document major parts of the AmigaOs, they do not include a volume on
AmigaDOS itself. This is due to the history of AmigaDOS which is
nothing but a port of the TRIPOS to the Amiga, and thus its
documentation became available as the AmigaDOS manual\cite{Bantam}
separately. This book itself is, similar to AmigaDOS, based on the
TRIPOS manual which has been augmented and updated to reflect the
changes that were necessary to fit TRIPOS into AmigaOs. Unfortunately,
the book is hard to obtain, and also leaves a lot to deserve.
\smallskip{}

Good third party documentation is available in the form of the Guru
Book\cite{guru}, though this source is out of print and even harder to
obtain. It covers also other aspects of AmigaOs that go beyond
AmigaDOS such that its focus is a bit different than this work.
\smallskip{}

This work attempts to fill this gap by providing a comprehensive and
complete documentation of the AmigaDOS library and its subsystems in
the style of the ROM Kernel Reference Manuals.

\section{Language and Type Setting Conventions}
The words \emph{shall} and \emph{shall not} indicate normative
requirements software shall or shall not follow or in order to satisfy the
interface requirements of AmigaOs. The words \emph{should} and
\emph{should not} indicate best practise and recommendations that are
advisable, but not strictly necessary to satisfy a particular
interface. The word \emph{may} provides a hint to a possible
implementation strategy.
\smallskip{}

The word \emph{must} indicates a logical consequence from existing
requirements or conditions that follows necessarily without
introducing a new restriction, such as in ``if $a$ is 2, $a+a$
\emph{must} be 4''.

\punchline{Worth to remember!}{Important aspects of the text are
  indicated with a bold vertical bar like this.}

Terms are indicated in \emph{italics}, e.g. the \emph{dos.library}
implements interface of \emph{AmigaDOS}. Data structures and
components of source code are printed {\tt in courier} in fixed-width
font, reassembling the output of a terminal, e.g.

\begin{verbatim}
typedef unsigned char UBYTE; /* an 8-bit unsigned integer */
typedef long LONG;           /* a 32-bit integer          */
\end{verbatim}

\chapter{Elementary Data Types}
\section{The dos.library}
\emph{AmigaDOS} as part of the \emph{Amiga Operating System} or short
\emph{AmigaOs} is represented by the ROM-based
\emph{dos.library}. This library is typically opened by the startup
code of most compilers anyhow, and its base pointer is placed into
{\tt DOSBase} by this startup code:
\begin{verbatim}
struct DosLibrary *DOSBase;
\end{verbatim}
Hence, in general, there is no need to open this library manually.
\smallskip{}

The structure \emph{\mkey{DosLibrary}struct DosLibrary} is defined in
{\tt dos/dosextens.h}, but its layout and its members are usually not
required and should rather not be accessed directly. Instead, the
library provides accessor functions to read many objects contained
within it.
\smallskip{}

If you do not link with compiler startup code, the base pointer of the
\emph{dos.library} can be obtained similar to that of any other library:
\begin{verbatim}
#include <proto/exec.h>
#include <proto/dos.h>
#include <exec/libraries.h>
#include <dos/dos.h>

...
if ((DOSBase = (struct DosLibrary *)(OpenLibrary(DOSNAME,47))) {
  ...
  CloseLibrary((struct Library *)DOSBase);
}
\end{verbatim}

Unlike many other operating system, the \emph{dos.library} does not
manage disks or files itself, neither does it provide access to
hardware interface components. It rather implements a \emph{virtual
  file system} which forwards requests to its subsystems, called
\emph{handlers} or \emph{file systems}, see~\ref{sec:handlerovv}.

\section{Booleans}

AmigaDOS uses a somewhat different convention for booleans, i.e. truth
values defined in the file {\tt dos/dos.h}:

\begin{rkrmtable}{DOS Truth Values} \label{table:dosbool}
{\bf Define} & {\bf Value}\\ \hline \hline
DOSFALSE & 0  \\ \hline
DOSTRUE  & -1 \\ \hline
\end{rkrmtable}

Note that the C language instead uses the value $1$ for
{\tt TRUE}. Code that checks for zero or non-zero return codes will
function normally, however code shall not compare to {\tt TRUE} in
boolean tests.

\section{Pointers and BPTRs} \label{sec:bptrs}
AmigaDOS is a descendent of the \emph{TRIPOS system} and as such
originally implemented in the BCPL language. As of Kickstart 2.0,
AmigaDOS was re-implemented in C and assembler, but this
implementation had to preserve the existing interface based on BCPL
conventions.
\smallskip{}

BCPL is a typeless language that structures the memory of its host
system as an array of 32-bit elements enumerated contiguously from
zero up. Rather than pointers, BCPL communicates the position of its
data structures in the form of indices of the first 32-bit element of
such structures. As each 32-bit group is assigned its own index, one
can obtain this index by dividing the byte-address of an element by 4,
or equivalently, by right-shifting the address by two bits. This has
the consequence that (most) data structures passed into and out of the
dos.library shall be aligned to 32-bit boundaries. Similarly, in order
to obtain the byte-address of a BPCL structure, the index is
multiplied by 4, or left-shifted by 2 bits.

\punchline{Not on the Stack!}{Since BPCL structures must have an
  address that is divisible by 4, you should not keep such structures
  on the stack as the average compiler will not ensure long word
  alignment for automatic objects. In the absence of a dedicated
  constructor function such as
  \emph{\key{AllocDosObject()}AllocDosObject()}, a safe strategy is
  use the exec.library memory allocation functions such as
  \emph{\key{AllocMem()}AllocMem()} or
  \emph{\key{AllocVec()}AllocVec()} to obtain memory for holding
  them.}

These indices are called \emph{BCPL pointers} or short \emph{\key{BPTR}BPTR}s,
even though they are not pointers in the sense of the C language, but
rather integer numbers as indices to an array of {\tt LONG}
(i.e. 32-bit) integers. In order to communicate this fact more
clearly, the {\tt dos/dos.h} include file defines the following data
type:

\mkey{BPTR}
\begin{verbatim}
typedef long  BPTR;                 /* Long word pointer */
\end{verbatim}

Conversion from BCPL pointers to conventional C pointers and back are
formed by the following macros, also defined in {\tt dos/dos.h}:

\mkey{BADDR()} \mkey{MKBADDR()}
\begin{verbatim} 
/* Convert BPTR to typical C pointer */
#define BADDR(x)        ((APTR)((ULONG)(x) << 2))
/* Convert address into a BPTR */
#define MKBADDR(x)      (((LONG)(x)) >> 2)
\end{verbatim}

Luckely, in most cases callers of the \emph{dos.library} do not need
to convert from and to BPTRs but can rather use such ``pointers'' as
\emph{opaque values} or \emph{handles} representing some AmigaDOS
objects.
\smallskip{}

It is certainly a burden to always allocate temporary BCPL objects
from the heap, and doing so may also fragment the AmigaOs memory
unnecessarily. However, allocation of automatic objects from the stack
does not ensure long-word alignment in general. To work around this
burden, one can use a trick and instead request from the compiler a
somewhat longer object of automatic lifetime and align the requested
object manually within the memory obtained this way. The following
macro performs this trick:

\begin{verbatim}
#define D_S(type,name) char a_##name[sizeof(type)+3]; \
                       type *name = (type *)((ULONG)(a_##name+3) & ~3UL)
\end{verbatim}

It is used as follows:
\begin{verbatim}
D_S (struct FileInfoBlock, fib); 
\end{verbatim}

At this point, fib is pointer to a properly aligned {\tt struct
FileInfoBlock}, e.g. this is equivalent to
\begin{verbatim}
struct FileInfoBlock _tmp;
struct FileInfoBlock *fib = &tmp;
\end{verbatim}
except that the created pointer is properly aligned and can safely be
passed into the \emph{dos.library}.
\smallskip{}

Similar to the C language, a pointer to a non-existing element is
expressed by the special pointer value $0$. While this is called the
{\tt NULL} pointer in C, it is better to reserve another name for it
in BPCL as its pointers are rather indices. The following convention
is suggested to express an invalid \emph{BPTR}:

\begin{verbatim}
#define ZERO 0L
\end{verbatim}

Clearly, with the above convention, the BCPL {\tt \mkey{ZERO}ZERO} pointer
converts to the C {\tt \mkey{NULL}NULL} pointer and back, even though the two are
conceptionally something different: The first being the index to the
first element of the host memory array, the later the pointer to the
first address.

\section{C Strings and BSTRs}
While the C language defines \emph{\mkey{String}strings} as
0-terminated arrays of {\tt char}, and AmigaOs in particular to
0-terminated arrays of {\tt UBYTE}s, that is, unsigned characters, the
BPCL language uses a different convention, namely that of a {\tt
  UBYTE} array whose first element contains the size of the string to
follow. They are not necessarily 0-terminated either. If BCPL strings
are passed into BCPL functions, or are part of BCPL data structures,
then typically in the form of a \emph{\key{BPTR}BPTR} to the 32-bit
element containing the size of the string its 8 most significant
bits. The include file {\tt dos/dos.h} provides its own data type for
such strings:

\mkey{BSTR}
\begin{verbatim}
typedef long  BSTR;   /* Long word pointer to BCPL string  */
\end{verbatim}

Luckely, functions of the \emph{dos.library} take C strings as
arguments and perform the conversion from C strings to their BCPL
representation as \emph{BSTR}s internally, such that one rarely gets
in contact with this type of strings. They appear as part of some
AmigaDOS structures to be discussed, and as part of the interface
between the \emph{dos.library} and its handlers, e.g. file systems.
However, even though users of the \emph{dos.library} rarely come in
contact with \emph{BSTR}s themselves, the \emph{BCPL} convention has
an important consequence, namely that (most) strings handled by the
\emph{dos.library} cannot be longer than 255 characters as this is the
limit imposed by the BCPL convention.

\punchline{Length-Limited Strings}{Remember that most strings that are
  passed into the \emph{dos.library} are internally converted to
  \emph{BSTR}s and thus cannot exceed a length of 255 characters.}

Unfortunately, even as of the latest version of \emph{AmigaDos}, the
\emph{dos.library} is ill-prepared to take longer strings, and will
likely fail or mis-interpret the string passed in. If longer strings
are required, e.g. as part of a \emph{\key{path}path}, it is
(unfortunately) in the responsibility of the caller to take this path
apart into components and iterate through the components manually,
see also section~\ref{sec:files}.

\section{Files}
Files\key{File} are streams of bytes together with a file pointer that
identifies the next position to be read, or the next byte position to
be filled. Files are explained in more detail in section~\ref{sec:file}.

\section{Locks}
Locks\key{Lock} are access rights to a particular object on a file
system. A locked object cannot be altered by any other
process. Section~\ref{sec:locks} provides more details on locks.

\section{Processes}
AmigaDOS is a multi-tasking system operating on top of the \emph{exec}
kernel~\cite{rkrmlib}. As such, it can operate multiple tasks at once,
where the tasks are assigned to the CPU in a round-robin fashion. A
\emph{Process}\key{Process} is an extension of an AmigaOs
\emph{Task}\mkey{Task} that includes additional state information
relevant to AmigaDOS, such as a \emph{current directory} \emph{Current
  Directory} it operates in, a \emph{default file system}\key{Default
  file system}, a \emph{console}\key{console} it is connected to, and
default input, output and error streams. Processes are explained in
more detail in section~\ref{sec:process}.

\section{Handlers and File Systems} \label{sec:handlerovv}
\emph{Handlers} are special processes that manage files on a volume, or that
input or output data to a physical device. AmigaDOS itself delegates
all operations on files to such handlers. Handlers are introduced in
section~\ref{sec:handler}.
\smallskip{}

\emph{File systems} are special handlers that organize the contents of
data carriers such as hard disks, floppies or CD-Roms in the form of
files and directories, and provides access to such objects through the
\emph{dos.library}. File systems interpret paths (see~\ref{sec:paths})
in order to locate objects such as files and directories on such data
carriers.

\chapter{Date and Time} \label{sec:dates}

Due to its history, AmigaOs uses two incompatible representations of date
and time. The {\tt timer.device} represents a date as the number of seconds
and microseconds since January $1^{\mbox{\tiny st}}$ 1978. As AmigaDOS is
based on TRIPOS as an independently developed operating system, the
\emph{dos.library} uses a different representation as {\tt DateStamp}
structure defined in {\tt dos/dos.h}: \mkey{DateStamp}
\begin{verbatim}
struct DateStamp {
   LONG  ds_Days;
   LONG  ds_Minute;
   LONG  ds_Tick;
};
\end{verbatim}

The elements of this structure are as follows:
\smallskip{}

{\tt ds\_Days} counts the number of days since January $1^{\mbox{{\tiny st}}}$ 1978.
\smallskip{}

{\tt ds\_Minute} counts the number of minutes past midnight, i.e. the start of the day.
\smallskip{}

{\tt ds\_Tick} counts the ticks since the start of the minute. The number of
ticks per second is defined as {\tt TICKS\_PER\_SECOND} in {\tt dos/dos.h}.
\smallskip{}

\punchline{Ticking 50 Times a Second}{A system ``tick'' is always
$1/50^{\mbox{\tiny th}}$ of a second, regardless whether the system is an
NTSC or PAL system. AmigaDOS detects the clock basis during setup and will
scale times appropriately such that the definition of the ``tick'' is
independent of the clocking of the system or the monitor refresh frequency.}

\section{Elementary Time and Date Functions}

The functions in this section obtain the current system time, compare two
times, or delay the system for a given time. They represent times --- and
dates if appropriate --- in the {\tt DateStamp} structure as a triple of
days, minutes and ticks.

\subsection{Obtaining the Time and Date}

The {\tt DateStamp()}\mkey{DateStamp()} function obtains the current date
and time from AmigaDOS:

\begin{verbatim}
ds = DateStamp( ds );
D0              D1

struct DateStamp *DateStamp(struct DateStamp *)
\end{verbatim}

This function retrieves the current system time and fills it into a
{\tt DateStamp}\key{DateStamp} structure pointed to by {\tt ds}. It also
returns a pointer to the structure passed in. This function cannot fail.
\smallskip{}

Unlike many other \emph{dos.library} functions, there is no requirement to
align {\tt ds} to a long-word boundary.

\subsection{Comparing two Times and Dates}

The {\tt CompareDates()}\mkey{CompareDates()} function compares two dates as
given by {\tt DateStamp}\key{DateStamp} function and returns an indicator
which of the dates are earlier.

\begin{verbatim}
result = CompareDates(date1,date2)
D0                     D1     D2

LONG CompareDates(struct DateStamp *,struct DateStamp *)
\end{verbatim}

This function takes two pointers to {\tt DateStamp} structures as
{\tt date1} and {\tt date2} and returns a negative number if {\tt date1} is later
than {\tt date2}, a positive number if {\tt date2} is later than {\tt date1},
or 0 if the two dates are identical.

\subsection{Delaying Program Execution}

The {\tt Delay()}\mkey{Delay()} function delays the execution of the calling
process by a specific amount of ticks.

\begin{verbatim}
Delay( ticks )
       D1

void Delay(ULONG)
\end{verbatim}

This function suspends execution of the calling process by {\tt ticks}
AmigaDOS ticks. The delay is system-friendly and does not burn CPU cycles;
instead, the process is suspended from the CPU the indicated amount of time,
makking it available for other processes. Thus, this function is the
preferred way of delaying program execution. A tick is $1/50^{\mbox{\tiny
    th}}$ of a second.
\smallskip{}

AmigaDOS variants below version 36 could not handle delays of~0
appropriately.

\section{Conversion Into and From Strings} \label{sec:dateconv}

Functions in this section convert date and time in the (binary) AmigaDOS
representation to human-readable strings, and in the reveverse direction.
Both the input and output of these functions are kept in the {\tt
  DateTime} structure that is defined in {\tt dos/datetime.h}
and reads as follows:
\mkey{DateTime}
\begin{verbatim}
struct DateTime {
        struct DateStamp dat_Stamp;
        UBYTE   dat_Format;        
        UBYTE   dat_Flags;         
        UBYTE   *dat_StrDay;       
        UBYTE   *dat_StrDate;      
        UBYTE   *dat_StrTime;      
};
\end{verbatim}

{\tt dat\_Stamp} contains the input or output date represented as a {\tt
  DateStamp} structure.
\smallskip{}

{\tt dat\_Format} defines the format of the date string to create, and the
order in which days, months and years appear within the string. The
following formats are available, all defined in {\tt dos/datetime.h}:

\begin{rkrmtable}{Date formatting options} \label{table:dateformats}
{\bf Format Definition} & {\bf Description} \\ \hline \hline
{\tt FORMAT\_DOS} & The AmigaDOS default format \\ \hline
{\tt FORMAT\_INT} & International (ISO) format \\ \hline
{\tt FORMAT\_USA} & USA date format \\ \hline
{\tt FORMAT\_CDN} & Canadian and European format \\ \hline
\end{rkrmtable}

{\tt FORMAT\_DOS} represents the date as day of the month in two digits,
followed by the month as three-letter abbreviation, followed by a two-digit
year counting from the start of the century. An example of this formatting
is {\tt 30-Sep-23}.
\smallskip{}

{\tt FORMAT\_INT} starts with a two-digit year, followed by the month
represented as two digits starting from 01 for January, followed by two
digits for the day of the month. An example of this string is
{\tt 23-09-30}.
\smallskip{}

{\tt FORMAT\_USA} places the month first, encoded as two numerical digits,
followed by two digits of the day of the month, followed by two digits of
the year. An example of this formatting is {\tt 09-30-23}.
\smallskip{}

{\tt FORMAT\_CDN} follows the European convention and places the day of the
month first, followed by the month represented as two numerical digits,
followed by the year as two digits.
\medskip{}

{\tt dat\_Flags} defines additional flags that control the conversion
process. They are also defined in {\tt dos/datetime.h}:

\begin{rkrmtable}{Date conversion flags} \label{table:dateflags}
{\bf Flag} & {\bf Description} \\ \hline \hline
{\tt DTF\_SUBST} & Substitute dates by relative description if possible \\ \hline
{\tt DTF\_FUTURE} & Reference direction for relative dates is to the future\\ \hline
\end{rkrmtable}

The include file {\tt dos/datetime.h} define in addition also bit numbers
for the above flags that start with {\tt DTB} instead of {\tt DTF}. The
meaning of these flags are as follows:
\smallskip{}

{\tt DTF\_SUBST} allows, if set, the conversion to substitute dates nearby
today's date by descriptions relative to today. This flag is only honored when
converting a time and date in AmigaDOS representation to human-readable
strings. In particular, the following substitutions are made:
\smallskip{}

If the date provided is identical to the system date, the output date is set
to ``Today''.
\smallskip{}

If the date is one day later than the current system date, the output date
is set to ``Tomorrow''.
\smallskip{}

If the date is one day before te current system date, the output date is set
to ``Yesterday''.
\smallskip{}

If the date in the past week, the function substitutes it by the name of the
day of the week, e.g. ``Saturday''.
\medskip{}

{\tt DTF\_FUTURE} is only only honored when converting a string to the
AmigaDOS representation, that is into {\tt DateStamp} structure. It
indicates whether weekdays such as ``Monday'' are interpreted as dates in
the past, i.e. ``last Monday'', or as dates in the future, i.e. ``next
Monday''. If the flag is cleared, weekdays are interpreted as being in the
past, same as the {\tt DateToStr()}\key{DateToStr()} function would generate
them. If the flag is set, weekdays are assumed as references into the
future.
\medskip{}

{\tt dat\_StrDay}: This buffer is only used by converting {\tt DateStamps}
to strings, and --- if present --- is then filled by the week of the day,
e.g. ``Saturday''.
\smallskip{}

{\tt dat\_StrDate}: This element points to a buffer that is either filled
with the human-readable date, or is input to the conversion then containing
a human-readable date. The buffer is formatted, or expected to be formatted
according to {\tt dat\_Format} and {\tt dat\_Flags}.
\smallskip{}

{\tt dat\_StrTime}: This element points to a buffer that is either filled
with a human-readable time, or is the input time to be converted. AmigaDOS
expects here a 24h clock, hours, minutes and seconds in this order,
separated by colon, e.g. {\tt 21:47:16}.
\medskip{}

The functions in this section are patched by the \emph{locale.library} once
it is loaded, and then replaced the English strings by the corresponding
localized output. The localized versions may also accept (or provide)
different formats, such as four-digit years.

\subsection{Converting a Time and Date to a String} \label{sec:datetostr}

The {\tt DateToStr()} function converts a date and time into a human
readable string. The date and time, as well as formatting instructions are
given by a {\tt DateTime} structure.

\begin{verbatim}
success = DateToStr( datetime )
D0                      D1

BOOL DateToStr(struct DateTime *)
\end{verbatim}

This function takes the date and time in the AmigaDOS binary representation
contained in {\tt dat\_Stamp} of the passed in {\tt DateTime} structure
introduced in section~\ref{sec:dateconv} and converts it into human readable
strings. The elements of this structure shall be populated as follows:
\smallskip{}

{\tt dat\_Stamp} shall be initialized to the date and time to be converted.
\smallskip{}

{\tt dat\_Format} defines the format of the date string to create. It shall be
a value from table~\ref{table:dateformats}.
\smallskip{}

{\tt dat\_Flags} defines additional flags that control the conversion
process. This function only honors the {\tt DTF\_SUBST} flag which indicates
that {\tt DateToStr()} is supposed to represent the date relative to the
current system date if possible. That is, if possible, the date is
represented as ``today'', ``tomorrow'', ``yesterday'' or a weekday. Week
days always correspond to past days, e.g. ``Friday'' corresponds to the past
Friday, not a day in the future.
\smallskip{}

{\tt dat\_StrDay}: If this pointer is non-{\tt NULL}, it shall point to a
string buffer at least {\tt LEN\_DATSTRING} bytes large into which the day
of the week is filled, e.g. ``Saturday''.
\smallskip{}

{\tt dat\_StrDate}: If this pointer is non-{\tt NULL}, it shall also point
to a string buffer at least {\tt LEN\_DATSTRING} bytes large. This buffer
will then be filled by a description for the date according to the format
in {\tt dat\_Format} and {\tt dat\_Flags}.
\smallskip{}

{\tt dat\_StrTime}: This buffer, if the pointer is non-{\tt NULL}, is filled
by the time of the day, using a 24h clock. The format is always hours,
minutes, seconds, separated by colon.
\medskip{}

This function is patched by the \emph{locale.library} once it is loaded, and
then replaced the English output by the corresponding localized output.
\smallskip{}

The function returns~0 on error; the only source of error here is if {\tt
  dat\_Stamp} is invalid, e.g. the number of minutes is larger than $60
\times 24$ or the number of ticks is larger than $50 \times 60$. This makes
this function probably unsuitable to handle leap seconds correctly. This
function does not touch~{\tt IoErr()}, even in case of failure.

\subsection{Convert a String to a Date and Time}

The {\tt StrToDate()}\mkey{StrToDate()} function converts a date from a
human-readable string to its binary AmigaDOS representation.

\begin{verbatim}
success = StrToDate( datetime )
D0                      D1

BOOL StrToDate( struct DateTime * )
\end{verbatim}

This function takes a {\tt DateTime} structure as defined in
section~\ref{sec:dateconv} and converts the date and time strings
in this structure to a {\tt DateStamp} structure in {\tt dat\_Stamp}. In
particular, the elements of the {\tt DateTime} shall be initialized as
follows:
\smallskip{}

{\tt dat\_DateTime} may remain uninitialized and is rather filled by this
function with the converted date. In other words, this element is used to
provide the result of this function.
\smallskip{}

{\tt dat\_Format} shall be initialized by the format that is used by the
input date. Table~\ref{table:dateformats} lists the available input
formats. In particular, the ROM code within the \emph{dos.library} only
accepts two-digit years and interprets the anything between 78 and 99 as
1978 to 1999, and years between 00 and 45 as 2000 to 2045. It refuses all
other numbers. However, {\tt StrToDate()} is patched by the
\emph{locale.library} whose replacement implementation also accepts
four-digit years.
\smallskip{}

{\tt dat\_Flags} shall be initialized by a combination of the flags from
table~\ref{table:dateflags}. As {\tt StrToDate()} always accepts relative
dates such as ``yesterday'', the {\tt DTF\_SUBST} flag is ignored and only
{\tt DTF\_FUTURE} is honored. This flag indicates whether weekdays are
considered a date in the past or in the future.
\smallskip{}

{\tt dat\_StrDay} is ignored by this function. If a relative date given by a
day of a week is to be converted, this weekday goes directly into {\tt dat\_StrDate}.
\smallskip{}

{\tt dat\_StrDate}, if it is non-{\tt NULL}, points to a string describing
the date, in the format according to {\tt dat\_Format}. If this string is
not given, the output date is taken from the system date, i.e. is today's
date.
\smallskip{}

{\tt dat\_StrTime}, if it is non-{\tt NULL}, points to a human-readable
string describing the time of the day. This time shall be formatted as a 24h
clock, in the order hours, minutes and seconds, each separated by colon. If
this pointer is {\tt NULL}, the current system time is used.
\smallskip{}

This function returns non-zero on success, and~0 on error. It does not set
{\tt IoErr()} in case of error. Possible errors include ill-formatted input
strings the function cannot interpret.
\smallskip{}

Also note that this function is patched by the \emph{locale.library} once
loaded. It adds conventions of the current locale how dates and times are
supposed to be formatted. Interpretation of date and time will then follow
the conventions of this library.

\chapter{Files} \label{sec:file}

\section{What are Files?}
\emph{\mkey{File}Files} are streams of sequences of bytes that can be read from
and written to, along with a file pointer that points to the next byte
to be read, or the next byte to be written or overwritten. Files may
have an \emph{End-of-File position}, beyond which the file pointer can
not advance when reading bytes from it.

\section{Interactive vs. non-Interactive Files} \label{sec:interactive}

AmigaDOS knows two types of files: \emph{Interactive} and
\emph{non-interactive} files.
\smallskip{}

\emph{Non-interactive} files are stored on some persistent data carrier;
unless modified by a process\key{Process}, the contents of such non-interactive
files does not change. They also have a defined \emph{file size}. The
file size is the number of bytes between the start of the file and the
end-of-file position, or short \emph{EOF position}\mkey{EOF}. This file size
does not change unless some process\key{Process} writes to the file, which may or
may not be the same process that reads from the file.
\smallskip{}

Examples for non-interactive files are data on a disk, such as a
floppy or a harddisk. Such files have a name, possibly a path within a
hierarchical file system, and possibly multiple protection flags that
define which type of actions can be applied to a file; such flags
define whether the file can be read from, written to, and so on.
\smallskip{}

\emph{Interactive} files depend on the interaction of the computer
system with the outside world, and their contents can change due to
such interaction. Interactive files may not define a clear end-of-file
position, and an attempt to read from them or write to them may block
an indefinite amount of time until triggered by an external event.
\smallskip{}

Examples for interactive files are the console\key{Console}, where reading from it
depends on the user entering data in a console window and output
corresponds to printing to the console; or the serial port, where read
requests are satisfied by serial data arriving at the serial port and
written bytes are transmitted out of the port. The parallel port is
another example of an interactive file. Requests to read from it
result in an error condition, while writing prints data on a printer
connected to the port. Writing may block indefinitely if the printer
runs out of paper or is turned off.

\section{Paths and File Names} \label{sec:paths}
Files are identified by \emph{\mkey{Path}paths}, which are strings
from which AmigaDOS locates a process\key{Process} through which
access to the file is managed. Such a process is called the
\emph{\key{Handler}Handler} of the file, or, in case of files of on a
data carrier, also the \emph{\key{File System}File System}.  AmigaDOS
itself does not operate on files directly, but delegates such work to
its handler.
\smallskip{}

A \emph{path} is broken up into two parts: An optional device or
volume name terminated by a colon (``:''), followed by string that
identifies the file within the handler identified by the first part.
\smallskip{}

The first part, if present, is interpreted by AmigaDOS itself. It
relates to the name of a handler (or file system) of the given name,
or a known disk volume\key{Volume}, or a logical volume of the name
within the AmigaDOS \emph{device list}\key{Device List}. These concepts are
presented in further detail in section~\ref{sec:devicelist}.
\smallskip{}

The second, or only part is interpreted by the handler identified by
the first part.

\subsection{Devices, Volumes and Assigns}
The first part of a path, up to the colon, identifies the device, the
volume or the assign a file is located in.

\subsubsection{Devices} \label{sec:deviceoverview}
A \emph{\mkey{Device name}device name} identifies the handler or file
system directly. Handlers are typically responsible for particular
hardware units within the system, for example for the first floppy
drive, or the second partition of a harddisk. For example, {\tt df0}
is the name of the handler responsible for the first floppy drive,
regardless of which disk is inserted into it.
\smallskip{}

Table~\ref{table:romdevices} lists all devices AmigaDOS mounts itself
even without a boot volume available. They can be assumed present any
time.

\begin{rkrmtable}{System defined devices} \label{table:romdevices}
{\bf Device Name} & {\bf Description}\\ \hline \hline
{\tt DF0}              & First floppy drive\\ \hline
{\tt PRT}              & Printer\\ \hline
{\tt PAR}              & Parallel port\\ \hline
{\tt SER}              & Serial port\\ \hline
{\tt CON}              & Line-interactive console\\ \hline
{\tt RAW}              & Character based console\\ \hline
{\tt PIPE}             & Pipeline between processes\\ \hline
{\tt RAM}              & RAM-based file handler\\ \hline
\end{rkrmtable}

If more than one floppy drives are connected to the system, they are
named {\tt DF1} through {\tt DF3}. If a hard disk is present, then the device
name(s) of the harddisk partitions depend on the contents of Rigid
Disk Block, see~\ref{rkrmdev}. These names can be selected upon
installation of the harddisks, e.g. through \emph{HDToolBox}.  The
general convention is to name them {\tt DH0} and following.
\medskip{}

The following device names have a special meaning and do not belong to
a particular device:

\begin{rkrmtable}{System defined devices} \label{table:specialdevices}
{\bf Name} & {\bf Description} \\ \hline \hline
{\tt *}          & the console of the current process\\ \hline  
{\tt CONSOLE}    & the console of the current process\\ \hline
{\tt NIL}        & the data sink\\ \hline
\end{rkrmtable}

The {\tt NIL}\mkey{NIL} device is a special device without a handler
that is maintained by AmigaDOS itself. Any data written into it
vanishes completely, and any attempt to read data from it results in
an end-of-file\key{EOF} condition.
\smallskip{}

The {\tt *}\mkey{* (file name)}, if used as complete path name without
a trailing colon, is the current console of the process\key{Process}, if such a
console\key{console} exists. Any data output to the file named {\tt *} will be
printed on the console. Any attempt to read from {\tt *} will wait on
the user to input data on the console, and will return such data.

\punchline{Not a wildcard!}{Unlike other operating systems, the
  asterisk {\tt *} is \emph{not} a wildcard under AmigaDOS. It rather
  identifies the current console of a process, or is used as escape
  character in AmigaDOS shell scripts}.

The {\tt CONSOLE}\mkey{CONSOLE (device)} device is the default console
of the process\key{Process}. Unlike {\tt *}, but like any other device name, it
shall be followed by a colon, and an optional job name. Such job names
form \emph{logical consoles} that are used by the shell for job
control purposes.

\punchline{Prefer the stars}{The difference between {\tt *} and {\tt
    CONSOLE} is subtle, and the former should be preferred as it
  identifies the process as part of a particular shell job. An attempt
  to output to {\tt CONSOLE:} may block the current process as it does
  not identify it properly as part of its job, but rather denotes the
  job started when creating the shell. Thus, in case of doubt, use the
  {\tt *} without any colon if you mean the console.}

Additional devices can be loaded into the system by the \emph{Mount}\key{Mount}
command, see section~\ref{sec:handlers}.

\subsubsection{Volumes} \label{sec:volumelist}
A \emph{\mkey{Volume name}volume name} identifies a particular data
carrier within a physical drive. For example, it may identify a
particular floppy disk, regardless of the drive it is inserted it. For
example, the volume name ``Workbench3.2'' relates always to the same
floppy, regardless of whether it is inserted in the first {\tt df0} or
second {\tt df1} drive.

\subsubsection{Assigns} \label{sec:assignlist}
An \emph{\mkey{Assign}assign} or \emph{logical volume} identifies a
subset of a files within a file system under a unique name. Such
assigns are created by the system or by the user helping to identify
portions of the file system containing files that are of particular
relevance for the system. For example, the assign {\tt C} contains all
commands of the boot shell, and the assign {LIBS} contains dynamically
loadable system libraries. Such assigns can be changed or redirected, and by that
the system can be instructed to take system resources from other parts of a file system,
or entirely different file systems.
\medskip{}

Assigns can be of three types: \emph{Regular assigns},
\emph{non-binding assigns} and \emph{late assigns}. \emph{Regular
  assigns} bind to a particular directory on a particular volume. If
the \emph{assign} is accessed, and the original volume the bound
directory is not available, the system will ask to insert this
particular volume, and no other volume will be accepted.
\smallskip{}

\emph{Regular assigns} can also bind to multiple directories at once,
in which case a particular file or directory within such a
\emph{multi-assign} is searched in all directories bound to the
assign. A particular use case for this is the {\tt FONTS} assign,
containing all system-available fonts. Adding another directory to
{\tt FONTS} makes additional fonts available to the system without
loosing the original ones.
\smallskip{}

\emph{Regular assigns} have the drawback that the volume remains known
to the system, and the corresponding volume icon will not vanish from
the workbench. They also require the volume to be present at the time
the assign is created.
\smallskip{}

\emph{Non-binding assigns} avoid these problems by only storing the
symbolic path the assign goes to; whenever the assign is accessed, any
volume of the particular name containing the particular path will
work. However, if this also implies that the target of the assign is
not necessarily consistent, i.e. if the assign is accessed later on,
another volume with different content will be accepted by the system.
\smallskip{}

\emph{Late assigns} are a compromise between \emph{regular assigns}
and \emph{non-binding assigns}. AmigaDOS initially only stores a
target path for the assign, but when the assign is accessed the first
time, the assign is converted to a \emph{regular assign} and thus then
binds to the particular directory of the particular volume that was
inserted at the time of the first access.
\medskip{}

Table~\ref{table:romassigns} lists the assigns made by AmigaDOS
automatically during bootstrap; except for the {\tt SYS} assign, they
all go to a directory of the same name on the boot volume. They are
all \emph{regular assigns}, except for {\tt ENVARC}, which is
\emph{late assign}.

\begin{rkrmtable}{System defined assigns} \label{table:romassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt C}           & Boot shell commands\\ \hline
{\tt L}           & AmigaDOS handlers and file systems\\ \hline
{\tt S}           & AmigaDOS Scripts \\ \hline
{\tt LIBS}        & AmigaOs libraries \\ \hline
{\tt DEVS}        & AmigaOs hardware drivers \\ \hline
{\tt FONTS}       & AmigaOs fonts \\ \hline
{\tt ENVARC}      & AmigaOs preferences (late)\\ \hline
{\tt SYS}         & The boot volume \\ \hline
\end{rkrmtable}

In addition to the above table, the following assigns are handled by
AmigaDOS internally and are not part of the \emph{device
  list}\key{Device list}, (see section \ref{sec:devicelist}):

\begin{rkrmtable}{System defined assigns} \label{table:specialassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt PROGDIR}     & Location of the executable\\ \hline
\end{rkrmtable}

Thus, {\tt PROGDIR}\mkey{PROGDIR} is the directory the currently
executed binary was loaded from. Note that {\tt PROGDIR} does not
exist in case an executable file was not loaded from disk, probably
because it was either taken from ROM or was made resident. More on
resident executables is found in section~\ref{sec:commands}.
\smallskip{}

Additional assigns can become necessary for a fully operational
system, though these assigns are created through the
\emph{Startup-sequence}\key{Startup-Sequence}, a particular AmigaDOS
script residing in the S assign which is executed by the boot shell.
Table~\ref{table:startupassigns} lists some of them.

\begin{rkrmtable}{Assigns made during bootstrap} \label{table:startupassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt ENV}         & Storage for active preferences and global variables\\ \hline
{\tt T}           & Storage for temporary files\\ \hline
{\tt CLIPS}       & Storage for clipboard contents\\ \hline
{\tt KEYMAPS}     & Keymap layouts\\ \hline
{\tt PRINTERS}    & Printer drivers\\ \hline
{\tt REXX}        & ARexx scripts\\ \hline
{\tt LOCALE}      & Catalogs and localization\\ \hline
\end{rkrmtable}

Additional assigns can always be made with the
\emph{Assign}\key{Assign} command, see section~\ref{sec:handlers}.

\subsection{Relative and Absolute Paths}

As introduced in section~\ref{sec:paths}, a path consists either of an
device, volume or assign name followed by a colon followed by a second
part, or the second part alone. If a device, volume or assign name is
present, such a path is said to be an \emph{absolute path} because it
identifies a location within a logical or physical volume.
\smallskip{}

If no first part is present, or if it is empty, i.e. the colon is the
first part of the path, AmigaDOS uses information from the calling
process\key{Process} to identify a suitable handler. Details on this are provided
in section~\ref{sec:process}. Such a path is called a
\emph{relative path}.
\smallskip{}

This second part is forwarded to the handler and is not interpreted by
the \emph{dos.library}. It is then within the responsibility of the
handler to interpret this path and locate a file within the data
carrier it manages, or to configure an interface to the outside world
according to this path.
\smallskip{}

In general, the \emph{dos.library} does not impose a particular syntax
on how this second part looks like. However, several support functions
of AmigaDOS implicitly define conventions file systems should follow
to make these support functions workable and it is therefore advisable
for file system implementors to follow these conventions.

\subsection{Maximum Path Length} \label{sec:pathlimit}

The \emph{dos.library} does not enforce a limit on the size of file or
directory names, except that the total length of a path including all
of its components shall not be larger than 255 characters. This is
because it is converted to a BSTR within the
\emph{dos.library}. How large a component name can be is a matter of
the file system itself. The \emph{Fast File System} includes variants
that limit file names to 30, 56 or 106 characters.
\smallskip{}

File systems typically do not report an error if the maximum file
name is exceeded; instead, the name is clamped to the maximum size
without further notice, which may lead to undesired side effects. For
example, a file system may clip or remove a trailing {\tt .info} from
a workbench icon file name without ever reporting this, resulting in
unexpected side effects. The \emph{icon.library} and
\emph{workbench.library} of AmigaOs take care to avoid such file names
and double check created objects for correct names.

\subsection{Flat vs. Hiearchical File Systems} \ref{sec:flathierarchical}
A flat file system organizes files as a single list of all files
available on a physical data carrier. For large amounts of files, such
a representation is clearly burdensome as files may be hard to find
and hard to identify.
\smallskip{}

For this reason, all file systems provided by AmigaOs are
\emph{hierarchical} and organize files in nested sets of
\emph{directories}\mkey{Directory}, where each directory contains
files or additional directories. The topmost directory of a volume forms
the \emph{root directory}\mkey{Root Directory} of this volume.
\smallskip{}

While AmigaDOS itself does not enforce a particular convention, all
file systems included in AmigaDOS follow the convention that a path
consists of a sequence of zero or more directory names separated by a
forwards slash (``/''), and a final file or directory name.

\subsubsection{Locating Files or Directories} \label{sec:locate}

When attempting to locate a particular file or directory, the
\emph{dos.library} first checks whether an absolute path name is
present. If so, it starts from the root directory on the device,
physical or logical volume identified by the device or volume name and
delegates the interpretation of the path to the handler.
\smallskip{}

Otherwise, it uses the \emph{current directory} of the calling
process\key{Process} to locate a handler responsible for the
interpretation of the path name. If this current directory is {\tt
  ZERO} (see section~\ref{sec:bptrs}), it uses the \emph{default file
  system}\key{Default file system} of the process, which by itself,
defaults to the boot file system.
\smallskip{}

The second part of the path interpretation is up to the file system
identified by the first step and is performed there, outside of the
\emph{dos.library}. If the path name includes a colon (``:''), then locating
a file starts from the root of the inserted volume. This also includes
the special case of an absent device or volume name, though a present
colon, i.e. ``:'' represents the root directory of the volume to which
the current directory belongs.
\medskip{}

The following paragraphs describe a recommended set of operations an
AmigaDOS file system should follow. A path consists of a sequence of
components separated by forward slashes (``/'').
\smallskip{}

To locate a file, the file system should work iteratively through the
path, component by component: A single isolated ``/'' without a
preceding component indicates the parent directory of the current
directory. The parent directory of the root directory is the root
directory itself.
\smallskip{}

Otherwise, a component followed by ``/'' instructs the handler to enter
the directory of given by the component, and continue searching there.
\smallskip{}

Scanning terminates when the file system reaches the last component. The
file or directory to find is then the given by the last component
reached during the scan.
\smallskip{}

As scanning through directories starts with the current directory and
stops when the end of the path has been reached, the empty string
indicates the current directory.

\punchline{No Dots Here}{Unlike other operating systems, AmigaDOS does
  not use ``.'' and ``..'' to indicate the current directory or the
  parent directory. Rather, the current directory is represented by
  the empty string, and the parent directory is represented by an
  isolated forwards slash without a preceding component.}

Thus, for example, ``:S'' is a file or directory named ``S'' in the
root directory of the current directory of the process, and
``//Top/Hi'' is a file or directory named ``Hi'' two directories up
from the current directory, in a directory named ``Top''.

\subsection{Case Sensitivity}

The \emph{dos.library} does not define whether file names are
case-sensitive or insensitive, except for the device or volume name
which is case-insensitive. Most if not all AmigaDOS file-systems are
also case-insensitive, or rather should. Some variants of the
\emph{Fast File System} do not handle case-insensitive comparisons
correctly on non-ASCII characters, i.e. ISO-Latin code points whose
most-significant bit is set, see section~\ref{sec:ffs} for
details. These variants should be avoided and the ``international''
variants should be preferred.

\section{Opening Files} \label{sec:open}
To read data from or write data to a file, it first needs to be opened
by the {\tt Open()}\mkey{Open()} function:

\begin{verbatim}
file = Open( name, accessMode )
D0           D1    D2

BPTR Open(STRPTR, LONG)
\end{verbatim}
The {\tt name} argument is the \emph{path} the file to be opened,
which is interpreted according to the rules given in
section~\ref{sec:paths}. The argument {\tt accessMode} identifies how
the file is opened. The function returns a {\tt BPTR} to a
\emph{file handle} on success, or {\tt ZERO} on failure. A secondary return
code can be retrieved from {\tt IoErr()} described in
section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case opening the file failed.
\smallskip{}

The access mode shall be one of the following, defined in {\tt dos/dos.h}:

\begin{rkrmtable}{Access Modes for Opening Files} \label{table:openmodes}
{\bf Access Name} & {\bf Description}\\ \hline \hline
{\tt MODE\_OLDFILE}   & Shared access to existing files\\ \hline
{\tt MODE\_READWRITE} & Shared access to new or existing files\\ \hline
{\tt MODE\_NEWFILE}   & Exclusive access to new files\\ \hline
\end{rkrmtable}

\punchline{Length Limited}{As this function needs to convert the path
  argument from a C string to a BSTR, path names longer than 255
  characters are not supported and results are unpredictable if such
  names are passed into Open(). If such long path names cannot be
  avoided, it is the responsibility of the caller to split the path
  name accordingly and potentially walk through the directories
  manually if necessary. Note that this strategy may not be suitable
  for interactive files or handlers that follow conventions for the
  path name that are different from the conventions described in
  section~\ref{sec:locate}.}

The access mode {\tt MODE\_OLDFILE}\mkey{MODE\_OLDFILE} attempts to find an existing
file. If the file does not exist, the function fails. If the file
exists, it can be read from or written from, though simultaneous
access from multiple processes is possible and does not create an
error condition. If multiple processes write to the same file
simultaneously, the result is undefined and no particular order of the
write operations is imposed.
\smallskip{}

The access mode {\tt MODE\_READWRITE}\mkey{MODE\_READWRITE} first attempts to find an
existing file, but if the file does not exist, it will be created
under the name given by the last component of the path. The function
does not attempt to create directories within the path if they do not
access. Once the file is opened, access to the file is shared, even if
it has been just created. That is, multiple processes may then access
it for reading or writing. If multiple processes write to the file
simultenously, the order in which the writes are served is undefined
and depends on the scheduling of the processes.
\smallskip{}

The access mode {\tt MODE\_NEWFILE}\mkey{MODE\_NEWFILE} creates a new file, potentially
erasing an already existing file of the same name if it already
exists. The function does not attempt to create directories within the
path if they do not exist. Access to the file is exclusive, that is,
any attempt to access the file from a second process fails with an
error condition.

\punchline{No Wildcards}{The Open() function, similar to most
  \emph{dos.library} functions, does not attempt to resolve wild cards. That
  is, any character potentially reassembling a wild card, such as
  ``?'' or ``\#'' will taken as a literal and will be used as part of
  the file name. While these characters are valid, they should be
  avoided as they make such files hard to access from the Shell.}

\section{Closing Files}

The {\tt Close()}\mkey{Close()} function writes all internally
buffered data to disk and makes an exclusively opened file accessible
to other processes again.

\begin{verbatim}
success = Close( file )
D0               D1

BOOL Close(BPTR)
\end{verbatim}

The {\tt file} is a BPTR to a \emph{FileHandle} identifying the file. The
return code indicates whether the file system could successfully close
the file and write back any data. If the result code is {\tt DOSFALSE},
an error code can be obtained through {\tt IoErr()} described in
section~\ref{sec:misc}. Otherwise, {\tt IoErr()} will not be altered.
\smallskip{}

Unfortunately, not much can be done if closing a file fails and no
general advise is possible how to handle this situation.
\smallskip{}

Attempting to close the {\tt ZERO} file handle returns success
immediately.

\section{Types of Files and Handlers}

As introduced in \ref{sec:interactive}, AmigaDOS distinguishes between
non-interactive files managed by file systems and interactive files
that interact with the outside world. Typically, \emph{file
  systems}\key{File System} create non-interactive files; all other
\emph{handlers}\key{Handlers} create interactive or non-interactive
files, depending on the nature of the handler.

\subsection{Obtaining the Type from a File} \label{sec:isinteractive}

A file can be either interactive, in which case attempts to read or
write data to the file may block indefinitely, or non-interactive
where the amount of available data is determined by file itself. The
{\tt IsInteractive()} function returns the nature of an already opened
file.

\begin{verbatim}
status = IsInteractive( file )
 D0                      D1

BOOL IsInteractive(BPTR)
\end{verbatim}

The {\tt IsInteractive()}\mkey{IsInteractive()} function returns
{\tt TRUE} in case the \emph{file handle} passed in is interactive, or
{\tt FALSE} in case it corresponds to a non-interactive stream of
bytes, potentially on a file system.
This function cannot fail and does not alter {\tt IoErr()}.

\subsection{Obtaining the Type from a Path}

A \emph{handler}\key{handler} that manages physical data carriers and
allows to access named files on such data carriers is a \emph{file
  system}. The {\tt IsFileSystem()}\key{IsFileSystem()} function
determines the nature of a handler given a path (see~\ref{sec:paths})
to a candidate handler.

\begin{verbatim}
result = IsFileSystem(name)
D0                     D1

BOOL IsFileSystem(STRPTR)
\end{verbatim}
The {\tt name} argument is a path that does not need to identify a
physically existing object. Instead, it is used to identify a handler
that would be responsible to such a hypothetical object regardless
whether it exists or not.
\smallskip{}

It is of advisable to provide a path that identifies the handler
uniquely, i.e. a string that is terminated by a colon (``:''). Otherwise,
the call checks whether the \emph{handler} responsible for the current
directory of the calling process is a file system.
\smallskip{}

The returned result is {\tt DOSTRUE} in case the handler identified by the
path is a file system, and as such allows access to multiple files on a
physical data carrier and examining directories. Otherwise, it
returns {\tt DOSFALSE}.

\section{Unbuffered Input and Output} \label{sec:unbuffered}

The functions described in this section read bytes from or write bytes
to already opened files. These functions are \emph{unbuffered}, that
is, any request goes directly to the handler. Since a request performs
necessarily a task switch from the caller to the handler managing the
file, these functions are inefficient on small amounts of data and
should be avoided. Instead, files should be read or written in larger
chunks, either by buffering data manually, or by using the buffered
I/O functions described in section~\ref{sec:buffered}.

\subsection{Reading Data}
The following function reads data from an opened file by directly
invoking the handler for performing the read:

\begin{verbatim}
actualLength = Read( file, buffer, length )
D0                   D1    D2      D3

LONG Read(BPTR, void *, LONG)
\end{verbatim}

The {\tt Read()}\mkey{Read()} function reads {\tt length} bytes from an opened
file identified by the \emph{file handle} {\tt file} into the buffer pointed
to by {\tt buffer}. The buffer is a standard C pointer, not a BPTR.
\smallskip{}

The return code {\tt actualLength} is the amount of bytes actually
read, or -1 for an error condition. A secondary return
code can be retrieved from {\tt IoErr()} described in
section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case reading failed.
\smallskip{}

The amount of data read may be less data than requested by the {\tt
  length} argument, either because the \emph{EOF} position has been
reached (see section \ref{sec:interactive}) for non-interactive files,
or because the interactive source is depleted. Note that for
interactive files, the function may block indefinitely until data
becomes available.

\subsection{Testing for Availability of Data}

An issue of the {\tt Read}function is that it may block indefinitely
on an interactive file if the user does not enter any data. The {\tt
  WaitForChar()}\mkey{WaitForChar()} tests for the availability of a
character on an interactive file for limited amount of time and
returns if no data becomes available.

\begin{verbatim}
status = WaitForChar( file, timeout )
  D0                    D1    D2

BOOL WaitForChar(BPTR, LONG)
\end{verbatim}

This function waits for a maximum of {\tt timeout} microseconds for
the availability of input on {\tt file}. If data is already available,
or becomes available within this time, the function returns
{\tt DOSTRUE}. Otherwise, the function returns {\tt DOSFALSE}.
\smallskip{}

A secondary return code can be obtained from {\tt IoErr()}. If it is
$0$, the handler was able check the availability of a byte from the
given file. Otherwise, an error code from {\tt dos/dos.h} indicates
failure of the function.
\smallskip{}

This function requires an interactive file to operate, file systems
will typically not implement this function as they do not block.

\subsection{Writing Data}
The following call writes an array of bytes unbuffered to a file,
interacting directly with the corresponding handler:

\begin{verbatim}
returnedLength =  Write( file, buffer, length )
 D0                       D1    D2      D3

LONG Write (BPTR, void *, LONG)
\end{verbatim}

The Write\mkey{Write} function writes {\tt length} bytes in the buffer
pointed to by {\tt buffer} to the \emph{file handle} given by the {\tt file}
argument. On success, it returns the number of bytes written as {\tt
  returnedLength}, and advances the file pointer of the file by this
amount. Note that this amount of bytes may even be 0 in case the file
cannot absorb any more bytes. On error, $-1$ is returned.
\smallskip{}

A secondary return code can be retrieved from {\tt IoErr()} described
in section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case writing failed.
\smallskip{}

For interactive files, this function may block indefinitely until the
corresponding handler is able to take additional data.

\subsection{Adjusting the File Pointer}

The {\tt Seek()}\mkey{Seek()} adjusts the file pointer of a
non-interactive file such that subsequent reading or writing is
performed from an alternative position of the file.

\begin{verbatim}
oldPosition = Seek( file, position, mode )
 D0                  D1    D2        D3

LONG Seek(BPTR, LONG, LONG)
\end{verbatim}

This function adjusts the file pointer of {\tt file} relative to the
position determined by {\tt mode} by {\tt position} bytes. The value
of {\tt mode} shall be one of the following options, defined in
{\tt dos/dos.h}:

\begin{rkrmtable}{Seek Modes} \label{table:seekmode}
{\bf Mode Name} & {\bf Description}\\ \hline \hline
{\tt OFFSET\_BEGINNING} & Seek relative to the start of the file\\ \hline
{\tt OFFSET\_CURRENT}   & Seek relative to the current file position\\ \hline
{\tt OFFSET\_END}       & Seek relative to the end of the file\\ \hline
\end{rkrmtable}

\punchline{Undefined on Interactive Files}{The {\tt Seek} function
  will typically indicate failure if applied to interactive
  files. Some handlers may assign this function, however, a particular
  meaning. See the handler definition for details.}
  
If {\tt mode} is {\tt OFFSET\_BEGINNING}, then the new file pointer is
placed {\tt position} bytes from the start of the file, i.e. the new
file pointer is equal to {\tt position}.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_CURRENT}, then {\tt position} is added
to the file pointer. That is, the file pointer is advanced if
{\tt position} is positive, or rewinded if {\tt position} is negative.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_END}, then the end-of-file
position\key{EOF} is determined, and {\tt position} is added to this
position. This, in particular, requires that {\tt position} should be
negative.
\smallskip{}

The {\tt Seek()} function returns the file pointer before its
adjustment, or $-1$ in case of an error.
\smallskip{}

A secondary return code can be retrieved from {\tt IoErr()} described
in section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case adjusting the file pointer failed.

\punchline{Not 64bit safe}{Unfortunately, it is not quite clear how
  {\tt Seek} operates on files that are larger than 2GB, and it is
  file system dependent how such files could be handled. {\tt
    OFFSET\_BEGINNING} can probably only reach the first 2GB of a
  larger file as the file system may interpret negative values as an
  attempt to reach a file position upfront the start of the file and
  may return an error. Similarly, {\tt OFFSET\_END} may possibly only
  reach the last 2GB of the file. Any other position within the file
  may be reached by splitting the seek into chunks of at most 2GB and
  perform multiple {\tt OFFSET\_CURRENT} seeks. However, whether such a
  strategy succeeds is pretty much file system dependent. Note in
  particular that the return code of the function does not allow to
  distinguish between a file pointer just below the 4GB barrier and an
  error condition. A zero result code of {\tt IoErr()} should be then
  used to learn whether a result of -1 indicates a file position of
  {\tt 0xffffffff} instead. Most AmigaDOS file systems may not be able
  to handle files larger than 2GB.}

Even though {\tt Seek()} is an unbuffered function, it is aware of a
buffer and implicitly flushes the file system internal buffer. That
is, it can be safely used by buffered and unbuffered functions.

\subsection{Setting the Size of a File} \label{sec:setfilesize}

The {\tt SetFileSize()}\mkey{SetFileSize()} function truncates or
extends the size of an opened file to a given size. Not all handlers
support this function.

\begin{verbatim}
newsize = SetFileSize(fh, offset, mode)
D0                    D1    D2     D3

LONG SetFileSize(BPTR, LONG, LONG)
\end{verbatim}
This function extends or truncates the size of the file identified by
the \emph{file handle} {\tt fh}; the target size is determined by the
current file pointer, {\tt offset} and the {\tt mode}. Interpretation
of {\tt mode} and {\tt offset} is similar to {\tt Seek()}, except that
the end-of-file position\key{EOF} of the file is adjusted, and not the
file pointer.
\medskip{}

The {\tt mode} shall be selected from to
table~\ref{table:seekmode}. In particular, it is interpreted as
follows:
\smallskip{}

If {\tt mode} is {\tt OFFSET\_BEGINNING}, then the file size is set to
the value of {\tt offset}, irrespectible of the current file pointer.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_CURRENT}, then the new end-of-file position
is set {\tt offset} bytes relative to the current file pointer. That
is, the file is truncated if {\tt offset} is negative, and extended if
{\tt offset} is positive.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_END}, the new file size is given by the
current file size plus {\tt offset}. That is, the file is extended by
{\tt offset} bytes if positive, or truncated otherwise. The value of the
current file pointer is irrelevant and ignored.
\smallskip{}

If the current file pointer of any \emph{file handle} opened on the
same file is, after a potential truncation, beyond the new
end-of-file, it is clamped to the end-of-file. They remain unchanged
otherwise.
\smallskip{}

If the file is enlarged, the values within the file beyond the
previous end-of-file position are undetermined.
\smallskip{}

The return value {\tt newsize} is the size of the file after the
adjustment, i.e. the position of the end-of-file location.

\punchline{Not 64bit safe}{Similar to {\tt Seek()},
  {\tt SetFileSize()} cannot be assumed to work properly if the (old or
  new) file size is larger than 2GB. What exactly happens if an
  attempt is made to adjust the file by more than 2GB depends on
  the file system performing the operation. A possible strategy to
  adjust the file size to a value above 2GB is to first seek to the
  closest position, potentially using multiple seeks of maximal size,
  and then perform one or multiple calls to {\tt SetFileSize()} with
  the {\tt mode} set to {\tt OFFSET\_CURRENT}. However, whether this
  strategy succeeds is file system dependent.}

\section{Buffered Input and Output} \label{sec:bufferedio}

AmigaDOS also offers buffered input and output functions that stores
data in an intermediate buffer. AmigaDOS then transfers data only in
larger chunks between the buffer and the handler, minimizing the task
switching overhead and offering better performance if data is to be
read or written in smaller units.

\punchline{Performance Improved}{While buffered I/O functions of
  AmigaOs 3.1.4 and below were designed around single-byte functions
  and thus caused massive overhead in the buffered functions described
  in this section, the functions in this section were redesigned in
  AmigaOs 3.2 and now offer significantly better
  performance. Unfortunately, the default buffer size AmigaDOS uses is
  quite small and should be significantly increased by
  {\tt SetVBuf()}\key{SetVBuf()}. A suggested buffer size is 4096 bytes
  which corresponds to a disk block of modern hard drives.}

\subsection{Buffered Read From a File}

The {\tt FRead()}\mkey{FRead()} function reads multiple equally-sized
records from a file through a buffer, and returns the number of
records retrieved.

\begin{verbatim}
count = FRead(fh, buf, blocklen, blocks)
 D0           D1  D2     D3        D4

LONG FRead(BPTR, STRPTR, ULONG, ULONG)
\end{verbatim}

This function reads {\tt blocks} records each of {\tt blocklen} bytes
from the file {\tt fh} into the buffer {\tt buf}. It returns the
number of complete records retrieved from the file. If the file runs
out of data, the last record may be incomplete.
\smallskip{}

From AmigaOs 3.2 onwards, {\tt FRead()} first attempts to satisfy the
request from the file handle internal buffer, but if the number of
remaining bytes is larger than the buffer size, the handler will be
invoked directly for ``bursting'' the data into the target buffer,
bypassing the file buffer.
\smallskip{}

This function does not modify {\tt IoErr()}\key{IoErr()} in case the
request can be satisfied completely from the file handle buffer. It
neither returns $-1$ in case of an error. Callers should instead use
{\tt SetIoErr(0)} to clear the error state before calling this
function, and then use {\tt IoErr()} to learn if any error occurred if
the number of records read is smaller than the number of records
requested.

\subsection{Buffered Write to a File}

The {\tt FWrite()}\mkey{FWrite()} function writes multiple equally-sized
records to a file through a buffer, and returns the number of
records it could write.

\begin{verbatim}
count = FWrite(fh, buf, blocklen, blocks)
D0             D1  D2     D3        D4

LONG FWrite(BPTR, STRPTR, ULONG, ULONG)
\end{verbatim}

This function write {\tt blocks} records each of {\tt blocklen} bytes
from the buffer {\tt buf} to the file {\tt fh}. It returns the number
of complete records written to the file. On an error, the last record
written may be incomplete.
\smallskip{}

From AmigaOs 3.2 onwards, {\tt FWrite()} first checks whether the file
handle internal buffer is partially filled. If so, the file handle
internal buffer is filled from {\tt buf}. If any bytes remain to be
written, and the number of bytes is larger than the internal buffer
size, the handler will be invoked to write the data in a single block,
bypassing the buffer. Otherwise, the data will be copied to the
internal buffer.
\smallskip{}

This function does not modify {\tt IoErr()}\key{IoErr()} in case the
request can be satisfied completely by using the file handle
buffer. It neither returns $-1$ in case of an error. Callers should
instead use {\tt SetIoErr(0)} to clear the error state before calling
this function, and then use {\tt IoErr()} to learn if any error
occurred if the number of records written is smaller than the number of
records passed in.

\subsection{Buffered Write to the Output Stream}

The {\tt WriteChars()}\mkey{WriteChars()} writes an array of bytes buffered
to the output stream. 

\begin{verbatim}
count = WriteChars(buf, buflen)
D0                 D1   D2

LONG WriteChars(STRPTR, LONG)
\end{verbatim}

This function is equivalent to {\tt FWrite(Output(),buf,1,buflen)}, that is,
the bytes in the buffer {\tt buf} of size {\tt buflen} is writing to the
output stream, and the number of characters written is returned. Therefore,
this function has similar quirks concerning error reporting as {\tt
  FWrite()}\key{FWrite()}: It does not set {\tt IoErr()}\key{IoErr()}
consistently, namely only when the buffer is written to the stream. It
neither returns~$-1$ on an error. It is therefore recommended to reset the
error upfront with {\tt SetIoErr(0)}\key{SetIoErr()}.

\subsection{Adjusting the Buffer}

The {\tt SetVBuf()}\mkey{SetVBuf()} function allows to adjust the
internal buffer size for buffered input/output functions such as {\tt
  FRead()}\key{FRead()} or {\tt FWrite()}\key{FWrite()}. It also sets
the buffer mode. The default buffer size is 204 characters, which is
too low for many applications.

\begin{verbatim}
error = SetVBuf(fh, buff, type, size)
D0              D1   D2    D3    D4

LONG SetVBuf(BPTR, STRPTR, LONG, LONG)
\end{verbatim}

This function sets the internal buffer of the \emph{file handle}
{\tt fh} to {\tt size} bytes. Sizes smaller than 204 characters will be
rounded up to 204. If {\tt buff} is non-{\tt NULL}, it is a pointer to
a user-provided buffer that will be used for buffering. This buffer
shall be aligned to a 32-bit boundary. A user provided buffer will not
be released when the file is closed.
\smallskip{}

Otherwise, if {\tt buff} is {\tt NULL} AmigaDOS will allocate the
buffer for you, and will also release it when the file is closed.
\smallskip{}

The {\tt type} argument identifies the type of buffering according to
Table~\ref{table:buffmode}; the modes there are defined in the include
file {\tt dos/stdio.h}.

\begin{rkrmtable}{Buffer Modes} \label{table:buffmode}
{\bf Buffer Name} & {\bf Description}\\ \hline \hline
{\tt BUF\_LINE} & Buffer up to end of line\\ \hline
{\tt BUF\_FULL} & Buffer everything\\ \hline
{\tt BUF\_NONE} & No buffering\\ \hline
\end{rkrmtable}

The buffer mode {\tt BUF\_LINE} automatically flushes the buffer when
writing a line feed (0x0a), carriage return (0x0c) or ASCII NUL (0x00)
character to the buffer, and the target file is
interactive. Otherwise, the characters remain in the buffer until it
either overflows or is flushed manually, see {\tt Flush()}\key{Flush()}.
\smallskip{}

The buffer mode {\tt BUF\_FULL} buffers all characters until the
buffer either overflows or is flushed.
\smallskip{}

The buffer mode {\tt BUF\_NONE} effectively disables the buffer and
writes all characters to the target file immediately.
\smallskip{}

On reading, {\tt BUF\_LINE} and {\tt BUF\_FULL} are equivalent and
fill the entire buffer from the file; {\tt BUF\_NONE} disables
buffering.
\medskip{}

The function returns non-zero on success, or $0$ on error. Error
conditions are either out-of-memory, an invalid buffer mode or an
invalid file handle. Unfortunately, {\tt IoErr()} is only set on an
out-of-memory condition and remains otherwise unchanged.

\subsection{Synchronize the File to the Buffer}

The {\tt Flush()}\mkey{Flush()} function flushes the internal buffer
of a \emph{file handle} and synchronizes the file pointer to the
buffer position.

\begin{verbatim}
success = Flush(fh)
D0              D1

LONG Flush(BPTR)
\end{verbatim}

Synchronizes the file pointer to the buffer, that is, if bytes were
written to the buffer, writes out buffer content to file. If bytes
were read from the file and non-read files remained in the buffer,
such bytes are dropped and the function attempts to seek back to the
position of the last read byte. This can fail for interactive files.
\smallskip{}

The return code is currently always {\tt DOSTRUE} and thus cannot be
used as an indication of error, even if not all bytes could be
written, or if seeking failed. If error detection is desired, the
caller should first use {\tt SetIoErr(0)}\key{SetIoErr()} to erase an
error condition, then call flush, and then use {\tt IoErr()} to
check whether an error occurred.

\punchline{Flush when switching between reading and writing}{The {\tt
    Flush()} function shall be called when switching from writing to a
  file to reading from the same file, or vice versa. The internal
  buffer logic is unfortunately not capable to handle this case
  correctly. Also, {\tt Flush()} shall be called when switching from
  buffered to unbuffered input/output.}

\subsection{Write a Character Buffered to a File}

The {\tt FPutC()}\mkey{FPutC()} function writes a single character to
a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
char = FPutC(fh, char)
D0           D1   D2

LONG FPutC(BPTR, LONG)
\end{verbatim}

This function writes the single character {\tt char} to the \emph{file
  handle} {\tt fh}.  Depending on the buffer mode, the character and
the type of file, the character may go to the buffer first, or may
cause the buffer to be emptied. See {\tt SetVBuf()}\key{SetVBuf()} for
details on buffer modes and conditions for implicit buffer flushes.
\smallskip{}

It returns the character written, or {\tt ENDSTREAMCH} on an
error. The latter constant is defined in {\tt dos/stdio.h} and equals
to $-1$.
\smallskip{}

This function does not touch {\tt IoErr()} if the character only goes
into the internal buffer. 

\subsection{Write a String Buffered to a File}

The {\tt FPuts()}\mkey{FPuts()} function writes a {\tt NUL}-terminated
string to a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
error = FPuts(fh, str)
D0            D1  D2

LONG FPuts(BPTR, STRPTR)
\end{verbatim}

This function writes the NUL-terminated (C-style) string {\tt str} to
the \emph{file handle} {\tt fh}. The terminating {\tt NUL} character
is not written.
\smallskip{}

Depending on the buffer mode, the string will first go into the
buffer, or may be written out immediately. See
{\tt SetVBuf()}\key{SetVBuf()} for details on buffer modes and conditions
for implicit buffer flushes.
\smallskip{}

This function returns $0$ on success, or {\tt ENDSTREAMCH} on an error. The
latter constant is defined in {\tt dos/stdio.h} and equals to~$-1$. The
error code {\tt IoErr()}\key{IoErr()} is only adjusted when the buffer is
flushed.

\subsection{Write a String Buffered to the Output Stream}

The {\tt PutStr()}\mkey{PutStr()} function writes a {\tt NUL}-terminated
string to the output. No newline is appended.

\begin{verbatim}
error = PutStr(str)
D0             D1

LONG PutStr(STRPTR)
\end{verbatim}

This function is equivalent to {\tt FPuts(Output(),str)}, that is, it writes
the {\tt NUL}-terminated string pointed to by {\tt str} to the output. It
returns~$0$ on success and~$-1$ on error. The {\tt IoErr()}\key{IoErr()} is
only adjusted when the buffer of the {\tt Output()}\key{OutPut()}
\emph{FileHandle} is flushed. When this happens depends on the buffer mode
installed by {\tt SetVBuf()}\key{SetVBuf()}.

\subsection{Read a Character from a File}

The {\tt FGetC()}\mkey{FGetC()} function reads a single character from
a file through the internal buffer of the \emph{file handle}.

\begin{verbatim}
char = FGetC(fh)
D0           D1

LONG FGetC(BPTR)
\end{verbatim}

This function attempts to read a single character from the \emph{file
  handle} {\tt fh} using the buffer of the handle. If characters are
present in the buffer, the request is satisfied from the buffer first,
then the function attempts to refill the buffer from the file and
tries again.
\smallskip{}

The function returns the character read, or {\tt ENDSTREAMCH} on an
end-of-file condition or an error. The latter constant is defined in
{\tt dos/stdio.h} and equals to $-1$.
\smallskip{}

To distinguish between the error and the
end-of-file case, the caller should first reset the error condition
with {\tt SetIoErr(0)}\key{SetIoErr()}, and then check {\tt IoErr()}
when the function returns with {\tt ENDSTREAMCH}.

\subsection{Read a Line from a File}

The {\tt FGets()}\mkey{FGets()} function reads a newline-terminated
string from a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
buffer = FGets(fh, buf, len)
D0             D1  D2   D3

STRPTR FGets(BPTR, STRPTR, ULONG)
\end{verbatim}

This function reads a line from the \emph{file handle} into the buffer
pointed to by {\tt buf}, capable of holding {\tt len} characters.
\smallskip{}

Reading terminates either if {\tt len}-1 characters have been read, filling
up the buffer completely; or a line-feed character is found, which is
copied into the buffer; or if an end-of-file condition or an error
condition is encountered. In either event, the string is {\tt NUL}
terminated.
\smallskip{}

The function returns {\tt NULL} in case not even a single character
could be read. Otherwise, the function returns the buffer passed in.
\smallskip{}

To distinguish between the error and end-of-file condition, the caller
should first use {\tt SetIoErr(0)}\key{SetIoErr()}, and then test
{\tt IoErr()} in case the function returns {\tt NULL}.

\subsection{Revert a Single Byte Read}

The {\tt UnGetC()} function reverts a single byte read from a
stream and makes this byte available for reading again.

\begin{verbatim}
value = UnGetC(fh, ch)
D0             D1  D2

LONG UnGetC(BPTR, LONG)
\end{verbatim}

The character {\tt ch} is pushed back into the \emph{file handle} {\tt fh}
such that the next attempt to read a character from {\tt fh}
returns {\tt ch}. If {\tt ch} is $-1$, the last character read will be
pushed back. If the last read operation indicated an error or end-of-file condition,
{\tt UnGetC(fh,-1)} pushes an end-of-file condition back.
\smallskip{}

This function returns non-zero on success or $0$ if the character
could not be pushed back. At most a single character can be pushed
back after each read operation, an attempt to push back more
characters can fail.

\section{File Handle Documentation}

So far, the \emph{file handle} has been used as an opaque value bare
any meaning. However, the {\tt BPTR}, once converted to a regular
pointer, is a pointer to {\tt FileHandle}\mkey{FileHandle} structure:

\begin{verbatim}
BPTR file = Open("S:Startup-Sequence,MODE_OLDFILE);
struct FileHandle *fh = BADDR(file);
\end{verbatim}

In the following sections, this structure and its functions are documented.

\subsection{The struct FileHandle} \label{sec:filehandle}

When opening a file via {\tt Open()}, the \emph{file handle} is allocated by
the \emph{dos.library} by going through {\tt AllocDosObject()}\key{AllocDosObject()},
and then forwarded to the file system or handler for second-level initialization. It is
documented in {\tt dos/dosextens.h} as replicated here:
\mkey{FileHandle}
\begin{verbatim}
struct FileHandle {
   struct Message *fh_Link;	 
   struct MsgPort *fh_Port;
   struct MsgPort *fh_Type;
   BPTR fh_Buf;       
   LONG fh_Pos;
   LONG fh_End;
   LONG fh_Funcs;
#define fh_Func1 fh_Funcs
   LONG fh_Func2;
   LONG fh_Func3;
   LONG fh_Args;
#define fh_Arg1 fh_Args
   LONG fh_Arg2;
};
\end{verbatim}
{\tt fh\_Link} is actually not a pointer, but an AmigaDOS internal
value that shall not be interpreted or touched, and of which one
cannot make productive use.
\smallskip{}

{\tt fh\_Port} is similarly not a pointer, but a {\tt LONG}. If it is
non-zero, the file is interactive, otherwise it is a file system.
{\tt IsInteractive()}\key{IsInteractive()} makes use of this
member. The file system or handler shall initialize this value when
opening a file and shall initialize it according to the nature of the
handler.
\smallskip{}

{\tt fh\_Type} points to the {\tt MsgPort} of the handler or file
system that implements all input and output
operations. Section~\ref{sec:handler} provides additional information
on how handlers and file systems work. If this pointer is {\tt NULL},
no handler is associated to the file handle. This is also the value
AmigaDOS will deposit here when opening a file to the {\tt NIL:}
(pseudo-)device. Attempting to {\tt Read()}\key{Read()} from this
handle results in an end-of-file situation, and calling {\tt Write()}
on such a handle does nothing, ignoring any data written.
\smallskip{}

{\tt fh\_Buf} is a {\tt BPTR} to the file handle internal buffer all
buffered I/O function documented in this section use.
\smallskip{}

{\tt fh\_Pos} is the next read or write position within this buffer.
\smallskip{}

{\tt fh\_End} is the size of the buffer in bytes.
\smallskip{}

{\tt fh\_Func1} is a function pointer that is called whenever the
buffer is to be filled through the handler. Users shall not call this
function itself, and the function prototype is intentionally not
documented.
\smallskip{}

{\tt fh\_Func2} is a second function pointer that is called whenever
the buffer is full and is to be written by the handler. Users shall
not call this function itself, and the function prototype is
intentionally undocumented.
\smallskip{}

{\tt fh\_Func3} is a final function pointer that is called whenever
the file handle is closed. This function then potentially writes the
buffer content out when dirty, releases the buffer if it is
system-allocated, and finally forwards the close request to the
handler.
\smallskip{}

{\tt fh\_Arg1} is a file-system internal value the handler or file
system uses to identify the file. The interpretation of this value is
to the file system or handler, and the \emph{dos.library} does not
attempt to interpret it. The handler deposits the file identification
here when opening a file, and the \emph{dos.library} forwards it to the
handler on {\tt Read()} and {\tt Write()}. See
section~\ref{sec:handler} for details.
\smallskip{}

{\tt fh\_Arg2} is currently unused.

\subsection{String Streams} \label{sec:stringstreams}
It is sometimes useful to provide programs with (temporary) input not
coming from a file system or handler directly, even though the program
uses a file interface to access it. One solution to this problem is to
deposit the input data on the {\tt RAM} disk, then opening this file
and providing it as input to such a program. The drawback of this
approach is that additional tests are necessary to ensure that the
file name is unique, and to avoid that other than the intended program
accesses it.
\smallskip{}

AmigaDOS uses the technique documented here itself, for example to
provide the command to be executed by the {\tt Run}\key{Run}
command. There, the string stream contains the command to be run in
background, which is then provided as input file to the shell. The
{\tt System()}\key{System()} function of the \emph{dos.library} makes
use of the same trick to feed the command to be executed as input
file. Thus, even though the shell can only execute commands from a
file, AmigaDOS can generate \emph{file handles} that do not correspond
to a handler, but to a string in memory containing the commands.
\smallskip{}

The shell itself is using the same technique to pass arguments to the
commands it executes; it deposits the command arguments in the file
handle buffer of the input stream where {\tt ReadArgs()} collects them.
\medskip{}

The idea is to allocate a {\tt struct FileHandle} and initialize its
buffer to contain the string within the file. For this {\tt fh->Buf}
needs to point to the buffer containing the string, and {\tt fh->End}
needs to be its size. The function pointers in the \emph{file handle}
remain 0 such as to avoid that the \emph{dos.library} reads, writes or
flushes the buffer. The {\tt FileHandle} shall be allocated by {\tt
  AllocVec()} as the \emph{dos.library} releases the handle through
{\tt FreeVec()}.

The following program demonstrates this technique:
\begin{verbatim}
#include <exec/memory.h>
#include <dos/dos.h>
#include <dos/stdio.h>
#include <string.h>
#include <proto/dos.h>
#include <proto/exec.h>

int main(int argc,char **argv)
{
  const char *test = "Hello World!\n";
  const int len = strlen(test)+1;
  struct FileHandle *fh;
  BPTR file;

  fh   = AllocVec(sizeof(struct FileHandle) + len,MEMF_PUBLIC|MEMF_CLEAR);
  if (fh) {
    UBYTE *c = (UBYTE *)(fh + 1);
    file     = MKBADDR(fh);
    memcpy(c,test,len);
    fh->fh_Buf = MKBADDR(c);
    fh->fh_End = len;
    {
      BPTR out = Output();
      LONG ch;
      while((ch = FGetC(file)) >= 0) {
        FPutC(out,ch);
      }
    }
    Close(file);
  }
  return 0;
}
\end{verbatim}
Here the buffer is allocated along with the file handle, and thus
released along with it. Setting {\tt MEMF\_PUBLIC} is of utter
importance as it clears all function pointers, and in particular the
{\tt fh\_Link} field to zero; the latter is an indication to the
\emph{dos.library} that this structure was not allocated through
itself.

\subsection{An FSkip() Implementation} \label{sec:fskip}

Unlike most unbuffered functions, {\tt Seek()}\key{Seek} can be safely
mixed with buffered input and output functions. However, this function
is not very efficient, and seeking should be avoided if buffer
manipulation is sufficient. Buffer manipulation has the advantage that
small amounts of bytes can be skipped easily without going through the
file system; skipping over larger amounts of bytes can be performed by
a single function without requiring to read bytes.
\smallskip{}

The following function implements an {\tt FSkip()}\mkey{FSkip()}
function that selects the most viable option and is more efficient
that {\tt Seek()} for buffered reads.
\begin{verbatim}
LONG FSkip(BPTR file,LONG skip)
{
  LONG res;
  struct FileHandle *fh = BADDR(file);
  if (fh->fh_Pos >= 0 && fh->fh_End > 0 && fh->fh_Func3) {
    LONG newpos = fh->fh_Pos + skip;
    if (newpos >= 0 && newpos < fh->fh_End) {
      fh->fh_Pos = newpos;
      return DOSTRUE;
    }
  }
  skip += fh->fh_Pos - fh->fh_End;
  fh->fh_Pos = -1;
  fh->fh_End = -1;
  if (Seek(fh,skip,OFFSET_CURRENT) != -1)
   return DOSTRUE;
  return DOSFALSE;
}
\end{verbatim}

The first if-condition checks whether the buffer is actually
present. Then, the new buffer position is computed. If it is within
the buffer, the new buffer position is installed as the work is done.
\smallskip{}

Otherwise, the skip distance is adjusted by the buffer
position. Initializing the buffer size and position to $-1$ ensures
that the following {\tt Seek()} does not attempt to call {\tt Flush()}
internally.
\smallskip{}

There is one particular catch, namely that the {\tt file}
needs to be initialized for reading immediately after opening the
file, or the buffer will not be in the right state for the trick:
\begin{verbatim}
BPTR file = Open(filename,MODE_OLDFILE);
UnGetC(file,-1); /* initialize buffer */
\end{verbatim}
This is only necessary if the first access to the file is an
{\tt FSkip()}.

\subsection{An FGet() Implementation}

While the {\tt FRead()}\key{FRead()} function already provides a
buffered read function, it is not very efficient prior release 47 of
AmigaDOS. The following simple function provides in such cases a
faster implementation that even allows inlining:

\begin{verbatim}
LONG FGet(BPTR f,void *buf,LONG size)
{
  struct FileHandle *cis = BADDR(f);

  if (cis->fh_Pos) {
    LONG end = cis->fh_Pos + size;
    if (end < cis->fh_End) {
      memcpy(buf,(UBYTE *)BADDR(cis->fh_Buf) + cis->fh_Pos,(size_t)(size));
      cis->fh_Pos = end;
      return size;
    }
  }

  return FRead(f,buf,1,size);
}
\end{verbatim}

It reads {\tt size} bytes from the file {\tt fh} into the buffer {\tt
  buf}, and returns the number of bytes read.
\smallskip{}

As seen from this implementation, the function attempts to satisfy the
read if a partial buffer is present. If not, the above implementation
runs into the operating system function. As for the {\tt FSkip()}
implementation presented in section~\ref{sec:fskip}, the file handle
requires some preparation by a dummy {\tt UnGetC()}, see there.

\section{Formatted Output}

The functions in this section print strings formatted to a file. Both
files use the internal buffer of the \emph{file handle}.

\subsection{Print Formatted String using C-Syntax to a File}

The {\tt VFPrintf()}\mkey{VFPrintf()} function prints multiple
datatypes using a format string that closely reessembles the syntax of
the C syntax. {\tt FPrintf()}\mkey{FPrintf()} is based on the same
entry point of the \emph{dos.library}, though the prototype for the C
language is different and thus arguments are expected directly as function
arguments instead of requiring them to be collected in an array upfront.

\begin{verbatim}
count = VFPrintf(fh, fmt, argv)
D0               D1  D2    D3

LONG VFPrintf(BPTR, STRPTR, LONG *)

count = FPrintf(fh, fmt, ...)

LONG FPrintf(BPTR, STRPTR, ...)
\end{verbatim}

This function uses the {\tt fmt} string to format an array of
arguments pointed to by {\tt argv} and outputs the result to the file
{\tt fh}. The syntax of the format string is identical to that of the
exec function {\tt RawDoFmt()}, and shares its problems. In
particular, format strings indicating integer arguments such as
{\tt \%d} and {\tt \%u} assume 16bit integers, independent of the integer
model of the compiler. On compilers working with a 32bit integer
models, the format modifier {\tt l} should be used, e.g. {\tt \%ld}
for signed and {\tt \%lu} for unsigned integers.
\smallskip{}

As {\tt RawDoFmt()}\key{RawDoFmt()} is also patched by the
\emph{locale.library}, additional syntax elements from the
{\tt FormatString()} function of this library become available for
{\tt VFPrintf()} and {\tt FPrintf()}.
\smallskip{}

The result {\tt count} delivers the number of characters written to
the file, or $-1$ for an error. In the latter case,
{\tt IoErr}\key{IoErr()} provides an error code.

\subsection{BCPL Style Formatted Print to a File}

The {\tt VFWritef()}\mkey{VFwrite()} function formats several
arguments according to a format string similar to {\tt
  VFPrintf()}\key{VFprintf()}, but uses the formatting syntax of the
BCPL language. The main purpose of this function is to offer formatted
output for legacy BCPL programs where this function appears as an
entry of the BCPL \emph{Global Vector}\key{Global Vector}. New code
should not use this function but rather depend on {\tt VFPrintf()}
which also gets enhanced by the \emph{locale.library}.
\smallskip{}

The {\tt FWritef()}\mkey{FWritef()} uses the same entry point of the
\emph{dos.library}, though the compiler prototype imposes a different
calling syntax where the objects to be formatted are directly
delivered as function arguments rather requiring the caller to collect
them in an array upfront.

\begin{verbatim}
count = VFWritef(fh, fmt, argv)
D0               D1  D2    D3

LONG VFWritef(BPTR, STRPTR, LONG *)

count = FWritef(fh, fmt, ...)

LONG FWritef(BPTR, STRPTR, ...)
\end{verbatim}

This function formats the arguments from the array pointed to by
{\tt argv} according to the format string in {\tt fmt} and writes the
output to the file {\tt fh}. The format string follows the syntax of
the BCPL language. The following format identifiers are supported:

\begin{itemize}
\item[{\tt \%S }] Write a {\tt NUL} terminated string from the array to the output.
\item[{\tt \%Tx}] Writes a {\tt NUL} terminated string left justified
  in a field whose width is given by the character {\tt x}. The length
  indicator is always a single character; a digit from {\tt 0} to
  {\tt 9} indicates the field widths from $0$ to $9$ directly. Characters
  {\tt A} to {\tt Z} indicate field widths from $10$ onwards.
\item[{\tt \%C }] Writes a single character whose ISO-Latin-1 code is given
  as a 32-bit integer on the {\tt argv} array.
\item[{\tt \%Ox}] Writes an integer in octal to the output where
  {\tt x} indicates the maximal field width. The field width is a single
  character that is encoded similarly to the {\tt \%T} format string.
\item[{\tt \%Xx}] Writes an integer in hexadecimal to the output in a field
  that is at most {\tt x} characters long. {\tt x} is a single character and
  encodes the width similar to that {\tt \%T} format string.
\item[{\tt \%Ix}] Writes a (signed) integer in decimal to the output
  in field that is at most {\tt x} characters long. The field length
  is again indicated by a single character.
\item[{\tt \%N }] Writes a (signed) integer in decimal to the output
  without any length limitation.
\item[{\tt \%Ux}] Writes an unsigned integer in decimal to the output,
  limiting the field length to at most {\tt x} characters, where
  {\tt x} is encoded in a single character.
\item[{\tt \%\$ }] Ignores the next argument, i.e. skips over it.
\end{itemize}

This function is \emph{not} patched by the \emph{locale.library} and
therefore is not localized or enhanced.
\smallskip{}

While the same function can also be found in the BPCL \emph{Global
  Vector}\key{Global Vector}, it there takes BSTRs instead of regular
C strings for the format string and arguments of the {\tt \%S} and
{\tt \%T} formats.

\subsection{Setting the Console Buffer Mode} \label{sec:setmode}

The {\tt SetMode()}\mkey{SetMode()} function sets the behaviour of a
handler. It is typically used in conjunction with the graphical or serial
console, i.e. the CON-Handler and the AUX-Handler, and there sets the input
buffer mode of the console. Depending on this mode, the console either waits
for an entire line to be completed to satisfy an input, or provides each
individual key as input to programs, or provides a line buffer with the
exception of some special control keys that are transmitted immediately.

\begin{verbatim}
success = SetMode(fh, mode)
D0                D1  D2

BOOL SetMode(BPTR, LONG)
\end{verbatim}

This function sets the mode of the handler addressed by the
\emph{FileHandle} {\tt fh} to the {\tt mode} provided as second
argument. The meaning of the modes is specific to the handler; however, this
function is typically used in conjunction with both consoles provided by the
system, the graphical console of the {\tt CON:} and {\tt RAW:} device, and
the serial console corresponding to the {\tt AUX:} device. All three devices
are, actually, implemented by the CON-Handler, while the AUX-Handler is just a
simple wedge to the first for historical reasons.
\smallskip{}

For the console(s), the interpretation of the {\tt mode} argument is as
follows:

\begin{rkrmtable}{Console Modes} \label{table:conmodes}
{\bf Buffer Mode} & {\bf Description}\\ \hline \hline
\tt 0 & Cooked mode \\ \hline
\tt 1 & Raw mode \\ \hline
\tt 2 & Medium mode \\ \hline
All other values & Reserved for future use \\ \hline
\end{rkrmtable}

In the \emph{cooked mode}, the console buffers entire lines, provides
line-editing features, but only makes the input data available when the user
terminates the input with the {\tt RETURN} key. The {\tt CON:} and {\tt
  AUX:} devices
operate by default in this mode, but can be switched to any other buffer
mode with this function.
\smallskip{}

In the \emph{raw mode}, every single keystroke is made available
immediately, including control sequences corresponding to all cursor and
function keys. That implies, however, that line editing is not available and
pressed keys are not echoed on the console, but rather transmitted directly.
If echoing is desired, it needs to be performed manually by the application.
This mode corresponds to the {\tt RAW:} device which is nothing but a
console operating in this mode by default.
\smallskip{}

In the \emph{medium mode}, the console also buffers lines, but some
keystrokes are directly transmitted without requiring the user to press the
{\tt RETURN} key. In specific, key-combinations of the up- and down cursor
keys and the {\tt TAB} key are reported immediately to the caller through
control sequences. The Amiga Shell uses this mode to offer a history and
provides through it {\tt TAB} expansion of commands and command line
arguments. No device name corresponds to this mode; instead, the Shell
switches a regular {\tt CON:} window to this mode in order to offer
additional services. Section~\ref{sec:console} provides details.
\smallskip{}

Both the CON-Handler and the AUX-Handler implement this function, supporting
all three modes. However, there is --- unless explicitly mounted by the user
--- no device name that corresponds to the \emph{medium mode} and no device
name that corresponds to an {\tt AUX:} console in the \emph{raw mode}.

\section{Record Locking} \label{sec:recordlocking}

While locks control access to a \emph{file system} object in total,
record locks provide access control on portions of a file. Unlike
locks, however, the \emph{file system} does not block read or write
access to the locked region. Instead, a record lock on a portion of a
file only prevents another record lock on a region that overlaps with
the locked region. Record locks therefore require the locking
processes to follow the same locking protocol.
\smallskip{}

Record locks are a relatively modern protocol not all file systems
implement. The Ram-Handler and the Fast File System support it.

\subsection{Locking a Portion of a File} \label{sec:lockrecord}

The {\tt LockRecord}\mkey{LockRecord} function locks a single region
of a file, potentially waiting for a timeout for the region to become
available.

\begin{verbatim}
success = LockRecord(fh,offset,length,mode,timeout)
D0                   D1   D2     D3    D4    D5

BOOL LockRecord(BPTR,ULONG,ULONG,ULONG,ULONG)
\end{verbatim}

This function attempts to lock the region of the file identified by
{\tt fh} starting from the byte offset {\tt offset} and the byte size
{\tt length}. The {\tt mode} shall be taken from the following
constants, defined in {\tt dos/record.h}:

\begin{rkrmtable}{Record Locking Modes} \label{table:reclockmode}
{\bf Record Locking Mode} & {\bf Description}\\ \hline \hline
{\tt REC\_EXCLUSIVE} & Exclusive access to a region, honoring the timeout\\ \hline
{\tt REC\_EXCLUSIVE\_IMMED} & Exclusive access to a region, ignoring the timeout\\ \hline
{\tt REC\_SHARED} & Shared access to a region, honoring the timeout\\ \hline
{\tt REC\_SHARED\_IMMED} & Shared access to a region, ignoring the timeout\\ \hline
\end{rkrmtable}

While the same byte within a file can be included in multiple regions
locked through a shared record lock, only a single exclusive lock can
be held on each byte of a file. Or put differently, shared regions can
overlap with each other without failure, exclusivively locked regions
cannot overlap with shared locked regions or with each other.
\smallskip{}

For the {\tt REC\_EXCLUSIVE} and {\tt REC\_SHARED} modes, the {\tt
  timeout} value provides a time limit in ticks,
i.e. $1/50^{\mbox{\tiny th}}$ of a second, after which an attempt to
obtain a lock times out. This time limit may also be $0$ in which case
an attempt to lock a region fails immediately.
\smallskip{}

The {\tt REC\_EXCLUSIVE\_IMMED} and {\tt REC\_SHARED\_IMMED} modes
ignore the timeout, i.e. they act as if the timeout is~$0$ and fail as
soon as they can determine that the requested record cannot be locked.
\smallskip{}

This function returns~$0$ in case of failure and then returns a
non-zero error code with {\tt IoErr()}. In case the record lock cannot
be obtained because the region overlaps with another locked region,
the error will be {\tt ERROR\_LOCK\_COLLISION}. If the region can be
locked, the call returns a non-zero result code and sets {\tt IoErr()}\key{IoErr()}
to~0.

\subsection{Locking Multiple Portions of a File} \label{sec:lockrecords}

The {\tt LockRecords()}\mkey{LockRecords()} function locks multiple
records at once, potentially within multiple files.

\begin{verbatim}
success = LockRecords(record_array,timeout)
D0                       D1           D2

BOOL LockRecords(struct RecordLock *,ULONG)
\end{verbatim}

This function attempts to lock multiple records at once that are
included in the the {\tt RecordLock} structure. This structure is
defined in {\tt dos/record.h} and looks as follows: \mkey{RecordLock}
\begin{verbatim}
struct RecordLock {
        BPTR    rec_FH;         /* filehandle */
        ULONG   rec_Offset;     /* offset in file */
        ULONG   rec_Length;     /* length of file to be locked */
        ULONG   rec_Mode;       /* Type of lock */
};
\end{verbatim}

The {\tt record\_array} is a pointer to an array of the above
structure that is terminated by a {\tt RecordLock} structure with {\tt
  rec\_FH} equal to {\tt NULL}. The elements of this structure
correspond to the arguments of the {\tt LockRecord()}\key{LockRecord()} function:
\smallskip{}

{\tt rec\_FH} is the file handle to the file within which a record is
to be locked. It shall be {\tt NULL} for the last element in the array.
\smallskip{}

{\tt rec\_Offset} and {\tt rec\_Length} specify the region in the file to be locked.
\smallskip{}

{\tt rec\_Mode} specifies the type of the lock that is to be
obtained. It shall be one of the modes listed in
table~\ref{table:reclockmode}; the modes are all defined in {\tt dos/record.h}.
\smallskip{}

The {\tt timeout} specifies how long each of the attempts to obtain a
lock is supposed to wait for a record to become available if a
non-immediate record lock is requested. The {\tt timeout} is applied
to each of the records in the {\tt RecordLock} array sequentially
until either all records could be locked, or until locking one of the
records fail. In such a case, the call unlocks all locks obtained so
far, and then returns with failure.
\smallskip{}

On failure, i.e. if one of the records cannot be locked, the function
returns~0 and sets {\tt IoErr()} to an error code. On success, the
function returns a non-zero result and sets {\tt IoErr()}\key{IoErr()} to~0.
\smallskip{}

Unlike what the function prototype suggests, this function is
\emph{not atomic}. Instead, it attempts to lock the records
sequentially one after another, applying the same timeout for each
call. Thus, it can happen that another task attempts for a lock of a
conflicting region while the first caller is executing this
function. It is therefore recommended to establish an order in which
records within a file are locked, e.g. from smallest to largest start
offset. Note that this also implies that the maximal time this
function may take is given by the number of elements in the
{\tt record\_array} times {\tt timeout}.

\subsection{Unlocking a Portion of a File}

The {\tt UnLockRecord()}\mkey{UnLockRecord()} function unlocks a
region of a file, releasing it for further locks. The provided region
shall be identical to one of the regions locked before, i.e. it is not
possible to partially unlock a region and leave the remaining bytes of
the region locked.

\begin{verbatim}
success = UnLockRecord(fh,offset,length)
D0		       D1   D2     D3

BOOL UnLockRecord(BPTR,ULONG,ULONG)
\end{verbatim}

This function unlocks a region of a file locked before by
{\tt LockRegion()}\key{LockRegion()} or {\tt LockRegions()}\key{LockRegions()}.
The region starts {\tt offset} bytes within the file identified by {\tt fh} and
is {\tt length} bytes large.
\smallskip{}

This function returns~0 on failure and sets an error code that can be
obtained by {\tt IoErr()}\key{IoErr()}. A possible error code is {\tt
  ERROR\_RECORD\_NOT\_LOCKED} if an attempt is made to unlock a record
that is actually not locked, or to partially unlock a record. On
success, the function returns a non-zero result code and sets {\tt
  IoErr()} to~0.

\subsection{Unlocking Multiple Records of a File}

The {\tt UnLockRecords()} function unlocks multiple records provided
in an array of {\tt RecordLock} structures at once, sequentially
releasing one record after another.

\begin{verbatim}
success = UnLockRecords(record_array)
D0		             D1

BOOL UnLockRecords(struct RecordLock *)
\end{verbatim}

This function releases multiple records provided in an array of
{\tt RecordLock} structures. The last element of the structure is
indicated by its {\tt rec\_FH} element set to {\tt NULL}. This
structure is defined in section~\ref{sec:lockrecords}.
\smallskip{}

The function calls {\tt UnLockRecord()} in a loop, and is therefore
\emph{not atomic}. In case unlocking any of these records fails, the
function returns~0 but attempts to unlock also any remaining records
in the array. On success, it returns a non-zero result code and sets
{\tt IoErr()} to~0. Unfortunately, the function does not set {\tt
  IoErr()} consistently in case of failure as the error code is not
saved on a failed unlock.
  
\chapter{Locks} \label{sec:locks}

\emph{Locks}\mkey{Lock} are access rights to objects, such as files or
directories, on a file system. Once an object has been locked, it can
no longer be deleted, or in case of files, it can no longer altered
either. Depending on the file system, locks may also prevent other
forms of changes of the object.
\medskip{}

Locks come in two types: \emph{Exclusive}\mkey{Lock (Exclusive)} and
\emph{shared locks}. Only a single exclusive lock can exist on a file
system object at a time, and no other locks on an exclusively locked
object can exist. An attempt to lock an exclusively locked object
results in failure, and attempting to exclusively lock an object that
is already shared locked will also fail.
\smallskip{}

Multiple \emph{shared locks}\mkey{Lock (Shared)} can be kept on the
same object at the same time, though once a shared lock has been
obtained, any attempt to lock the same object exclusively fails.
\smallskip{}

One particular use case of \emph{locks} is to serve as an identifier
of a particular directory or file on a file system. Since paths are
limited to 255 characters, see~\ref{sec:paths}, locks are the
preferred method of indicating a position within a file system. Even
though paths are length limited, there is no restriction on the depth
within the directory structure of a file system. The {\tt ZERO} lock
identifies the boot volume, also known as {\tt SYS:}, see also
section~\ref{sec:assignlist}.
\smallskip{}

\emph{Locks} are also the building stone of files; in fact, every file
is internally represented by a lock on the corresponding object, even
if the file system does not expose this lock to the caller.
\smallskip{}

As long as at least a single lock is held of an object on a particular
volume, the file system will keep the volume within the
\emph{device list} of the \emph{dos.library}, see section~\ref{sec:devicelist}.
This has, for example, the consequence that the workbench will
continue to show an icon representing the volume in its window.

\section{Obtaining and Releasing Locks}

\emph{Locks} can be obtained either explicitly from a path, or can be
derived from another lock or file. As locks block altering accesses to
an object of a file system, locks need to be released as early as
possible to allow other accesses to the locked object.

\subsection{Obtaining a Lock from a Path} \label{sec:lock}

The {\tt Lock()}\key{Lock()} function obtains a lock on an object
given a path to the object. The path can be either absolute, or
relative (see section~\ref{sec:paths}) to the current directory of the
calling process.

\begin{verbatim}
lock  = Lock( name, accessMode )
D0            D1        D2

BPTR Lock(STRPTR, LONG)
\end{verbatim}

This function locks the object identified by {\tt name}, which is the
path to the object. The type of the lock is identified by {\tt
  accessMode}. This mode shall be one of the two following modes,
defined in {\tt dos/dos.h}:

\begin{rkrmtable}{Lock Access Modes} \label{table:lockmodes}
{\bf Access Mode} & {\bf Description}\\ \hline \hline
{\tt SHARED\_LOCK} & Lock allowing shared access from multiple sources\\ \hline
{\tt ACCESS\_READ} & Synonym of the above, identical to {\tt SHARED\_LOCK} \\ \hline
{\tt EXCLUSIVE\_LOCK} & Exclusive lock, only allowing a single lock on the object \\ \hline
{\tt ACCESS\_WRITE} & Synonym of the above, identical to {\tt EXCLUSIVE\_LOCK} \\ \hline
\end{rkrmtable}

The access mode {\tt SHARED\_LOCK}\mkey{SHARED\_LOCK} or {\tt
  ACCESS\_READ}\mkey{ACCESS\_READ} allows multiple shared locks on the
same object. This type of lock should be preferred. The access mode
{\tt EXCLUSIVE\_LOCK}\mkey{EXCLUSIVE\_LOCK} or
{\tt ACCESS\_WRITE}\mkey{ACCESS\_READ} only allows a single, exclusive
lock on the same object.
\smallskip{}

The return code {\tt lock} identifies the lock. It is non-{\tt ZERO}
(see~\ref{sec:bptrs}) on success, or {\tt ZERO} on failure. In either
case, {\tt IoErr()}\key{IoErr()} is set to $0$ indicating success, or
an error code on failure.
\smallskip{}

\punchline{No Wildcards Here!}{Note that this function does not attempt to
  resolve wild cards, similar to {\tt Open()}. All characters in the
  path are literals.}

\subsection{Duplicating a Lock}

The {\tt DupLock()}\mkey{DupLock()} function replicates a given
\emph{lock}, returning a copy of the \emph{lock} given as
argument. This requires that the original \emph{lock} is a
\emph{shared lock}, and it returns a \emph{shared lock} if successful.

\begin{verbatim}
lock = DupLock( lock )
D0              D1

BPTR DupLock(BPTR)
\end{verbatim}

This function copies the (shared) lock passed in as {\tt lock} and
returns a copy of it in {\tt lock}. In case of error, it returns {\tt
  ZERO}, and then {\tt IoErr()}\key{IoErr()} returns an error code
identifying the error. On success, {\tt IoErr()} is reset. It is not
possible to copy an \emph{exclusive lock}.

\subsection{Obtaining the Parent of an Object}

The {\tt ParentDir()}\mkey{ParentDir()} function obtains a
\emph{shared lock} on the directory containing the locked object
passed in. For directories, this is the parent directory, for files,
this is the directory containing the file.

\begin{verbatim}
newlock = ParentDir( lock )
D0                   D1

BPTR ParentDir(BPTR)
\end{verbatim}

The {\tt lock} argument identifies the object whose parent is to be
found; the function returns a \emph{lock} on the directory containing
the object. If such parent does not exist, or an error occurs, the
function returns {\tt ZERO}. The former case applies to the topmost
directory of a file system, or the {\tt ZERO} lock itself.
\smallskip{}

To distinguish the two cases, the caller should check the {\tt
  IoErr()}\key{IoErr()} function; if this function returns $0$, then
no error occurred and the passed in object is topmost and no parent
exists. If it returns a non-zero error code, then the file system
failed to identify the parent directory.

\subsection{Creating a Directory}

The {\tt CreateDir()} object creates a new empty directory whose name
is given by the last component of the path passed in. It does not
create any intermediate directories between the first component of the
path and its last component, such directories need potentially be
created manually by multiple calls to this function.

\begin{verbatim}
lock = CreateDir( name )
 D0                D1

BPTR CreateDir(STRPTR)
\end{verbatim}

The {\tt name} argument is the path to the new directory to be
created; that is, the directory given by the last component of the
path (see section~\ref{sec:paths}) will be created. If successful,
the function returns an \emph{exclusive lock} in {\tt lock}, otherwise
it returns {\tt ZERO}.
\smallskip{}

In either case, {\tt IoErr()}\key{IoErr()} is set to either an error
code, or to $0$ in case the function succeeds.
\smallskip{}

Note that not all file systems support directories, i.e. flat file
systems (see section~\ref{sec:flathierarchical}) do not.

\subsection{Releasing a Lock}

Once you are done with a \emph{lock} and no part of your program is
using it anymore, you should release it to allow other processes or
functions to access or modify the locked object. Note that setting the
{\tt CurrentDir()}\key{CurrentDir()} to a particular lock implies
usage of the lock, i.e. the lock installed as {\tt CurrentDir()} shall
not be unlocked.

\begin{verbatim}
UnLock( lock )
         D1

void UnLock(BPTR)
\end{verbatim}

This function releases the \emph{lock} passed in as {\tt lock}
argument. Passing {\tt ZERO} as a lock is fine and performs no
activity.

\subsection{Changing the Type of a Lock}

Once a \emph{lock} has been granted, it is possible to change the
nature of the lock, either from
{\tt EXCLUSIVE\_LOCK}\key{EXCLUSIVE\_LOCK} to
{\tt SHARED\_LOCK}\key{SHARED\_LOCK}, or --- if this is the only \emph{lock} on
the object --- vice versa.

\begin{verbatim}
success = ChangeMode(type, object, newmode)
D0                    D1     D2      D3

BOOL ChangeMode(ULONG, BPTR, ULONG)
\end{verbatim}

This function changes the access mode of {\tt object} whose type is
identified by {\tt type} to the access mode {\tt newmode}. The
relation between {\tt type} and the nature of the object shall be as
in table~\ref{table:changemode}, where the types are defined
in {\tt dos/dos.h}:

\begin{rkrmtable}{Object Types for ChangeMode()} \label{table:changemode}
{\bf {\tt \bf type}} & {\bf {\tt \bf object} Type}\\ \hline \hline
{\tt CHANGE\_LOCK} & {\tt object} shall be a \emph{lock}\\ \hline
{\tt CHANGE\_FH} & {\tt object} shall be a \emph{file handle}\\ \hline
\end{rkrmtable}

The argument {\tt newmode} shall be one of the modes indicated in
Table~\ref{table:lockmodes}, i.e. {\tt SHARED\_LOCK}\key{SHARED\_LOCK}
to make either the file or the lock accessible for shared access, and
{\tt EXCLUSIVE\_LOCK}\key{SHARED\_LOCK} for exclusive access.

On success, the function returns a non-zero result code, and
{\tt IoErr()} is set to $0$. Otherwise, the function returns $0$ and sets
{\tt IoErr()}\key{IoErr()} to an appropriate error code.
\smallskip{}

Unfortunately, this function may not work reliable for \emph{file
  handles} under all versions of AmigaDOS. In particular, the
\emph{RAM-Handler} does not interpret {\tt newmode} correctly for {\tt
  CHANGE\_FH}.

\subsection{Comparing two Locks} \label{sec:samelock}

The {\tt SameLock()}\mkey{SameLock()} function compares two locks and
returns information whether they are identical, or at least correspond
to objects on the same volume.

\begin{verbatim}
value = SameLock(lock1, lock2)
 D0                D1     D2

LONG SameLock(BPTR, BPTR)
\end{verbatim}

This function compares {\tt lock1} with {\tt lock2}. The return code,
all of them defined in {\tt dos/dos.h}, can be one of the following:

\begin{rkrmtable}{Lock Comparison Return Code} \label{table:lockcompare}
{\bf Return Code} & {\bf Description}\\ \hline \hline
{\tt SAME\_LOCK} & Both locks are on the same object\\ \hline
{\tt SAME\_VOLUME} & Locks are on different objects, but on the same volume\\ \hline
{\tt LOCK\_DIFFERENT} & Locks are on different volumes\\ \hline
\end{rkrmtable}

This function does not set {\tt IoErr()}\key{IoErr()} consistently,
and callers cannot depend on its value. Furthermore, the function does
not compare a {\tt ZERO} lock with lock on the boot volume, e.g {\tt
  SYS:} as identical. It is recommended not to pass in the {\tt ZERO}
lock for either {\tt lock1} or {\tt lock2}.

\subsection{Compare to Locks for the Device}

The {\tt SameDevice()}\mkey{SameDevice()} function attempts to check whether
two locks refer to two file systems that reside on the same physical device,
even if on potentially different partitions.

\begin{verbatim}
same = SameDevice(lock1, lock2)
D0		   D1     D2

BOOL SameDevice( BPTR, BPTR )
\end{verbatim}

The {\tt SameDevice()} function takes two \emph{Lock}s {\tt lock1} and {\tt
  lock2} and checks whether they were created by file systems that operate
on the same physical device, even if the two \emph{Lock}s refer to different
file systems or different partitions. Only the \emph{exec device} and the
corresponding unit is compared, that is, this function is not able to
determine whether whether the locks refer to file systems on the same or
different physical volumes.
\smallskip{}

This function returns a non-zero result if the resonsible file systems
operate on the same \emph{exec device}, and it returns~$0$ otherwise. If
the function is not able to identify the file systems, or cannot identify the
lower level exec {\tt device} on which the file systems operate, the
function also returns~$0$.
\smallskip{}

A possible use case of this function is to determine whether the involved
\emph{file systems} can operate in parallel without imposing speed penalties
due to conflicting medium accesses. Thus, copy functions may be optimized
depending on the result as no intermediate buffering need to be used if
source and destination are on different physical devices.
\smallskip{}

This function does not set {\tt IoErr()}\key{IoErr()}, even if it cannot
determine the device a file system operates on.

\section{Locks and Files}

Each \emph{file handle} is associated to a lock to the file that has
been opened. The type of the \emph{lock} depends on the access mode
the file has been opened with, table~\ref{table:modelock} for how lock
types and access modes relate.

\begin{rkrmtable}{Lock and File Access Modes} \label{table:modelock}
{\bf Access Mode} & {\bf Lock Type}\\ \hline \hline
{\tt MODE\_OLDFILE} & {\tt SHARED\_LOCK} \\ \hline
{\tt MODE\_READWRITE} & {\tt SHARED\_LOCK} \\ \hline
{\tt MODE\_NEWFILE} & {\tt EXCLUSIVE\_LOCK} \\ \hline
\end{rkrmtable}

The association of {\tt MODE\_READWRITE} to {\tt SHARED\_LOCK} is
unfortunate, and due to a defect in the \emph{RAM-Handler}
implementation in AmigaDOS 2.0 which was then later copied into the
\emph{Fast File System} implementation. Exclusive access to a file
without deleting its contents can, however, be established through the
{\tt OpenFromLock()}\key{OpenFromLock()} function passing in an
\emph{exclusive lock} to the function as argument.

\subsection{Duplicate the Implicit Lock of a File}

The {\tt DupLockFromFH()}\mkey{DupLockFromFH()} function performs a copy of a lock implicit
to a \emph{file handle} of an opened file. For this to succeed, the
file must be opened in the mode {\tt MODE\_OLDFILE}\key{MODE\_OLDFILE}
or {\tt MODE\_READWRITE}\key{MODE\_READWRITE}. Files opened with {\tt
  MODE\_NEWFILE}\key{MODE\_NEWFILE} are based on an implicit \emph{exclusive
lock} that cannot be copied.

\begin{verbatim}
lock = DupLockFromFH(fh)
D0                   D1

BPTR DupLockFromFH(BPTR)
\end{verbatim}

This function returns a copy of the lock the \emph{file handle} {\tt
  fh} is based on and returns it in {\tt lock}. In case of failure,
{\tt ZERO} is returned. In either case, {\tt IoErr()} is set to either
$0$ in case of success, or an error code on failure.

\subsection{Obtaining the Directory a File is Located in}

The {\tt ParentOfFH()}\mkey{ParentOfFH()} function obtains a
\emph{shared lock} on the parent directory of the file associated to
the \emph{file handle} passed in. That is, it is roughly equivalent to
first obtaining a lock on the file through {\tt DupLockFromFile()}
\key{DupLockFromFile()}, and then calling {\tt ParentDir()}\key{ParentDir()}
on it, except that this function also applies to files opened in
the {\tt MODE\_NEWFILE}\key{MODE\_NEWFILE} mode.

\begin{verbatim}
lock = ParentOfFH(fh)
 D0               D1

BPTR ParentOfFH(BPTR)
\end{verbatim}

This function returns in {\tt lock} a shared lock on the directory
containing the file opened through the {\tt fh} \emph{file handle}. It
returns {\tt ZERO} on failure or in case there is no parent directory
because {\tt fh} already represents the root directory.
\smallskip{}

In either case, {\tt IoErr()} \key{IoErr()} is set, namely to $0$ in case of
success or to an error code on failure. Attempting to obtain the parent of
the root directory is not a failure case, and thus {\tt IoErr()} is set to~0
in this case.

\subsection{Opening a File from a Lock} \label{sec:openfromlock}

The {\tt OpenFromLock()} function uses a \emph{lock} and opens the
locked file, returning a \emph{file handle}. If the lock is associated
to a directory, the function fails. The \emph{lock} passed in is then
absorbed into the \emph{file handle} and shall not be unlocked. It
will be released by the file system upon closing the file.

\begin{verbatim}
fh = OpenFromLock(lock)
D0                 D1

BPTR OpenFromLock(BPTR)
\end{verbatim}

This function attempts to open the object locked by {\tt lock} as
file, and creates the \emph{file handle} {\tt fh} from it. It fails in
case the {\tt lock} argument belongs to a directory and not a file.
\smallskip{}

In case of success, the \emph{lock} becomes an implicit part of the
\emph{file handle} and shall not be unlocked by the caller anymore.
In case of failure, the function returns {\tt ZERO} and the
\emph{lock} remains available to the caller, and also needs to be
unlocked at a later time. In either case, {\tt IoErr()} is set, to an
error code in case of failure, or $0$ on success.
\smallskip{}

This function allows to open files in exclusive mode without deleting
its contents. For that, obtain an \emph{exclusive lock} on the file to
be opened, and then call {\tt OpenFromLock()} as second step.

\subsection{Get Information on the State of the Medium} \label{sec:info}

The {\tt Info()}\mkey{Info()} function returns information on the
medium on which the locked object is located, and fills an {\tt
  InfoData} structure with the status of the \emph{file system}. If it
is instead intended to retrieve information on the currently inserted
volume, i.e. without requiring a \emph{lock}, direct communication
with the \emph{file system} on the packet level is required by sending
a packet type of {\tt ACTION\_DISK\_INFO}, see
section~\ref{sec:action_disk_info}.

\begin{verbatim}
success = Info( lock, parameterBlock )
D0		D1    D2

BOOL Info(BPTR, struct InfoData *)
\end{verbatim}

The {\tt lock} is a \emph{lock} to an arbitrary object on the volume
to be querried; its only purpose is to identify it. The function fills
out an {\tt InfoData} structure that shall be aligned to long-word
boundaries.
\smallskip{}

This structure is defined in {\tt dos/dos.h} and reads as follows:
\mkey{InfoData}
\begin{verbatim}
struct InfoData { 
   LONG	  id_NumSoftErrors;
   LONG	  id_UnitNumber;
   LONG	  id_DiskState;
   LONG	  id_NumBlocks;
   LONG	  id_NumBlocksUsed;
   LONG	  id_BytesPerBlock;   
   LONG	  id_DiskType;		
   BPTR	  id_VolumeNode;
   LONG	  id_InUse;
};
\end{verbatim}
The elements of this structure are interpreted as follows:
\smallskip{}

{\tt id\_NumSoftErrors} counts the number of read or write errors the
file system detected during its life-time. It is not particularly
bound to the currently inserted medium.
\smallskip{}

{\tt id\_UnitNumber} is the unit number of the exec device on which
the \emph{file system} operates, and hence into which the volume
identified by the \emph{lock} is inserted.
\smallskip{}

{\tt id\_DiskState} identifies the status of the file system, whether
the volume is writable and whether it is consistent. Disk states are
also defined in {\tt dos/dos.h} and set according to the following table:

\begin{rkrmtable}{Disk States} \label{table:diskstate}
{\bf Disk State} & {\bf Description}\\ \hline \hline
{\tt ID\_WRITE\_PROTECTED} & The volume is write protected \\ \hline
{\tt ID\_VALIDATING} & The volume is currently validating \\ \hline
{\tt ID\_VALIDATED} & The volume is consistent and read- and writeable \\ \hline
\end{rkrmtable}

A volume in the state {ID\_WRITE\_PROTECTED} has been identified as
consistent, but does not accept modifications, either because the
medium is physically write-protected, or because it has been locked by
software, see section~\ref{sec:action_write_protect}.
\smallskip{}

A volume gets the state {\tt ID\_VALIDATING} if its \emph{file system}
detected inconsistencies; some file systems, including the Fast File
System, then trigger a consistency check of the volume. The Fast File
System rebuilds the bitmap of the volume that describes which blocks
are allocated and which are free. It cannot fix more severe errors and
then presents a requester to the user indicating the problem. During
validation, file systems typically refuse to accept write requests. If
validation cannot bring the volume into a consistent state, the disk
state will remain {\tt ID\_VALIDATING}.
\smallskip{}

A volume in state {\tt ID\_VALIDATED} is consistent and read- and
writeable.
\medskip{}

{\tt id\_NumBlocks} is the total number of blocks into which the
medium is divided. This includes both free and occupied blocks, and
thus indicates the total capacity of the volume. This number is not
necessarily constant. The RAM-Handler adjusts this value according to
the available memory; RAM-Handler versions prior version 45 set this
to~0. In means, in particular, that care needs to be taken when the
disk fill state in percent is computed by a dividing the number of
used blocks by this number.
\smallskip{}

{\tt id\_NumBlocksUsed} is the number of blocks occupied by file
system on the disk. As it is dependent on the file system how many
blocks it needs in addition to the actual payload data, no conclusion
can be derived from this number whether a particular file fits on the
volume. RAM-Handlers prior to release 45 did not even fill this with a
useful value.
\smallskip{}

{\tt id\_BytesPerBlock} is the number of bytes available for payload
in a physical block of the medium, and not necessarily the physical
block size into which the storage medium is divided. Some file systems
require additional bytes of the physical block for administrating
files. Even the RAM-Handler segments data into blocks and provides in
this member the number of data bytes stored there.
\smallskip{}

{\tt id\_DiskType} identifies whether the \emph{file system} that
generated the {\tt lock} argument can identify the disk structure and
claims responsibility for it. Unlike what the name suggests, it is
\emph{not} a general identifier of the type \emph{file system} itself
and shall not be used to identify a paritcular file system. For legacy
reasons, the various flavours of the Fast File System also leave their
identifier here, though this principle should not be carried over to
new designs. Instead, a file system should rather return the generic
{\tt ID\_DOS\_DISK} if it finds a medium for which it claims
responsibility. Even if the file system recognizes the disk structure
as one of its own, it is possible that the structure is
considered inconsistent by setting {\tt id\_DiskState} to {\tt
  ID\_VALIDATING}.
\smallskip{}

AmigaDOS currently defines the following disk types in {\tt dos/dos.h}:
\begin{rkrmtable}{Disk Types} \label{table:disktype}
{\bf Disk Type} & {\bf Description}\\ \hline \hline
{\tt ID\_NO\_DISK\_PRESENT} & No disk is inserted \\ \hline
{\tt ID\_UNREADABLE\_DISK} & Reading disk data failed at exec device level \\ \hline
{\tt ID\_DOS\_DISK} & The disk is in a format the file system attempts to interpret \\ \hline
{\tt ID\_NOT\_REALLY\_DOS} & While disk contents can be accessed, it is not in a suitable structure\\ \hline
{\tt ID\_KICKSTART\_DISK} & A disk containing an A1000 kickstart \\ \hline
{\tt 'BUSY'} & The file system is currently inhibited \\ \hline
{\tt 'CON\textbackslash0'} & Not a file system, but the Con-Handler \\ \hline
{\tt 'RAW\textbackslash0'} & Not a file system, but the Con-Handler \\ \hline
All others & The first long word of the first block of the medium \\ \hline
\end{rkrmtable}

As mentioned above {\tt ID\_DOS\_DISK} is the {\tt id\_DiskType} \emph{file
systems} should return in case they recognize the structure and attempt to
interpret them. Despite this fact, the Fast File System returns erroneously
the {\tt dostype} as reported in table~\ref{table:ffsflavours}.
\smallskip{}

\punchline{Not the DosType}{While mount lists include a {\tt DOSTYPE}
  field that identifies the \emph{file system} uniquely, the {\tt
    id\_DiskType} member \emph{does not} represent this {\tt
    DOSTYPE}. That it coincides with the {\tt DOSTYPE} for the
  variants of the FFS is a historical error that shall not be mirrored
  by new \emph{file system} designs. It is therefore advisable to
  check the first 3 bytes of the {\tt id\_DiskType} for the characters
  {\tt DOS}, and if so, assume that the disk is valid and can be
  interpreted by the \emph{file system}. Unfortunately, some
  third-party designs do not follow this convention.}

{\tt ID\_NOT\_REALLY\_DOS} and {\tt ID\_UNREADABLE\_DISK} both
indicates disks the file system cannot make use of. The first because
the logical structure of the disk content cannot be interpreted, and
the second because the underlying exec device cannot gain access to
the contents of the blocks, i.e. the physical layer of the disk is not
readable.
\smallskip{}

{\tt 'BUSY'} is a four-character constant that is not documented in
{\tt dos/dos.h}, but returned whenever a file system has been
inibited, i.e. its access to the physical layer has been
stopped. Thus, any attempt to access this file system is currently
suspended, probably because some program attempts to operate on the
medium on a lower level. Disk editors or disk salvage programs will
typically make use of this practise to avoid file systems from
touching the medium while they work on it.
\smallskip{}

{\tt 'CON\textbackslash0'} and {\tt 'RAW\textbackslash0'} are indicators left by the Con-Handler
(or console-type handlers) which use the {\tt InfoData} structure for
other purposes, see section~\ref{sec:console}. As they do not (in
general) hand out locks, the {\tt Info()} function will usually not
return these two types, but direct handler communication with a packet
type of {\tt ACTION\_DISK\_INFO} can.
\smallskip{}

All other types are returned in case the \emph{file system} cannot
interpret the disk structure, and are then copied from the first 4
bytes of the medium or partition into {\tt id\_DiskType}. In case
these bytes are all~0, it is changed to {\tt ID\_NOT\_REALLY\_DOS}.
\medskip{}

{\tt id\_VolumeNode} in the {\tt InfoData} structure is a BPTR to the
{\tt DosList}\key{DosList} structure corresponding to the volume on
which the object identified by the {\tt lock} is located. For this
structure, see section~\ref{sec:devicelist}.
\smallskip{}

{\tt id\_InUse} counts the number of locks and files currently open on
the medium identified by {\tt lock}.
\medskip{}

This function returns a non-zero result code on success and sets then
{\tt IoErr()}\key{IoErr()} to~0. On failure, it returns~0 and sets
{\tt IoErr()} to an error code.

\subsection{The struct FileLock} \label{sec:filelock}

\emph{Locks} have been so far been opaque identifiers; in fact, they
are \emph{BPTR}s to a {\tt struct FileLock} that is defined in {\tt
  dos/dosextens.h}.

\begin{verbatim}
#include <dos/dosextens.h>
lock = Lock("S:Startup-Sequence",SHARED_LOCK);
struct FileLock *flock = BADDR(lock);
\end{verbatim}

While this structure is defined there, it is not allocated by the
\emph{dos.library} but by the \emph{file system} itself. The file
system may therefore allocate a structure that is somewhat larger and
can have additional members that are not shown here. 

\mkey{FileLock}
\begin{verbatim}
struct FileLock {
    BPTR                fl_Link;        /* bcpl pointer to next lock */
    LONG                fl_Key;         /* disk block number */
    LONG                fl_Access;      /* exclusive or shared */
    struct MsgPort *    fl_Task;        /* handler task's port */
    BPTR                fl_Volume;      /* bptr to DLT_VOLUME DosList entry */
};
\end{verbatim}

Most of the members of this structure are of no practical value, and
they should not be interpreted in any way. What is listed here is the
information callers can depend upon.
\smallskip{}

The {\tt fl\_Link} member has no practical value for users; the
\emph{file system} can use it to keep multiple links on object on the
same volume in a list. This is particularly important if the volume is
ejected from its drive and another file system needs to take over the
\emph{locks} if the volume is later inserted into another drive.
\smallskip{}

The {\tt fl\_Key} member can be used by the file system to identify the
object that has been locked. It may not necessarily be an integer, but
can be any data type, potentially a pointer to some internal
management object. It shall not be interpreted in any particular way.
\smallskip{}

The {\tt fl\_Access} member keeps the type of the lock. It is either {\tt SHARED\_LOCK}\key{SHARED\_LOCK}
or {\tt EXCLUSIVE\_LOCK}\key{EXCLUSIVE\_LOCK}.
\smallskip{}

The {\tt fl\_Task} member points to the message port of the file
system for processing requests on the lock. Any activity on the lock
goes through this port.
\smallskip{}

The {\tt fl\_Volume} is a \emph{BPTR} to the \emph{volume node} on the
\emph{Device list}\key{Device list}. The \emph{volume node} identifies
the volume the locked object is located
on. Section~\ref{sec:devicelist} provides further information on this
list and its entries.

\chapter{Working with Directories}

As objects on a file system can be identified by a name, these names
need to be stored somewhere on the data carrier. This object is called
a \emph{directory}. While a flat file system only contains a single,
topmost directory which then contains all files, a directory of a
hierarchical file system can contain other directories, thus creating
a \emph{tree} of nested objects, see also
section~\ref{sec:flathierarchical}.
\smallskip{}

AmigaDOS provides functions to list the directory contents, to move
objects in the file system hierarchy or change their name, and to
access adjust their metadata, such as comments, protection bits, or
creation dates.
\smallskip{}

AmigaDOS also supports \emph{links}, that is, entries in the file
system that point to some other object in the same, or some other file
system. Therefore, links circumvent the hierarchy otherwise imposed by
the tree structure of the file system.

\section{Examining Objects on File Systems} \label{sec:fib}

Given a lock on a file or a directory, further information on such an
object can be requested by the {\tt Examine()}\key{Examine()} function
of the \emph{dos.library}. To read multiple directory entries at once
and minimizing the calling overhead, {\tt ExAll()}\key{ExAll()}
provides an advantage that is, however, harder to use, but also
provides options to filter entries.

\punchline{May go away while you look!}{As AmigaDOS is a multitasking operating
system, the directory may change under your feed while scanning; in
particular, entries you received through the above functions may not
be up to date, may have been deleted already when the above functions
return, or new entries may have been added the current scan will not
reach. While a \emph{Lock} on a directory prevents that this directory
goes away, it does \emph{not} prevent other processes to add or remove
objects to this directory, so beware.}

While {\tt ExAll()} seems to provide an advantage by reading multiple
directory entries in one go, the AmigaOS ROM file system does usually
not profit from this feature, at least not unless a directory cache is
used. The latter has, however, other drawbacks and should be avoided
for different reasons, see section~\ref{sec:ffs}.
Actually, {\tt ExAll()} is (even more) complex to implement, and it is
probably not surprising that multiple file systems have issues. The
{\tt dos.library} provides an {\tt ExAll()} implementation for those
file systems that do not implement it themselves, but even this
(ROM-based) implementation had issues in the past. Therefore,
{\tt ExAll()} has probably less to offer than it seems.
\smallskip{}

{\tt Examine()} and {\tt ExNext()} fill a {\tt FileInfoBlock}\mkey{FileInfoBlock}
structure that collects information on an examined object in a directory.
It is defined in {\tt dos/dos.h} and reads as follows:
\begin{verbatim}
struct FileInfoBlock {
   LONG   fib_DiskKey;
   LONG   fib_DirEntryType;  /* Type of Directory. If < 0, then a plain file.
                              * If > 0 a directory */
   char   fib_FileName[108]; /* Null terminated. Max 30 chars used for now */
   LONG   fib_Protection;    /* bit mask of protection, rwxd are 3-0.      */
   LONG   fib_EntryType;
   LONG   fib_Size;          /* Number of bytes in file */
   LONG   fib_NumBlocks;     /* Number of blocks in file */
   struct DateStamp fib_Date;/* Date file last changed */
   char   fib_Comment[80];  /* Null terminated comment associated with file */

   /* Note: the following fields are not supported by all filesystems.  */
   /* They should be initialized to 0 sending an ACTION_EXAMINE packet. */
   /* When Examine() is called, these are set to 0 for you.             */
   /* AllocDosObject() also initializes them to 0.                      */
   UWORD  fib_OwnerUID;         /* owner's UID */
   UWORD  fib_OwnerGID;         /* owner's GID */
   char   fib_Reserved[32];
}; /* FileInfoBlock */

\end{verbatim}
The meaning of the members of this structure are as follows:
\medskip{}

{\tt fib\_DiskKey} is a file system internal identifier of the
object. It shall not be used, and programs shall not make any
assumptions on its meaning.
\smallskip{}

{\tt fib\_DirEntryType} identifies the type of an object. Object types
are defined in {\tt dos/dosextens.h}, replicated in
table~\ref{table:direntrytypes}:

\begin{rkrmtable}{Directory Entry Types} \label{table:direntrytypes}
{\bf Value of {\tt \bf fib\_DirEntryType}} & {\bf Description}\\ \hline \hline
{\tt ST\_SOFTLINK} & Object is a soft link to another object \\ \hline
{\tt ST\_LINKDIR} & Object is a hard link to a directory \\ \hline
{\tt ST\_LINKFILE} & Object is a hard link to a file \\ \hline
\end{rkrmtable}
All other types $>0$ indicate directories, and all other types $<0$
indicate files. Section~\ref{sec:link} provides more details on soft
links and hard links.
\smallskip{}

{\tt fib\_FileName} is the name of the object as {\tt NUL} terminated
string.
\smallskip{}

{\tt fib\_Protection} are the protection bits of the object. It
defines which operations can be performed on it. The following
protection bits are currently defined in {\tt dos/dos.h}:
\begin{rkrmtable}{Protection Bits} \label{table:protectionbits}
{\bf Protection Bits} & {\bf Description}\\ \hline \hline
{\tt FIBB\_DELETE} & If this bit is $0$, the object can be deleted.\\ \hline
{\tt FIBB\_EXECUTE} & If this bit is $0$, the file is an executable binary.\\ \hline
{\tt FIBB\_WRITE} & If this bit is $0$, the file can be written to.\\ \hline
{\tt FIBB\_READ} & If this bit is $0$, the file content can be read. \\ \hline
{\tt FIBB\_ARCHIVE} & This bit is set to $0$ on every write access. \\ \hline
{\tt FIBB\_PURE} & If $1$, the executable is reentrant and can be made resident. \\ \hline
{\tt FIBB\_SCRIPT} & If $1$, the file is a script. \\ \hline
{\tt FIBB\_HOLD} & If $1$, the executable is made resident on first execution. \\ \hline
\end{rkrmtable}
The flags {\tt FIBB\_DELETE} to {\tt FIBB\_READ} are shown inverted in
the output of most tools, i.e. they are shown active if the
corresponding flag is $0$, i.e. a particular protection function is
\emph{not} active. The {\tt FIBB\_READ} and {\t FIBB\_WRITE} bits were
ignored by early implementations of the ROM \emph{file system}. This was
fixed in release 36.
\smallskip{}

The {\tt FIBB\_EXECUTE} flag is only interpreted by the \emph{Shell} (see
section~\ref{sec.shell}) and the Workbench; if the bit is $1$, the
\emph{Shell} and the Workbench refuse to load the file as command or
program.
\smallskip{}

The {\tt FIBB\_ARCHIVE} flag is typically used by archival software. Such
software will set this flag upon archiving the flag, whereas the file system
will reset the flag when writing to or modifying a file, or when creating
new files. The archiving software is thus able to learn which files had been
altered since the last backup.
\smallskip{}

The {\tt FIBB\_PURE} flag indicates an additional property of
executable binaries; if the flag is set, the binaries do not alter
their segments and their code can be loaded in \emph{RAM} and stay
there to be executed from multiple processes in parallel. This avoids
loading the binary multiple times. The \emph{Shell} command
{\tt resident} can load such binaries into \emph{RAM} for future usage.
\smallskip{}

The {\tt FIBB\_SCRIPT} flag indicates whether a file is a \emph{Shell}
or an \emph{ARexx} script. If this flag is set, and the script is
given as command to the \emph{Shell}, it will forward this file to a
suitable script interpreter, such as \emph{ARexx} or {\tt Execute}.
\smallskip{}

The {\tt FIBB\_HOLD} flag indicates whether a command shall be made
resident upon loading it the first time. If the flag is $1$, and the
shell loads the file as executable binary, and the {\tt FIBB\_PURE}
bit is also set, the file is kept in \emph{RAM} and stays there for
future execution.
\medskip{}

The {\tt fib\_EntryType} member shall not be used; it can be identical
to the {\tt fib\_DirEntryType}, but its use is not documented.
\smallskip{}

The {\tt fib\_Size} member indicates the size of the file in bytes. It
should have probably be defined as an unsigned type. Its value is
undefined for directories.
\smallskip{}

The {\tt fib\_NumBlocks} member indicates now many blocks a file
occupies on the storage medium, if such a concept applies. Disks and
harddisk organize their storage into blocks of equal size, and the
file system manages these blocks to store data on the medium. The
number of blocks can be meaningless for directories.
\smallskip{}

The {\tt fib\_Date} member indicates when the file was changed last;
depending on the file system, the date may also indicate when the last
modification was made for a directory, such as creating or deleting a
file within. Which operations exactly trigger a change of a directory
is file system dependent. The {\tt DateStamp}\key{DateStamp} structure is specified
in section~\ref{sec:datestamp}.
\smallskip{}

The {\tt fib\_Comment} member contains a {\tt NUL} terminated string
to a comment on the file. Not all file systems support comments. The
comment has no particular meaning, it is only shown by some
\emph{Shell} commands or utilities and can be set by the user.
\smallskip{}

The {\tt fib\_OwnerUID} and {\tt fib\_OwnerGID} are filled in by some
multi-user aware file systems. The AmigaDOS ROM file systems do not
support these fields, and no provision is made to moderate access to a
particular file according to an owner or its group. The two concepts
are alien to AmigaDOS itself.
\smallskip{}

The {\tt fib\_Reserved} field is currently unused and shall not be
accessed.

\subsection{Retrieving Information on an Directory Entry}

The {\tt Examine()}\mkey{Examine()} function retrieves information on the object
identified by a \emph{lock} and fills a {\tt FileInfoBlock} from it.

\begin{verbatim}
success = Examine( lock, FileInfoBlock )
D0                  D1        D2

BOOL Examine(BPTR,struct FileInfoBlock *)
\end{verbatim}

This function fills out the {\tt FileInfoBlock}\key{FileInfoBlock} providing information
on the object identified by {\tt lock}. The structure is discussed in
section~\ref{sec:fib} in more detail. The function returns non-zero in
case of success, and $0$ for failure. In either case, {\tt IoErr()} is filled,
by $0$ on success, on an error code on failure.

\punchline{Keep it Aligned!}{As with most BCPL structures, the {\tt
    FileInfoBlock} shall be aligned to a long-word boundary. For that
  reason, it should be allocated from the heap. Section~\ref{sec:bptrs}
  provides some additional hints on how to allocate such structures.}

\subsection{Retrieving Information from a File Handle}

While {\tt Examine()}\key{Examine()} retrieves information a locked
object, {\tt ExamineFH()}\mkey{ExamineFH()} retrieves the same
information from a \emph{file handle}, or rather from the \emph{lock}
implicit to the handle.

\begin{verbatim}
success = ExamineFH(fh, fib)
D0                  D1  D2

BOOL ExamineFH(BPTR, struct FileInfoBlock *)
\end{verbatim}

This function examines the object accessed through the
\emph{file handle} {\tt fh}, and returns the information in the
\emph{FileInfoBlock}\key{FileInfoBlock}\key{FileInfoBlock}. Note that
the file content and thus its change can be changed any time, and thus
the information returned by this function may not be fully up-to-date,
see also the general information in section~\ref{sec:fib}.
\smallskip{}

This function returns non-zero in case of success, or $0$ on error. In
either case, {\tt IoErr()}\key{IoErr()} is set, namely to $0$ on
success and to an error code otherwise.
\smallskip{}

As for {\tt Examine()}\key{Examine()}, the \emph{FileInfoBlock} shall
be aligned to a 4-byte boundary.

\subsection{Scanning through a Directory Step by Step}

The {\tt ExNext()}\mkey{ExNext()} function iterates through entries of
a directory, retrieving information on one object after another
contained in this directory. For scanning through a directory, first
{\tt Lock()}\key{Lock()} the directory itself. Then use {\tt
  Examine()}\key{Examine()} on the \emph{lock}. This provides
information on the directory itself.
\smallskip{}

To learn about the objects in the directory, iteratively call {\tt
  ExNext()} on the same {\tt lock} and on the same {\tt FileInfoBlock}
until the function returns {\tt DOSFALSE}. Each iteration provides
then information on the subsequent element in the directory of the
{\tt lock}.

\begin{verbatim}
success = ExNext( lock, FileInfoBlock )
D0                 D1        D2

BOOL ExNext(BPTR, struct FileInfoBlock *)
\end{verbatim}

This call returns information on the subsequent entry of a directory
identified by {\tt lock} and deposits this information in the {\tt
  FileInfoBlock}\key{FileInfoBlock} described in~\ref{sec:fib}. The
{\tt lock} shall be a \emph{lock} on a directory, in particular.
\smallskip{}

On success, {\tt ExNext()} returns non-zero. If there is no further
element in the scanned directory, or on an error, it returns {\tt
  DOSFALSE}. In either event, {\tt IoErr()}\key{IoErr()} is set,
namely to $0$ in case of success, or to an error code otherwise.
\smallskip{}

At the end of the directory, the function returns {\tt DOSFALSE}, and
the error code as obtained from {\tt IoErr()} is set to {\tt
  ERROR\_NO\_MORE\_ENTRIES}.

\punchline{Same Lock, Same FIB}{To iterate through a directory, a lock
  to the same directory as passed into {\tt Examine()}\key{Examine()}
  shall be used. Actually, the same \emph{lock} should be used, and
  the same \emph{FileInfoBlock} should be used. As important state
  information is associated to the \emph{lock} and
  \emph{FileInfoBlock}, {\tt UnLock()}ing the original \emph{lock} and
  obtaining a new \emph{lock} on the same directory looses this
  information; using a different \emph{FileInfoBlock} also looses this
  state information, requiring the \emph{file system} to rebuild this
  state information, which is not only complex, but also slows down
  scanning the directory. In particular, you shall \emph{not} use the
  same \emph{FileInfoBlock} you used for scanning one directory for
  scanning a second, different directory as this can confuse the
  \emph{file system}. Also, as for {\tt Examine()}\key{Examine()}, the
       {\tt FileInfoBlock} shall be aligned to a long-word boundary.}

\subsection{Examine Multiple Entries at once} \label{sec:exall}

While scanning a directory with {\tt ExNext()}\key{ExNext()} requires
one interaction with the \emph{file system} for each entry and is
therefore potentially slow, {\tt ExAll()}\mkey{ExAll()} retrieves as
many entries as possible in one go. Whether a particular file system
can take advantage of such a block transfer is a matter of its original
organization, however.

\begin{verbatim}
continue = ExAll(lock, buffer, size, type, control)
D0               D1     D2     D3    D4     D5

BOOL ExAll(BPTR,STRPTR,LONG,LONG,struct ExAllControl *)
\end{verbatim}

This function examines as many directory entries belonging to the
directory identified by {\tt lock} as fit into the buffer {\tt buffer}
of {\tt size} bytes. This buffer is filled by a linked list of {\tt
  ExAllData} structures, see below for their layout. {\tt type}
determines which elements of {\tt ExAllData} is filled.
\smallskip{}

The {\tt lock} shall be a lock on the directory to be examined. It shall not
be {\tt ZERO}.
\smallskip{}

To start a directory scan with {\tt ExAll()}, first allocate a {\tt
  ExAllControl}\mkey{ExAllControl} structure through {\tt
  AllocDosObject()}\key{AllocDosObject()}, see~\ref{sec:allocdosobject}.
This structure looks as follows:

\mkey{ExAllControl}
\begin{verbatim}
struct ExAllControl {
  ULONG   eac_Entries;     /* number of entries returned in buffer      */
  ULONG   eac_LastKey;     /* Don't touch inbetween linked ExAll calls! */
  UBYTE  *eac_MatchString; /* wildcard string for pattern match or NULL */
  struct Hook *eac_MatchFunc; /* optional private wildcard function     */
};
\end{verbatim}

{\tt eac\_Entries} is provided by the \emph{file system} upon
returning from {\tt ExAll} and then contains the number of entries
that fit into the {\tt buffer}. Note that this number may well be $0$,
which does not need to indicate termination of the scan. Callers shall
instead check the return code of {\tt ExAll()} to learn on whether
scanning may continue or not.
\smallskip{}

{\tt eac\_LastKey} is a \emph{file system} internal identifier of the
current state of the directory scanner. This member shall not be
interpreted nor modified in any way.
\smallskip{}

{\tt eac\_MatchString} filters the directory entry names, and returns
only those that match the wild card pointed to by this member. This
entry shall be either {\tt NULL}, or a pre-parsed pattern as generated
by {\tt ParsePatternNoCase()}\key{ParsePatternNoCase()}.
\smallskip{}

{\tt eac\_MatchFunc} is a even more flexible option to filter
directory entries. It shall be either {\tt NULL} or point to a {\tt
  struct Hook} as defined in {\tt utility/hooks.h}. If set, then for
each directory entry the hook function {\tt h\_Entry} is called as
follows:

\begin{verbatim}
match = (hook->h_Entry)(struct Hook *hook, LONG *datap,
d0                                    a0          a2

                        struct ExAllData *buf )
                                          a1
\end{verbatim}

that is, register {\tt a0} points to the called hook, register {\tt a1} to
the data buffer that is part of the {\tt buffer} supplied by the caller of
{\tt ExAll()} and which is already filled in with a candidate {\tt
  ExAllData} structure to be checked for acceptance. Register {\tt a2}
points to a {\tt LONG}, which is a copy of the {\tt type} argument supplied
to {\tt ExAll()}. If the hook function returns non-zero, a match is assumed
and the directory entry remains in the output buffer. Otherwise, the data is
discarded.
\smallskip{}

{\tt eac\_MatchFunc} and {\tt eac\_MatchString} shall not be filled in
simultaneously, only one of the two shall be non-{\tt NULL}. If both
members are {\tt NULL}, all entries match.
\medskip{}

The {\tt buffer} supplied to {\tt ExAll()} is filled by a singly
linked list of {\tt ExAllData} structures that look as follows:
\mkey{ExAllData}
\begin{verbatim}
struct ExAllData {
        struct ExAllData *ed_Next;
        UBYTE  *ed_Name;
        LONG    ed_Type;
        ULONG   ed_Size;
        ULONG   ed_Prot;
        ULONG   ed_Days;
        ULONG   ed_Mins;
        ULONG   ed_Ticks;
        UBYTE  *ed_Comment;     /* strings will be after last used field */
        UWORD   ed_OwnerUID;    /* new for V39 */
        UWORD   ed_OwnerGID;
};
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt ed\_Next} points to the next {\tt ExAllData} structure within
{\tt buffer}, or {\tt NULL} for the last structure filled in.
\smallskip{}

{\tt ed\_Name} points to the file name of a directory entry, and
supplies the same name as {\tt fib\_FileName} as in the {\tt FileInfoBlock}.
\smallskip{}

{\tt ed\_Type} identifies the type of the entry. It identifies
directory entries according to table~\ref{table:direntrytypes} and
corresponds to {\tt fib\_DirEntryType}.
\smallskip{}

{\tt ed\_Size} is the size of the directory element for files. It is
undefined for directories. It corresponds to {\tt fib\_Size}.
\smallskip{}

{\tt ed\_Prot} collects the protection bits of the directory entry
according to table~\ref{table:protectionbits} and by that corresponds
to {\tt fib\_Protection}.
\smallskip{}

{\tt ed\_Days}, {\tt ed\_Mins} and {\tt ed\_Ticks} identifies the date
of the last change to the directory element. It corresponds to {\tt fib\_Date}.
Section~\ref{sec:setfiledate} defines these elements more rigorously.
\smallskip{}

{\tt ed\_Comment} points to a potential comment on the directory entry
and corresponds to {\tt fib\_Comment}.
\smallskip{}

{\tt ed\_ed\_OwnerUID} and {\tt ed\_OwnerGID} contain potential user
and group IDs if the file system is able to provide such
information. All the AmigaDOS native file systems do not.
\medskip{}

Which members of the {\tt ExAllData} structure are filled in is
selected by the {\tt type} argument. It shall be selected according to
table~\ref{table:exalltypes}, whose elements are defined in
{\tt dos/exall.h}:

\begin{rkrmtable}{Type Values} \label{table:exalltypes}
{\bf Type} & {\bf Filled Members}\\ \hline \hline
{\tt ED\_NAME} & Fill only {\tt ed\_Next} and {\tt ed\_Name}\\ \hline
{\tt ED\_TYPE} & Fill all members up to {\tt ed\_Type} \\ \hline
{\tt ED\_SIZE} & Fill all members up to {\tt ed\_Size} \\ \hline
{\tt ED\_PROTECTION} & Fill all members up to {\tt ed\_Prot} \\ \hline
{\tt ED\_DATE} & Fill all members up to {\tt ed\_Ticks}, i.e. up to the date \\ \hline
{\tt ED\_COMMENT} & Fill all members up to {\tt ed\_Comment} \\ \hline
{\tt ED\_OWNER} & Fill all members up to {\tt ed\_OwnerGID} \\ \hline
\end{rkrmtable}

The return code {\tt continue} is non-zero in case the directory
contents was too large to fit into the supplied {\tt buffer}
completely. In such a case, either {\tt ExAll()} shall be called again
to read additional entries, or {\tt ExAllEnd()}\key{ExAllEnd()} shall
be called to terminate the call and release all internal state information.
\smallskip{}

If {\tt ExAll()} is called again, the {\tt lock} shall be identical to
the {\tt lock} passed into the first call, and not only a copy on the
same directory as for the first call.
\smallskip{}

The return code {\tt continue} is {\tt DOSFALSE} in case the scan
result fit entirely into {\tt buffer} or in case an error occurred.
\smallskip{}

Regardless of the return code, {\tt IoErr()} is set to $0$ in case
{\tt continue} is non-zero, or to an error code otherwise. If the
error code is {\tt ERROR\_NO\_MORE\_ENTRIES}, then {\tt ExAll()}
terminated because all entries have been read and scanning the
directory completed. In this case, {\tt ExAllEnd()} should not be
called.
\medskip{}

Not all file systems --- actually, none delivered with AmigaOs ---
support {\tt ED\_OWNER}. If {\tt continue} is {\tt DOSFALSE} and
{\tt IoErr()} is {\tt ERROR\_BAD\_NUMBER}, try to reduce {\tt type} and
call {\tt ExAll()} again.
\smallskip{}

Some file systems do not implement {\tt ExAll()} themselves; in such a
case, the \emph{dos.library} provides a fall-back implementation
keeping {\tt ExAll()} workable regardless of the completeness of the
target \emph{file system}.

\subsection{Aborting a Directory Scan}

To abort an {\tt ExAll()}\key{ExAll()} scan through a directory,
{\tt ExAllEnd()}\mkey{ExAllEnd()} shall be called to explicitly release
all state information associated to the scan. This is unlike an
item-by-item scan through {\tt ExNext()}\key{ExNext()} which does not
require explicit termination.

\begin{verbatim}
ExAllEnd(lock, buffer, size, type, control)
          D1     D2     D3    D4     D5

void ExAllEnd(BPTR,STRPTR,LONG,LONG,struct ExAllControl *)
\end{verbatim}

This function aborts an {\tt ExAll()} driven directory scan before it
terminates due to an error or due to the end of the directory,
i.e. whenever {\tt ExAll()} returns with a non-zero result code which
would indicate that the function should be called again.
\smallskip{}

{\tt ExAll()} may also be the fastest way to terminate a directory
scan once it is running, for example on network file systems where the
scan may proceed offline on a separate server. The arguments to
{\tt ExAllEnd()} shall be exactly those supplied to
{\tt ExAll()}\key{ExAll()} which it is supposed to terminate. Note in
particular that the {\tt lock} shall be identical to the \emph{lock}
passed into {\tt ExAll()}, and not just a \emph{lock} to the same
object.

\section{Modifying Directory Entries}

While the functions in section~\ref{sec:fib} read directory entries,
the functions listed here modify the directory and its entries.

\subsection{Deleting Objects on the File System}

The {\tt DeleteFile()}\mkey{DeleteFile()} function removes --- despite
its name --- not only files, but also directories and links from a
directory. For this to succeed, the object need to allow deletion
through its protection bits (see section~\ref{sec:fib}), and no
\emph{locks} are held on the object (see section~\ref{sec:locks}).  To
be able to delete a directory, this directory needs to be empty in
addition.

\begin{verbatim}
success = DeleteFile( name )
 D0                    D1

BOOL DeleteFile(STRPTR)
\end{verbatim}

This function deletes the object given by the last component of the
path passed in as {\tt name}. It returns non-zero in case of success,
or $0$ in case of error. In either case, {\tt IoErr()}\key{IoErr()} is
set, namely $0$ on success or an error code in case of failure.

\subsection{Rename or Relocate an Object}

The {\tt Rename()}\mkey{Rename()} function changes the name of an
object, or even relocates it from one directory to another.

\begin{verbatim}
success = Rename( oldName, newName )
  D0                D1       D2

BOOL Rename(STRPTR, STRPTR)
\end{verbatim}

This function renames and optionally relocates an object between
directories. The {\tt oldName} is the current path to the object, and
its last component is the current name of the object to relocate and
rename; {\tt newName} is the target path and its last component the
target name of the object. The target directory may be different from
the directory the object is currently located in, and the target name
may be different from the current name. However, current path and
target path shall be on the same volume, and the target directory
shall not already contain an object of the target name; otherwise,
current and target path may be either relative or absolute paths.
\smallskip{}

A third condition is that if the object to relocate is a directory,
then the target path shall not be a position within the object to
relocate, i.e. you cannot move a directory into itself.
\smallskip{}

This function returns a boolean success indicator. It is non-zero on
success, or $0$ on error. In either case, {\tt IoErr()}\key{IoErr()}
is set, to $0$ on success, or to an error code otherwise.

\subsection{Set the File Comment}

The {\tt SetComment()}\mkey{SetComment()} function sets the comment of
an directory entry, provided the \emph{file system} supports comments.

\begin{verbatim}
success = SetComment( name, comment )
D0                    D1    D2

BOOL SetComment(STRPTR, STRPTR)
\end{verbatim}

This function sets the comment of the \emph{file system} object whose
path is given by {\tt name} to {\tt comment}. It depends on the file
system whether or how long comments can grow. The maximum comment
length AmigaDOS supports is 79 characters, due to the available space
in the {\tt FileInfoBlock}\key{FileInfoBlock} structure.
\smallskip{}

This function returns non-zero on success and $0$ on error. In either
case, the function sets {\tt IoErr()}\key{IoErr()} to $0$ on success
or to an error code otherwise.

\subsection{Setting Protection Bits}

The {\tt SetProtection()}\mkey{SetProtection()} function modifies the
protection bits of a \emph{file system} object, i.e. either a file or a
directory.

\begin{verbatim}
success = SetProtection( name, mask )
D0			 D1    D2

BOOL SetProtection (STRPTR, LONG)
\end{verbatim}

This function sets the protection bits of the file system object {\tt name}
in the current directory to the combination given by {\tt mask}. The
protection bits are defined in {\tt dos/dos.h} and their function is listed.
in table~\ref{table:protectionbits}. The {\tt mask} value corresponds to
what {\tt Examine()}\key{Examine()} returns in the {\tt FileInfoBlock}
structure in {\tt fib\_Protection}, see also section~\ref{sec:fib}.
\smallskip{}

This function returns a non-zero result code on success, or zero on
error. In either case, {\tt IoErr()}\key{IoErr()} is altered, either to~$0$
on success or to an error code otherwise.

\subsection{Set the Modification Date} \label{sec:setfiledate}

The {\tt SetFileDate()}\mkey{SetFileDate()} function sets the
modification date of an object of a \emph{file system}. Despite its
name, the function can also set the modification date of directories
and links if the file system supports them.

\begin{verbatim}
success = SetFileDate(name, date)
D0                     D1    D2

BOOL SetFileDate(STRPTR, struct DateStamp *)
\end{verbatim}

This function adjusts the modification date of the \emph{file system}
object identified by path as given by {\tt name} to {\tt date}. The
{\tt DateStamp}\key{DateStamp} structure is specified in
section~\ref{sec:datestamp}.
\smallskip{}

This function returns $0$ on error or non-zero on success. In either
case, {\tt IoErr()} is set, either to $0$ on success or to an error
code otherwise.
\smallskip{}

Note that not all file systems may be able to set the date precisely
to ticks, e.g. {\tt FAT} has only a precision of 2 seconds. Some file
systems may refuse to set the modification date if an object is
exclusively locked, this is unfortunately not handled consistently.

\subsection{Set User and Group ID}

The {\tt SetOwner()}\mkey{SetOwner()} function sets the user and group
ID of an object within a \emph{file system}. Both are concatenated to
a 32-bit ID value. While this function seems to imply that the file
system or AmigaDOS seems to offer some multi-user capability, this is
not the case. User and group ID are purely metadata that is returned
by the functions discussed in section~\ref{sec:fib}, they usually
ignore them. AmigaDOS has no concept of the current user of a
\emph{file system} and thus cannot decide whether a user is
privileged to access an object on a file system. In fact, all ROM
based file systems delivered with AmigaDOS do not support setting the
user or group ID.

\begin{verbatim}
success = SetOwner( name, owner_info )
D0                   D1       D2

BOOL SetOwner (STRPTR, LONG)
\end{verbatim}

This function sets the user and group ID of the \emph{file system}
object identified by the path in {\tt name} to the value {\tt
  owner\_info}. How exactly the {\tt owner\_info} is encoded is
\emph{file system} specific. Typically, the owner is encoded in the
topmost 16 bits, and the group in the least significant 16 bits.
\smallskip{}

This function returns a boolean success indicator which is non-zero on
success and $0$ on error. This function always sets {\tt IoErr()},
either to $0$ on success or to an error code otherwise.

\section{Working with Paths} \label{sec:workpaths}

The \emph{dos.library} contains a couple of support functions that
help working with paths, see also section~\ref{sec:paths}. What is
different from the remaining functions is that the paths are not
interpreted by the file system, but rather by the \emph{dos.library}
itself. This has several consequences: First, there is no 255
character limit as the path is never communicated into the \emph{file
  system} as it was stated in section~\ref{sec:pathlimit}. Second, as
the paths are constructed or interpreted by the library and not the
\emph{file system}, the syntax of the path is also that imposed by the
library.
\smallskip{}

That is, for these functions to work, the separator between component
must be the forwards slash ('{\tt /}') and the parent directory must
be indicated by an isolated single forward slash without a component
upfront. This implies, in particular, that the involved file systems
follow the conventions of AmigaDOS.

\subsection{Find the Path From a Lock} \label{sec:namefromlock}

The {\tt NameFromLock()}\mkey{NameFromLock()} function constructs a
path to the locked object, i.e. if the constructed path is used to
create a lock, it will refer to the same object.

\begin{verbatim}
success = NameFromLock(lock, buffer, len)
D0                      D1     D2    D3

BOOL NameFromLock(BPTR, STRPTR, LONG)
\end{verbatim}

This function constructs in {\tt buffer} an absolute path that
identifies the object locked by {\tt lock}. At most {\tt len} bytes
will be filled into {\tt buffer}, including {\tt NUL} termination of the
string. The created string is always {\tt NUL}-terminated, even if the
buffer is too short. However, in such a case the function returns~$0$,
and {\tt IoErr()}\key{IoErr()} is set to {\tt ERROR\_LINE\_TOO\_LONG}.
\smallskip{}

If the path cannot be constructed due to an error, {\tt success} is
also set to $0$ and {\tt IoErr()} is set to an error code. However, on
success, {\tt IoErr()} is not set consistently and cannot be depended
upon. Possible cases of failure are that the volume the locked object
is located on is currently not inserted in which case it will be
requested. The {\tt ZERO} lock is correctly interpreted, and resolves
into the string {\tt SYS:}. The {\tt lock} remains valid after the
call.

\subsection{Find the Path from a File Handle}

The {\tt NameFromFH()}\mkey{NameFromFH()} function constructs a path name
from a \emph{file handle}, i.e. it finds a path that is suitable to identify
the file identified by the passed in \emph{file handle}.

\begin{verbatim}
success = NameFromFH(fh, buffer, len)
D0                   D1    D2    D3

BOOL NameFromFH(BPTR, STRPTR, LONG)
\end{verbatim}

This function takes a \emph{file handle} in {\tt fh} and from that
constructs an absolute path of the opened file in the supplied {\tt buffer}
capable of storing {\tt len} bytes, including a terminating {\tt NUL} byte.
\smallskip{}

On success, the function returns a non-zero return code and sets
{\tt IoErr()}\key{IoErr()} to 0. On error, it returns~$0$ and sets
{\tt IoErr()} to an error code. In particular, if the supplied buffer
is not large enough, it is set to {\tt ERROR\_LINE\_TOO\_LONG}. Even in the
latter case, the created path is {\tt NUL} terminated, though not useful.

\subsection{Append a Component to a Path}

The {\tt AddPart()}\mkey{AddPart()} adds an absolute or relative path
to an existing path; the resulting path is constructed as if the input
path is a directory, and the attached (second) path identifies an object
relative to this given directory. The function handles special cases
such as the colon ('{\tt :}') and one or multiple leading slashes
('{\tt /}') correctly and are interpreted according to the rules
explained in section~\ref{sec:paths}: The colon identifies the root of
the volume, and a leading slash the parent directory, upon which the
trailing component of the input path is removed.

\begin{verbatim}
success = AddPart( dirname, filename, size )
D0                   D1        D2      D3

BOOL AddPart( STRPTR, STRPTR, ULONG )
\end{verbatim}

This function attaches to the existing path in {\tt dirname} another
path in {\tt filename}. The constructed path will overwrite the buffer
in {\tt dirname}, which is able to hold {\tt size} bytes, including a
terminating {\tt NUL} byte.
\smallskip{}

If the required buffer for the constructed path, including
termination, is larger than {\tt size} bytes, then the function
returns $0$ and {\tt IoErr()} is set to {\tt ERROR\_LINE\_TOO\_LONG},
and the input buffers are not altered. Otherwise, the function returns
non-zero, and {\tt IoErr()} is not altered.
\smallskip{}

This function does not interact with a \emph{file system} and does not
check whether the paths passed in correspond to accessible
objects. The output path is constructed purely based on the AmigaDOS
syntax of paths.

\subsection{Find the last Component of a Path}

The {\tt FilePart()}\mkey{FilePart()} function finds the last
component of a path; the function name is a bit misleading since the
last component does not necessarily correspond to a file, but could
also correspond to a directory once identified by a \emph{file
  system}. If there is only a single component in the path passed in,
this component is returned. If the path passed in terminates with at
least two slashes ('{\tt /}') indicating that the last component is at
least one level above, a pointer to the terminating slash is returned.

\begin{verbatim}
        fileptr = FilePart( path )
        D0                   D1

        STRPTR FilePart( STRPTR )
\end{verbatim}

This function returns in {\tt fileptr} a pointer to the last component
of the path passed in as {\tt path}, or a pointer to '{\tt /}' in case
the input path terminates with at least two slashes.
\smallskip{}

This function cannot fail, and does not touch {\tt IoErr()}.

\subsection{Find End of Next-to-Last Component in a Path}

The {\tt PathPart()}\mkey{PathPart()} identifies the end of the
next-to-last component in a path. That is, if a {\tt NUL} is injected
at the pointer returned by this function, the resulting string
starting at the passed in buffer corresponds to a path that
corresponds to the directory containing the last component of the
path. If the passed in path consists only of a single component, the
returned pointer is identical to the pointer passed in.

\begin{verbatim}
fileptr = PathPart( path )
D0                   D1

STRPTR PathPart( STRPTR )
\end{verbatim}

This function returns in {\tt fileptr} a pointer to the end of the
next-to-last component of the {\tt path} passed in. This function
cannot fail and does not alter {\tt IoErr()}.
\smallskip{}

The only difference between this function and {\tt
  FilePath()}\key{FilePart()} is that the latter advanced over a
potential trailing slash. That is, if the last character of the input
path of {\tt PathPart()} would be a slash, then {\tt PathPart()} would
return a pointer to this slash, but {\tt FilePart()} would advance
beyond this slash. That is, the ``file part'' of a path that
explicitly indicates a directory is empty, though the ``path part'' is
the same path without the trailing slash.

\subsection{Extract a Component From a Path}

The {\tt SplitName()}\mkey{SplitName()} function extracts a component
starting at a given offset from a path and delivers the component in a
buffer. It also returns a new position at which to continue parsing a path.
By iteratively calling {\tt SplitName()}, a path can be resolved directory
by directory, walking the \emph{file system} tree from top to bottom.

\begin{verbatim}
newpos = SplitName(name, separator, buf, oldpos, size)
D0                  D1      D2      D3     D4     D5

WORD SplitName(STRPTR, UBYTE, STRPTR, WORD, LONG)
\end{verbatim}

This function scans a path as given by {\tt name} starting from position
{\tt oldpos}. It copies all characters starting from this position into the
buffer {\tt buf} which is {\tt size} bytes large, terminating either at the
end of the path, or at {\tt separator}, or when {\tt buf} runs full. The
component string constructed in {\tt buf} is {\tt NUL}-terminated in either
case. If the provided separator is found, the separator is not copied into
{\tt buf}. 
\smallskip{}

If no separator is found, the function returns~$-1$ as {\tt newpos}
indicating that the entire path has been scanned. Otherwise, it returns the
offset into {\tt name} at which the next component starts, i.e. the offset
behind the found separator. These return values are also valid even in case
the found component was too large to fit into {\tt buf} and it had to be
truncated.
\smallskip{}

This function does not set error codes, even in case {\tt buf} was too
small to hold the copied component.
\smallskip{}

The intended purpose of this function is to walk a path component by
component, identifying the names of the directories as scanning
proceeds. That is, if result code {\tt newpos} is not negative, it should be
passed back into this function as {\tt oldpos} for a subsequent scan which
then extracts the next component of the path. The main user of this function
are therefore \emph{file systems} when locating an object in the file system
tree. For most AmigaDOS \emph{file systems} the sparator is therefore the
forwards slash (``{\tt /}'').

\section{Links} \label{sec:links}

\emph{Links} are tools to escape the tree-like hierarchy of
directories, sub-directories and files. A \emph{link} mirrors one
object of a file system to another location such that if the object is
changed using the path of one location, the changes are reflected in
another location. Put differently, creating a link is like copying an
object except that copy and original are always in sync. The storage
for the payload data of a file is only required once, the link just
points to the same data as the original directory entry. The same goes
for links between directories: Whenever a new entry is made in one
directory, the change also appears in the other.
\smallskip{}

AmigaDOS supports two (or, actually, three) types of links:
\emph{Hard-links} and \emph{Soft-links}. The \emph{RAM-Handler}
supports a third type that will be discussed below. \emph{Hard-links}
establish the relation between two \emph{file-system} objects on the
same volume at the level of the file system. That is, whenever a link
is accessed, the file system resolves the link, transparent to its
user.  While for the Amiga \emph{Fast File System} and the
\emph{RAM-Handler} a \emph{hard-link} is a distinct directory entry
type, some file systems do not distinguish between the original object
and a \emph{hard-link} to it. For such file systems, the same payload
data is just referenced by two directory entries. If the larger of a
link is deleted on the \emph{Fast File System} or the
\emph{RAM-Handler}, and (at least one) link to the object still
exists, then (one of) the link(s) takes over and becomes the object
itself. For other file systems, only a file system internal reference
counter is decreased, and the payload data is removed only if this
counter becomes zero.
\smallskip{}

\emph{Soft-Links} work differently and can also be established between
two different \emph{file systems}, or between two different
volumes. Here, the \emph{soft-link} is a type of its own that contains
the path of the referenced object. Unlike hard-links, soft-links are
resolved through an interaction of the file-system and the
\emph{dos.library}.
\smallskip{}

The \emph{dos.library} supports \emph{Soft-Links} through the
functions listed in Table~\ref{table:softenabled}:

\begin{rkrmtable}{Softlink aware functions} \label{table:softenabled}
{\bf Function} & {\bf Purpose}\\ \hline \hline
{\tt Open()} & Open a file\\ \hline
{\tt Lock()} & Obtain access rights to an object\\ \hline
{\tt CreateDir()} & Create a directory\\ \hline
{\tt SetProtection()} & Modify protection bits\\ \hline
{\tt SetFileDate()} & Set the modification date of a file\\ \hline
{\tt DeleteFile()} & Delete an object on a file system\\ \hline
{\tt SetComment()} & Modify object comment\\ \hline
{\tt MakeLink()} & Create a link to an object\\ \hline
{\tt SetOwner()} & Set User and Group ID\\ \hline
\end{rkrmtable}

All of the above functions take a path of its first argument. If the path
consists of multiple components, i.e. identifies an object in a nested
directory, and one of the intermediate components are \emph{soft-links}, the
\emph{dos.library} will automatically resolve such an intermediate link and
construct internally a resolved path to the link destination. Whether a
soft-link at the last component is resolved is typically \emph{file system}
and function dependent. For example, {\tt Open()} will always resolve
\emph{soft-links}, but {\tt Lock()} or {\tt SetProtection()} may not and may
instead affect the link, not the target object. {\tt DeleteFile()} will
never resolve a link at the final component of the path, and will therefore
delete the link, not the object linked to.
\smallskip{}

Note that {\tt Rename()}\key{Rename()} is currently not on the list
supporting soft-links as part of the path to the object to be renamed, or as
part of the target path.
\smallskip{}

If the target of a \emph{soft-link} is deleted (and not the link
itself), a link pointing to it becomes invalid, even though remains in the
\emph{file system}. Any attempt to resolve the link then, obviously,
fails. AmigaDOS does not attempt to identify such invalid links. The
same cannot happen for \emph{hard-links}.
\smallskip{}

Soft-link resolution works as follows: Functions of the \emph{dos.library}
create a packet of a type that corresponds to the called function; these
packets are specified in chapter~\ref{sec:handlers}. If the handler
addressed by the packet determines that the path provided by the user
contains a soft-link, it will respond with failure and the error code
{\tt ERROR\_IS\_SOFT\_LINK}.
\smallskip{}

The \emph{dos.library} then requests the handler to resolve the softlink via
the \emph{ReadLink()}\key{ReadLink()} function which sends a packet of type
{\tt ACTION\_READ\_LINK} back to the handler. The handler then computes from
the original path and the target of the soft-link an updated path and
provides it back to the \emph{dos.library}, which then attempts again to
perform the requested function. Details on how a file system merges a path
and a softlink is provided in section~\ref{sec:actionreadlink}. The
additional round-trip is unfortunately necessary as the handler the
soft-link points to may be a different handler than the one the soft-link is
stored on.
\smallskip{}

This process continues until either the requested action could be performed,
or a maximum number of attempts failed. Currently, the \emph{dos.library}
will perform at most~15 tries to resolve a soft-link until it finally fails.
\medskip{}

Finally, the \emph{RAM-Handler} supports a special type of
\emph{hard-links} that goes across volumes. These \emph{external
  links} copy the linked object on a read-access into the RAM disk,
i.e. the \emph{RAM-Handler} implements a \emph{copy on access}. This
feature is used for the {\tt ENV:} assign containing all active system
settings. This assign points to a directory in the RAM disk which
itself is externally linked to {\tt ENVARC:}. Thus, whenever a program
attempts to access its settings --- such as the preferences programs
--- the \emph{RAM-Handler} automatically copies the data from {\tt
  ENVARC:} to {\tt ENV:}, avoiding a manual copy and also saving RAM
space for settings that are currently not accessed and thus unused.
\medskip{}

The {\tt FileInfoBlock} introduced in section~\ref{sec:fib} identifies
links through the {\tt fib\_DirEntryType} member. As seen from
table~\ref{table:direntrytypes}, \emph{hard-links} to files are
indicated by {\tt ST\_LINKFILE} and \emph{hard-links} to directories
by {\tt ST\_LINKDIR}. Note, however, that not all file systems are
able to distinguish \emph{hard-links} from regular directory entries,
so this feature cannot be depended upon. In particular,
\emph{external links} of the \emph{RAM-Handler} cannot be identified
by any particular value of the {\tt fib\_DirEntryType}.
\smallskip{}

Table~\ref{table:direntrytypes} also provides the {\tt
  fib\_DirEntryType} for \emph{soft-links}, namely {\tt
  ST\_SOFTLINK}. As the target of a \emph{soft-link} may not under
control of the \emph{file system}, it cannot know whether the link
target is a file or a directory (or maybe another link), and therefore
a single type is sufficient to identify them.

\subsection{Creating Links}

The {\tt MakeLink()}\mkey{MakeLink()} function creates a
\emph{hard-link} or a \emph{soft-link} to an existing object on a
\emph{file system}.

\begin{verbatim}
success = MakeLink( name, dest, soft )
D0                   D1    D2    D3

BOOL MakeLink( STRPTR, LONG, LONG )
\end{verbatim}

This function creates a new link at the path {\tt name} of the type
given by {\tt soft}. The destination the link points to is given by
{\tt dest}.
\smallskip{}

The third argument, {\tt soft}, identifies the type of the link to be
created. It shall be taken from table~\ref{table:linktypes}, defined in
{\tt dos/dos.h}:

\begin{rkrmtable}{\tt Link Types} \label{table:linktypes}
{\bf Link Types} & {\bf Description}\\ \hline \hline
\tt LINK\_HARD & Hard link, or external link \\ \hline
\tt LINK\_SOFT & Soft link \\ \hline
\end{rkrmtable}

If {\tt soft} is {\tt LINK\_HARD}, {\tt dest} is a \emph{lock} represented
by {\tt BPTR}. For most \emph{file systems}, {\tt dest} shall be on
the same volume as the one identified by the path in {\tt name}. The
currently only exception is the \emph{RAM-Handler} for which the
destination \emph{lock} may be on a different volume. In such a case,
an \emph{external link} is created. While the target object will be
created, it may look initially like an empty file or an empty
directory, depending on the type of the link destination. Its contents
is copied, potentially recursively creating directories, by copying
the contents of the link destination into the link, or to a file or
directory within the link. Thus, the link becomes a mirror of the link
destination whenever an object within the link or the link itself is
accessed.
\smallskip{}

If {\tt soft} is {\tt LINK\_SOFT}, {\tt dest} is a {\tt const UBYTE *} that
shall be casted to a {\tt LONG}. Then, this function creates a
\emph{soft-link} that is relative to the path of the link, i.e.  {\tt
  name}. For details on \emph{soft-link} resolution, see
section~\ref{sec:readlink}.
\smallskip{}

This function returns in {\tt success} non-zero if creation of the
lock succeeded, or $0$ in case of failure. In either case,
{\tt IoErr()} is set to an error code on failure, or $0$ on success.

\subsection{Resolving Soft-Links} \label{sec:readlink}

The {\tt ReadLink()}\mkey{ReadLink()} function locates the destination
of a \emph{soft-link} and constructs from the path and directory of
the link a new path that identifies the target of the link. A typical
use case for this function is if a \emph{dos.library} function returns
with the error {\tt ERROR\_IS\_SOFT\_LINK}, indicating that the
\emph{file system} needs help from a higher layer to grant access to
the object. You then typically retry the access to the object with the
path constructed by this function. Note well that this path may be
that of yet another \emph{soft-link}, requiring recursive resolution
of the link. To avoid endless recursion, this loop should be aborted
after a maximum number of attempts, then generating an error such as
{\tt ERROR\_TOO\_MANY\_LEVELS}. A suggested maximum level of nested
\emph{soft-links}, also used by the \emph{dos.library}, is 15 links.
\smallskip{}

Note, however, that such steps would not be necessary for the
functions listed in table~\ref{table:softenabled} as they already
perform such steps internally.

\begin{verbatim}
success = ReadLink( port, lock, path, buffer, size)
D0                   D1    D2    D3     D4     D5

BOOL ReadLink( struct MsgPort *, BPTR, STRPTR, STRPTR, ULONG)
\end{verbatim}

This function creates in {\tt buffer} of {\tt size} bytes a path to
the target of a \emph{soft-link} contained in the input {\tt path}
relative to the directory represented by {\tt lock}. Typically, {\tt
  path} is the path given to some object you attempted to access, and
{\tt lock} is the \emph{lock} as given by the current
directory\key{CurrentDir()} to which the path is relative. The output
path constructed in {\tt buffer} is then an updated path relative to
the same directory, i.e. relative to {\tt lock}.
\smallskip{}

The {\tt port} is the message port of the file system that is queried
to resolve the \emph{soft-link}; this port should be obtained from
{\tt GetDeviceProc()}\key{GetDeviceProc()}, see
section~\ref{sec:getdevproc}. For relative paths, this port is
identical to the one in the {\tt fl\_Task} member of the {\tt FileLock}
structure representing {\tt lock}, see section~\ref{sec:filelock}.
\smallskip{}

If {\tt size} is too small to hold the adjusted path, the function
returns $0$ and sets {\tt IoErr()} to {\tt ERROR\_LINE\_TOO\_LONG}.
\smallskip{}

The function returns non-zero in case of success, or $0$ in case of
error. In either case, {\tt IoErr()}\key{IoErr()} is set to ether $0$
on success, or an error code otherwise.

\section{Notification Requests} \label{sec:notification}

Notification requests allow programs to monitor file or directory
changes. If so, either a signal or a message can be send to a specific
task, informing it on the modification. If the notification request is
issued on a file, any attempt to modify the contents of the file will
trigger the notification request. However, in order to avoid too many
request to be send out, the triggering the request is delayed until
after the corresponding file is closed.
\smallskip{}

If issued on a directory, attempts to add or remove files or links
will trigger the request, as well as renaming files. Whether changes
of metadata such as protection bits or comments are considered
modifications is not clearly defined and not all versions of all
AmigaDOS file systems handle it consistently. The most recent version
of AmigaDOS will consider such modifications sufficient to trigger a
notification.
\smallskip{}

A typical application of notification requests is the {\tt IPrefs}
program which uses such requests to monitor changes of the preferences
files. If it detects any changes of the preferences, it reloads the
contents of the files and re-installs the preferences into the
components it serves, most importantly {\tt intuition}.

\subsection{Request Notification on File or Directory Changes} \label{sec:startnotify}

The {\tt StartNotify()}\mkey{StartNotify()} function starts monitoring
a file or directory for changes, and if such modifications are found,
a signal or a message is send to a task.

\begin{verbatim}
success = StartNotify(notifystructure)
D0                          D1

BOOL StartNotify(struct NotifyRequest *)
\end{verbatim}

This function starts a notification request as described by the {\tt
  notifystructure} argument. This structure shall be initialized by
the caller, and is then enqueued in the file system until the
notification request is terminated by {\tt
  EndNotify()}\key{EndNotify()}. Once issued, the request shall not be
touched anymore as the \emph{file system} may access it any time. As
some field require zero-initialization at this point, it is advisable
to allocate it through exec with the {\tt MEMF\_CLEAR} flag set.
\smallskip{}

The {\tt NotifyRequest} structure is defined in {\tt dos/notify.h} and reads as follows:
\mkey{NotifyRequest}
\begin{verbatim}
struct NotifyRequest {
    UBYTE *nr_Name;
    UBYTE *nr_FullName;
    ULONG nr_UserData;
    ULONG nr_Flags;
    union {
        struct {
            struct MsgPort *nr_Port;
        } nr_Msg;

        struct {
           struct Task *nr_Task;
           UBYTE nr_SignalNum;
           UBYTE nr_pad[3];
        } nr_Signal;
    } nr_stuff;
    ULONG nr_Reserved[4];
    /* internal use by handlers */
    ULONG nr_MsgCount;            
    struct MsgPort *nr_Handler;
};
\end{verbatim}

The elements of this structure shall be initialized as follows:
\smallskip{}

{\tt nr\_Name}: The path to the object to be monitored, relative to
the current directory. While it seems plausible that issuing a
notification request on a not yet existing object will trigger a
notification once such an object is created, this type of notification
is currently not supported by AmigaDOS.

{\tt nr\_FullName} is initialized by the file system and shall be left alone
by the caller. The \emph{dos.library} uses it to store the full path of the
object to monitor.

{\tt nr\_UserData} is free for use by the calling application. It may
be used to distinguish multiple notification requests that have been
issued in parallel.

{\tt nr\_Flags} identifies the activity that is performed when a
change has been detected by a \emph{file system}. Currently, the
following flags are defined in {\tt dos/notify.h}:

\begin{rkrmtable}{Notification Flags} \label{table:notifyflags}
{\bf Flag} & {\bf Purpose}\\ \hline \hline
{\tt NRF\_SEND\_MESSAGE} & Send a message on a file system change \\ \hline
{\tt NRF\_SEND\_SIGNAL} & Set a signal on a change \\ \hline
{\tt NRF\_WAIT\_REPLY} & Wait for a reply before notifying again \\ \hline
{\tt NRF\_NOTIFY\_INITIAL} & Notify immediately when queuing the request \\ \hline
\end{rkrmtable}

All other bits are currently reserved. In specific, bits 16 upwards
are free for the file system to use.
\smallskip{}

The flags {\tt NRF\_SEND\_MESSAGE} and {\tt NRF\_SEND\_SIGNAL} are
mutually exclusive. Exactly one of the two shall be included in the
request to identify the activity that is performed when the monitored
object changes.
\smallskip{}

{\tt NRF\_WAIT\_REPLY} indicates to the file system that it should not
continue to send a notification message while it has already send one
message before that has not yet been replied. Thus, setting this flag
prevents notification requests to pile up at the recipient. However,
if one or multiple changes were detected while the first request was
triggered but not yet responded, replying to this first notification
message will immediately trigger a \emph{single} subsequent request.
\smallskip{}

{\tt NRF\_NOTIFY\_INITIAL} will instruct the file system to trigger a
notification message or signal immediately after the request has been
received. This allows applications to roll both the initial action and
the response of the notification into a single function --- for
example, for reading or re-reading a preferences file.
\medskip{}

{\tt nr\_Port} is only used if the {\tt NRF\_SEND\_MESSAGE} flag is
set in {\tt nr\_Flags}. It points to a {\tt MsgPort} structure to
which a {\tt NotifyMessage} is send when a change has been
detected. This structure is specified at the end of this section.
\smallskip{}

{\tt nr\_Task} and {\tt nr\_SignalNum} are only used if the {\tt
  NRF\_SEND\_SIGNAL} flag is set in {\tt nr\_Flags}. {\tt nr\_Task} is
a pointer to the {\tt Task} that will be informed, and {\tt
  nr\_SignalNum} the bit number of the signal that is set. It is not a
bit mask. Clearly, {\tt NRF\_WAIT\_REPLY} does not work in combination
with signal bits.
\smallskip{}

{\tt nr\_Pad} are only present for alignment and shall be left alone.
\smallskip{}

{\tt nr\_Reserved} shall be zero-initialized by the caller and are
reserved for future extensions.
\smallskip{}

{\tt nr\_MsgCount} shall not be touched by the caller and reserved
purely for the purpose of the \emph{file system}. It is there used to
count the number of messages that have been send out to the client,
but have not yet been responded. The client, i.e. the caller, shall
not interpret or modify this member.
\smallskip{}

{\tt nr\_Handler} shall neither be touched by the caller; it is used
by AmigaDOS to store the {\tt MsgPort} of the \emph{file system}
responsible for this notification request, and in particular, which to
contact for ending a notification request.
\medskip{}

If {\tt NRF\_SEND\_MESSAGE} is set, then the \emph{file system} sends
a {\tt NotifyMessage} to {\tt nr\_Port} upon detection of a change;
this structure is also defined in {\tt dos/notify.h} and looks as
follows:
\mkey{NotifyMessage}
\begin{verbatim}
struct NotifyMessage {
    struct Message nm_ExecMessage;
    ULONG  nm_Class;
    UWORD  nm_Code;
    struct NotifyRequest *nm_NReq;
    ULONG  nm_DoNotTouch;
    ULONG  nm_DoNotTouch2;
};
\end{verbatim}

{\tt nm\_ExecMessage} is a standard {\tt exec} message as documented in {\tt exec/ports.h}.
\smallskip{}

{\tt nm\_Class} is always set to {\tt NOTIFY\_CLASS}, also defined in
{\tt dos/notify.h}, to identify this message as notification.
\smallskip{}

{\tt nm\_Code} is always set to {\tt NOTIFY\_CODE}, again defined in
{\tt dos/notify.h}. This again may be used to identify notifications.
\smallskip{}

{\tt nm\_NReq} is a pointer to the {\tt NotifyRequest} through which
this message was triggered. This may allow clients to identify the
source of the request and by that the object that has been changed.
\smallskip{}

{\tt nm\_DoNotTouch} and {\tt nm\_DoNotTouch2} are strictly for use by
the \emph{file system} and shall not be touched or interpreted by the
caller or the client.
\medskip{}

This function returns a boolean success indicator. It returns a
non-zero result code on success and then sets {\tt
  IoErr()}\key{IoErr()} to~0. On error, the function returns~0 and
sets {\tt IoErr()} to a non-zero error code.

\subsection{Canceling a Notification Request}

The {\tt EndNotify()}\mkey{EndNotify()} function cancels an issued
notification request.

\begin{verbatim}
EndNotify(notifystructure)
		D1

void EndNotify(struct NotifyRequest *)
\end{verbatim}

This function cancels the notification request identified by {\tt
  notifystructure}. This function shall only be called on notification
requests that have been successfully issued by {\tt StartNotify()}. If
caller did not yet reply all {\tt NotifyMessage} messages and some are
still piled up in the {\tt nr\_Port}, the \emph{file system} will
manually dequeue them from this port.
\smallskip{}

Afterwards, the {\tt notifystructure} is again available for the
caller, for example to either release its memory, or to start another
notification request.

\chapter{File System Support Functions} \label{sec:filesysmisc}

Functions in this section act on a \emph{file system} as a whole;
thus, they do not need a file or a lock to operate on, but modify the
file system globally.

\subsection{Adjusting File System Buffers} \label{sec:addbuffers}

The {\tt AddBuffers()}\mkey{AddBuffers()} function increases or
reduces the number of buffers of a file system.

\begin{verbatim}
success = AddBuffers(filesystem, number)
D0		       D1          D2

BOOL AddBuffers(STRPTR, LONG)
\end{verbatim}

This function adds {\tt number} buffers to the file system whose name
is given by {\tt filesystem}. This name consists of a filename,
volume, or assign on the \emph{file system} whose buffer count shall
be modified, see also {\tt GetDeviceProc()}\key{GetDeviceProc()} in
section~\ref{sec:getdeviceproc} how a file system is located.
\smallskip{}

The {\tt number} argument may be both positive --- for adding buffers
to the file system --- or negative, to reduce the number of buffers.
The purpose of these buffers is file-system dependent. The Fast File
System in ROM uses it to buffer administrative information such as
directory contents, but also blocks that describe the location of file
content on the disk; thus adding more buffers can help to improve the
performance of random-access into the file with {\tt Seek()}\key{Seek()}.
\smallskip{}

A third purpose of the buffers is to store input and output data of
{\tt Read()}\key{Read()} or {\tt Write()}\key{Write()} if the
operation is not aligned to block boundaries or if the source or
target buffer is considered unsuitable for direct transfer to the
underlying hardware exec device.
\medskip{}

This function returns a non-zero result on success and~0 on
failure. In first case, it sets {\tt IoErr()} to~0, otherwise it is
set to an error code. Some file systems return the current number of
buffers allocated; callers should thus be prepared that the return
code is not equal to {\tt DOSTRUE} to indicate success.

\subsection{Change the Name of a Volume}

The {\tt Relabel()} function changes the name of a volume a file
system operates on.

\begin{verbatim}
success = Relabel(volumename,name)
D0                    D1      D2

BOOL Relabel(STRPTR,STRPTR)
\end{verbatim}

This function relables the volume that resides on the \emph{file
  system} corresponding to the {\tt volumename} path. This path is
resolved through {\tt GetDeviceProc()}\key{GetDeviceProc()} and thus
may be a relative or absolute path, the device or the volume name. As
{\tt filesystem} is interpreted as a path, a device or volume name
passed in shall include a colon (``{\tt :}'') as it would be otherwise
interpreted as a path relative to the current directory.
\smallskip{}

The volume name of the medium or partition is then changed to {\tt
  name}. Unlike the first argument, {\tt name} shall \emph{not}
contain a colon (``{\tt :}'') nor a slash (``{\tt /}'').
\smallskip{}

This function returns a non-zero result code for success or~0 for an
error. In the first case, it sets {\tt IoErr()}\key{IoErr()} to~0, in
the latter case to an error code.

\subsection{Initializing a File System}

The {\tt Format()} function initializes a complete file system,
writing administration information on the file system that corresponds
to an empty medium. Thus, this function erases all information stored
in it.

\begin{verbatim}
success = Format(filesystem, volumename, dostype)
D0                   D1          D2         D3

BOOL Format(STRPTR, STRPTR, ULONG)
\end{verbatim}

This function erases all information on the medium or partition
identified by {\tt filesystem}, which is interpreted as a path. Thus,
it may be a device or volume name, which shall then be terminated by a
colon (``{\tt :}''). However, all other path names also work; however,
if they do not include a colon, the argument is interpreted as a path
name relative to the current directory, and thus will initialize the
file system corresponding to it. This is probably not desirable.
\smallskip{}

To block processes from accessing information on the file system while
it is initializing, it should be inhibited upfront, e.g by {\tt
  Inhibit(filesystem,DOSTRUE)} or lower level direct communication to
the handler, see section~\ref{sec:action_inhibit}.  Initializing is
the only operation file systems are able to perform while being
inhibited.
\smallskip{}

The {\tt Format()} function \emph{does not} attempt a low-level
initialization of the corresponding medium; that is, it does not
attempt to low-level format it on the physical layer as required when
a floppy disk shall be prepared for initial use. This step needs to be
performed manually by first blocking access of the file system to the
floppy through {\tt Inhibit()}, then initializing the physical
layer through the exec device driver upfront, e.g. by the command {\tt
  TD\_FORMAT}, and then finally by calling this function.
\medskip{}

The volume name of the medium or partition is initialized to {\tt
  volumename}, which \emph{shall not} contain a colon (``{\tt :}'')
nor a slash (``{\tt /}''). Note that not all file systems support
volume names. In such cases, this argument is ignored.
\smallskip{}

The {\tt dostype} defines the flavour of file system created on the
device if the file system allows multiple variations. The variations
the Fast File System supports along with other file systems are listed in
table~\ref{table:ffsflavours}. This corresponds to the {\tt DOSTYPE}
in the mount list. File systems may also ignore this argument if they
only support a single flavour.

Unfortunately, AmigaDOS does not provide an easy way to access the flavours
supported by a file system. The {\tt Format} command of the workbench offers
the types listed in the first half of table~\ref{table:ffsflavours} if the
mount entry of the file system indicates that it is the FFS, and otherwise
does not offer any choices and just copies the {\tt dostype} from the {\tt
  de\_DosType} of the {\tt DosEnvec} structure, see also section~\ref{mountlist}.
\smallskip{}

After initializing the \emph{file system}, use {\tt
  Inhibit(filesystem,DOSFALSE)} or the corresponding lower level
packet {\tt ACTION\_INHIBIT} to grant the file system access to the
partition or medium again. As the volume name can be different and
\emph{locks} or \emph{file handles} on the original file system
clearly became invalid, it is advisable to pass the \emph{device name}
of the \emph{file system} to {\tt Inhibit()} if this call is used, see
also sections~\ref{sec:deviceoverview} and~\ref{sec:inhibit}.
\medskip{}

This function returns a boolean success indicator that is non-zero on
success or~0 on error. In either case, {\tt IoErr()} is set to~0 on
success or an error code on failure.

\subsection{Inhibiting a File System} \label{sec:inhibit}

The {\tt Inhibit()}\mkey{Inhibit()} function disables or enables
access of the \emph{file system} to the underlying exec device
driver. Typical application for this function are disk editors or file
system salvage tools that require exclusive access to the file system
structure.

\begin{verbatim}
success = Inhibit(filesystem, flag)
D0                    D1       D2

BOOL Inhibit(STRPTR,LONG)
\end{verbatim}

This call controls whether the file system identified by the path name
given as {\tt filesystem} is allowed to access the medium or partition
it usually operates on. The {\tt filesystem} argument is interpreted
through {\tt GetDeviceProc()}\key{GetDeviceProc()} to find the process
responsible for the medium. That is, the function resolves relative
and absolute paths, device and volume names, and even assigns. As {\tt
  filesystem} is interpreted as a path, a device or volume name passed
in shall include a colon (``{\tt :}'') as it would be otherwise
interpreted as a path relative to the current directory.
\smallskip{}

The {\tt flag} argument controls whether access to the medium is
allowed or disallowed. If {\tt flag} is set to {\tt DOSTRUE}, access
is inhibited and the \emph{file system} stops accessing the partition
or volume. It also sets {\tt id\_DiskType} to the four-character code
{\tt 'BUSY'}, which will be interpreted by the workbench to ghost the
corresponding drive icon. Application programs are then allowed to
access the exec device driver directly to access or modify blocks
within the partition managed by the inhibited \emph{file system}.
\smallskip{}

If {\tt flag} is set to {\tt DOSFALSE}, access to the medium is
allowed again. The \emph{file system} then performs a consistency
check of the file system structure of the disk, i.e. validates it.
\smallskip{}

This function returns a non-zero result code for success and then sets
{\tt IoErr()}\key{IoErr()} to~0. On error, it returns~0 and provides an
error code in {\tt IoErr()}.

\chapter{Administration of Volumes, Devices and Assigns} \label{sec:devicelist}

The \emph{dos.library} is just a layer of AmigaDOS that provides a
common API for input/output operations; these operations are not
implemented by the library itself, but forwarded to
\emph{file systems} or \emph{handlers}. This forwarding is based on the
exec \emph{message} and \emph{message port} system, and to this
end, the {\tt FileLock} structure and the {\tt FileHandle} structure
contain a pointer to a {\tt MsgPort}.
\smallskip{}

However, the \emph{dos.library} also needs to obtain this port from
somewhere; for relative paths (see section~\ref{sec:paths}), the
current directory\key{CurrentDir()} (see section~\ref{sec:currentdir})
provides it. For absolute paths, i.e. paths that contain a colon
('{\tt :}'), the string upfront the colon identifies handler, directly
or indirectly. If this string is empty, i.e. the path starts with a
colon, it is again the handler of the current directory that is
contacted, but otherwise, the dos searches the \emph{device list} to
find a suitable \emph{message port}. This algorithm is also available
as a function, namely {\tt GetDeviceProc()}\key{GetDeviceProc()},
which is documented in section~\ref{sec:getdeviceproc}.
\smallskip{}

Internally, the \emph{dos.library} keeps the relation between such
names and the corresponding ports in the {\tt DosList} structure. Such
a structure is also created when \emph{mounting} a handler,
i.e. advertizing the handler to the system, or when creating an
\emph{Assign}, see section~\ref{sec:assignlist}, or when inserting a
disk into a drive, thus making a particular \emph{volume} available to
the system (see also~\ref{sec:volumelist}). Only the names from
table~\ref{table:specialdevices} in~\ref{sec:deviceoverview} are
special cases and hard-coded into the~\emph{dos.library} without
requiring an entry in the \emph{device list} in the form of a
{\tt DosList} structure.
\smallskip{}

This structure, defined in {\tt dos/dosextens.h} reads as follows:

\mkey{DosList}
\begin{verbatim}
struct DosList {
    BPTR                dol_Next;
    LONG                dol_Type;
    struct MsgPort     *dol_Task;
    BPTR                dol_Lock;
    union {
      struct {
        BSTR    dol_Handler; 
        LONG    dol_StackSize;
        LONG    dol_Priority;  
        ULONG   dol_Startup;    
        BPTR    dol_SegList;    
        BPTR    dol_GlobVec;    
      } dol_handler;

      struct {
        struct DateStamp        dol_VolumeDate;
        BPTR                    dol_LockList;  
        LONG                    dol_DiskType;  
      } dol_volume;

      struct {
        UBYTE   *dol_AssignName;     
        struct AssignList *dol_List;
      } dol_assign;

    } dol_misc;

    BSTR                dol_Name;
};
\end{verbatim}

and its members have the following purpose:
\smallskip{}

{\tt dol\_Next} is a \emph{BPTR} to the corresponding next entry in a
singly linked list of {\tt DosList} structures. However, this list
should not be walked manually, but instead {\tt FindDosEntry()}\key{FindDosEntry()} should be used for
iterating through this list.
\smallskip{}

{\tt dol\_Type} identifies the type of the entry, and by that also the
layout of the structure, i.e. which members of the unions are
used. The following types are defined in {\tt dos/dosextens.h}:

\begin{rkrmtable}{\emph{DosList} Entry Types} \label{table:doslisttypes}
{\tt \bf dol\_Type} & {\bf Description}\\ \hline \hline
{\tt DLT\_DEVICE} & A \emph{file system} or \emph{handler}, see~\ref{sec:deviceoverview}\\ \hline
{\tt DLT\_DIRECTORY} & A regular assign, see~\ref{sec:assignlist}\\ \hline
{\tt DLT\_VOLUME} & A volume, see~\ref{sec:volumelist}\\ \hline
{\tt DLT\_LATE} & A late binding assign, see~\ref{sec:assignlist}\\ \hline
{\tt DLT\_NONBINDING} & A non-binding assign, see~\ref{sec:assignlist}\\ \hline
\end{rkrmtable}

{\tt dol\_Task} is the \emph{MsgPort} of the handler to contact for
the particular \emph{handler}, \emph{assign} or \emph{volume}. It may
be {\tt NULL} if the \emph{handler} is not started, or a new handler
process is supposed to be started for each file opened. This is, for
example, the case for the console which requires a process for each
window it handles. \emph{File systems} usually provide their port here
such that the same process is used for all objects on the
volume. \emph{Volumes} keep here the \emph{MsgPort} of the \emph{file
  system} that operates the volume, but it to {\tt NULL} in case the
volume goes away, e.g. is ejected. For \emph{regular assigns}, this is
also the pointer to the \emph{MsgPort} of the \emph{file system} the
assign binds to; in case the assign is a \emph{multi-assign}, this is
the \emph{MsgPort} of the first directory bound to. All additional
ports are part of the {\tt AssignList}. For \emph{late assigns} this
member is initially {\tt NULL}, but will be filled in as soon as the
assign in bound to a particular directory, and then becomes the
pointer to the \emph{MsgPort} of the handler the assign is bound
to. Finally, for \emph{non-binding assigns} this member always stays
{\tt NULL}.
\smallskip{}

{\tt dol\_Lock} is only used for \emph{assigns}, and only if it is
bound to a particular directory. That is, the member remains
{\tt ZERO} for \emph{non-binding assigns} and is initially {\tt ZERO} for
\emph{late assigns}. For all other types, this member stays {\tt ZERO}.
\smallskip{}

{\tt dol\_Name} is a \emph{BPTR} to a \emph{BSTR} is the name under
which the \emph{handler}, \emph{volume} or \emph{assign} is
accessed. That is, this string corresponds to the path component
upfront the colon. As a courtesy to C and assembler functions,
AmigaDOS ensures that this string is {\tt NUL} terminated, i.e.
{\tt dol\_Name + 1} is a regular C string whose length is available in
{\tt dol\_Name[0]}.
\medskip{}

The members within {\tt dol\_handler} are used by \emph{handlers} and
\emph{file systems}, i.e. if {\tt dol\_Type} is {\tt DLT\_DEVICE}.
\smallskip{}

{\tt dol\_Handler} is a \emph{BPTR} to a \emph{BSTR} containing the
file name from which the \emph{handler} or \emph{file system} is
loaded from. It corresponds to the {\tt Handler}, {\tt FileSystem} and
{\tt EHandler} fields of the mount list. They all deposit the file
name here.
\smallskip{}

{\tt dol\_StackSize} specifies the size of the stack for creating the
\emph{handler} or \emph{file system} process. Interestingly, the unit
of the stack size depends on the {\tt dol\_GlobVec} entry. If {\tt
  dol\_GlobVec} is negative indicating a C or assembler handler, {\tt
  dol\_StackSize} is in bytes. Otherwise, that is, for BCPL handlers,
it is in 32-bit long words. This member corresponds to the {\tt
  Stacksize} entry of the mount list.
\smallskip{}

{\tt dol\_Priority} is priority of the handler process. Even though it
is a {\tt LONG}, it shall be a number between $-128$ and $127$ because
priorities of the exec task scheduler are {\tt BYTE}s. For all
practical purposes, the priority should be a value between $0$ and
$19$. It corresponds to the {\tt Priority} entry of the mount list.
\smallskip{}

{\tt dol\_Startup} is a handler-specific startup value that is used to
commumicate a configuration to the handler during startup. While this value
may be whatever the handler requires, the {\tt mount} command either
deposits here a small integer, or a pointer to the {\tt FileSysStartupMsg}
structure defined in {\tt dos/filehandler.h}. Section~\ref{sec:handler}
provides more details on mounting handlers and how the startup mechanism
works. Unfortunately, it is hard to interpret {\tt dol\_Startup}
correctly. One way to set this member is to set {\tt Startup} in the mount
list, see~\ref{sec:filesysstartup} for details.
\smallskip{}

{\tt dol\_SegList} is a \emph{BPTR} to the chained segment list of the
handler if it is loaded. For disk-based handlers, this member is
initially {\tt ZERO}. When a program attempts to access a file on the
handler, the \emph{dos.library} first checks whether this field is
{\tt ZERO}, and if so, attempts to find a segment, i.e. a binary, for
the handler. If the {\tt FORCELOAD} entry of the mount list is
non-zero, the {\tt mount} command already performs this activity. The
process of loading a handler depends on the nature of the handler and
explained in more detail in section~\ref{sec:startup}.
\smallskip{}

{\tt dol\_GlobVec} identifies the nature of the handler as AmigaDOS
supports (still) BPCL and C/assembler handlers and defines how access
to the \emph{dos list} is secured for handler loading and startup.
BCPL handlers use a somewhat more complex loading and linking
mechanism as the language-specific \emph{global vector} needs to be
populated. This is not required for C or assembler handlers where a
simpler mechanism is sufficient, more on this in
section~\ref{startup}. Another aspect of the startup process is how
the \emph{device list} is protected from conflicting accesses from
multiple processes. Two types of access protection are possible:
Exclusive access to the list, or shared access to the list. Exclusive
access protects the \emph{device list} from any changes while the
handler is loaded and until handler startup completed. This prevents
any other modification to the list, but also read access from any
other process to the list. Shared access allows read accesses to the
list while preventing exclusive access to it.
\smallskip{}

The value in {\tt dol\_GlobVec} corresponds to the {\tt GlobVec} entry
in the mount list. It shall be one of the values in
table~\ref{table:gvvalues}.

\begin{rkrmtable}{GlobVec Values} \label{table:gvvalues}
{\tt \bf dol\_Type} & {\bf Description}\\ \hline \hline
{\tt -1} & C/assembler handler, exclusive lock on the \emph{dos list} \\ \hline
{\tt -2} & C/assembler handler, shared lock on the \emph{dos list} \\ \hline
{\tt  0} & BCPL handler using system GV, exclusive lock on the \emph{dos list} \\ \hline
{\tt -3} & BCPL handler using system GV, shared lock on the \emph{dos list} \\ \hline
{\tt >0} & BPCL handler with custom GV, exclusive lock on the \emph{dos list} \\ \hline
\end{rkrmtable}

The values $0$, $-3$ and $>0$ all setup a BCPL handler, but differ in
the access type to the \emph{device list} and how the BCPL
\emph{global vector} is populated. This vector contains all global
objects and all globally reachable functions of a BCPL program,
including functions of the \emph{dos.library}. The values $0$ and $-3$
fill this vector with the system functions first, and then use the
BPCL binding mechanism to extend or override entries in this vector
with the values found in the loaded code. Any values $>0$ defines a
\emph{BPTR} to a custom vector which is used instead for initializing
the handler. This startup mechanism has never been used in AmigaDOS
and is not quite practical as this vector needs to be communicated into
the \emph{dos.library} somehow. For new code, BCPL linkage and binding
should not be used anymore.
\medskip{}

Members of the {\tt dol\_volume} structure are used if {\tt dol\_Type}
is {\tt DLT\_VOLUME}, identifying this entry as belonging to a known
specific data carrier.
\smallskip{}

{\tt dol\_VolumeDate} is the creation date of the volume. It is a
{\tt DateStamp}\ref{sec:datestamp} structure that is specified in
section~\ref{sec:datestamp}. It is used to uniquely identify the volume,
and to distinguish this volume from any other volume of the same name.
\smallskip{}

{\tt dol\_LockList} is a pointer to a singly-linked list of
\emph{locks} on the volume. This list is created by the
\emph{file system} when the volume is ejected, and contains all locks on this
volume. It is stored here to allow a similar file system to pick up
the locks once the volume is re-inserted, even if it is re-inserted
into another device. Note that the linkage is performed with
\emph{BPTR}s and the {\tt fl\_Link} member of the {\tt FileLock}
structure.
\smallskip{}

{\tt dol\_DiskType} is an identifier of the \emph{file system type}
that operated the volume and placed here such that an alternative
process of the same file system is able to pick up or refuse the locks
stored here for non-available volumes.
\medskip{}

Members of the {\tt dol\_assign} structure are used for all other
types, i.e. all types of \emph{assigns}.
\smallskip{}

{\tt dol\_AssignName} is pointer to the target name of the assign for
\emph{non-binding} and \emph{late assigns}. The \emph{dos.library}
uses this string to locate the target of the assign. For \emph{late
  assigns}, this member is used only on the first attempt to access
the assign at which {\tt dol\_Lock} is populated.
\smallskip{}

{\tt dol\_List} contains additional locks for \emph{multi-assigns} and
is only used if {\tt dol\_Type} is {\tt DLT\_DIRECTORY}. In such a
case, {\tt dol\_Lock} is the lock to the first directory of the
\emph{multi-assign}, while {\tt dol\_List} contains all following
\emph{locks} in a singly-linked list of {\tt AssignList} structures:

\mkey{AssignList}
\begin{verbatim}
struct AssignList {
        struct AssignList *al_Next;
        BPTR               al_Lock;
};
\end{verbatim}

{\tt al\_Next} points to the next \emph{lock} that is part of the
\emph{multi-assign} and {\tt al\_Lock} is the lock itself. This
structure is also defined in {\tt dos/dosextens.h}.

\section{The Device List and the Mount List} \label{sec:mountlist}

Entries of the type {\tt DLT\_DEVICE} can be created through a {\tt
  Mountlist} and the {\tt Mount} command. Other sources of these entries are
the \emph{expansion.library} which is called from autoconfiguring boot
devies, such as SCSI hostadapters or other media interfaces.
\smallskip{}

Many keywords in the {\tt Mountlist} map directly to entries in the {\tt
  DosList} structure, others to entries in the {\tt FileSysStartupMsg} and
the {\tt DosEnvec} structure pointed to there.

\subsection{Keywords defining the DosList structure} \label{sec:mountdoslist}

The {\tt HANDLER}, {\tt EHANDLER} and {\tt FILESYSTEM} keywords in the
{\tt Mountlist} do all three into the {\tt dol\_Handler} member. Which
keyword is used impacts, however, other elements of the {\tt DosList}, most
notably {\tt dol\_Startup}.
\smallskip{}

The {\tt STACKSIZE} keyword sets {\tt dol\_StackSize} element. This is in
bytes for C and assembler handlers, and in long-words for BCPL handlers. The
type of the handler is determined by {\tt GLOBVEC}.
\smallskip{}

The {\tt PRIORITY} keyword sets {\tt dol\_Priority} and with that the
priority of the process running the handler.
\smallskip{}

The {\tt GLOBVEC} keyword sets {\tt dol\_GlobVec} element, and by that also
the type of the handler. Table~\ref{table:gvvalues} in~\ref{sec:devicelist}
lists the possible values and their interpretation.
\smallskip{}

If the {\tt HANDLER} keyword is present, the {\tt STARTUP} entry in the {\tt
  Mountlist} sets {\tt dol\_Startup}. It can be either an integer value, or
if the argument is enclosed in double quotes, a string. In the latter case,
{\tt dol\_Startup} is set to a \emph{BPTR} to a \emph{BSTR} that is, to ease
handler implementation, also {\tt NUL} terminated. The terminator is,
however, not included in the size of the \emph{BSTR}. It is therefore up to
the user to ensure that the arguments in the {\tt Mountlist} are what the
handler expects.

\subsection{Keywords controlling the FileSysStartupMsg} \label{sec:filesysstartup}

If the {\tt EHANDLER} or {\tt FILESYSTEM} keyword is present, {\tt
  dol\_Startup} is instead a \emph{BPTR} to a {\tt FileSysStartupMsg}
structure, defined in {\tt dos/filehandler.h}:
\mkey{FileSysStartupMsg}
\begin{verbatim}
struct FileSysStartupMsg {
    ULONG       fssm_Unit;
    BSTR        fssm_Device;
    BPTR        fssm_Environ;
    ULONG       fssm_Flags;
};
\end{verbatim}
It is again up to the user to ensure that the handler is really expecting
such a structure and setup the {\tt Mountlist} appropriately.
\medskip{}

The elements of the above structure identify an exec type device on top of
which the \emph{handler} or \emph{file system} is supposed to operate. Some
extended handlers, i.e. {\tt EHANDLER}s, also use this structure; the V47
{\tt Port-Handler} can be setup this way to operate on top of a third-party
serial device driver.
\smallskip{}

The {\tt DEVICE} keyword of the {\tt Mountlist} sets {\tt fssm\_Device}
entry. This element is initialized to a \emph{BSTR}. To avoid further string
conversion when calling {\tt OpenDevice()}\key{OpenDevice()}, this
\emph{BSTR} is {\tt NUL}-terminated.
\smallskip{}

The {\tt UNIT} keyword sets {\tt fssm\_Unit} and therefore the unit number
of the exec device on top of which the file system or handler should
operate.
\smallskip{}

The {\tt FLAGS} keyword sets {\tt fssm\_Flags} element, and thus the flags
for opening an exec type. Its purpose and meaning is specific to the device
identified by {\tt fssm\_Device}.
\smallskip{}

\subsection{Keywords controlling the Environment Vector} \label{sec:envec}

The {\tt fssm\_Environ} element of the {\tt FileSysStartupMsg} is a
\emph{BPTR} to another structure that describes, amongst others, the layout
of a \emph{file system} on a disk; beyond \emph{file systems}, extended
handlers mounted by the {\tt EHANDLER} keyword may also make use of it.
\smallskip{}

This structure is also defined in {\tt dos/filehandler.h} and looks as
follows: \mkey{DosEnvec}
\begin{verbatim}
struct DosEnvec {
    ULONG de_TableSize;      /* Size of Environment vector */
    ULONG de_SizeBlock;      /* in longwords: physical disk block size */
    ULONG de_SecOrg;         /* not used; must be 0 */
    ULONG de_Surfaces;       /* # of heads (surfaces). drive specific */
    ULONG de_SectorPerBlock; /* physical sectors per logical block */
    ULONG de_BlocksPerTrack; /* blocks per track. drive specific */
    ULONG de_Reserved;       /* DOS reserved blocks at start of partition. */
    ULONG de_PreAlloc;       /* DOS reserved blocks at end of partition */
    ULONG de_Interleave;     /* usually 0 */
    ULONG de_LowCyl;         /* starting cylinder. typically 0 */
    ULONG de_HighCyl;        /* max cylinder. drive specific */
    ULONG de_NumBuffers;     /* Initial # DOS of buffers.  */
    ULONG de_BufMemType;     /* type of mem to allocate for buffers */
    ULONG de_MaxTransfer;    /* Max number of bytes to transfer at a time */
    ULONG de_Mask;           /* Address Mask to block out certain memory */
    LONG  de_BootPri;        /* Boot priority for autoboot */
    ULONG de_DosType;        /* ASCII (HEX) string showing filesystem type;
                              * 0X444F5300 is old filesystem,
                              * 0X444F5301 is fast file system */
    ULONG de_Baud;           /* Baud rate for serial handler */
    ULONG de_Control;        /* Control word for handler/filesystem */
    ULONG de_BootBlocks;     /* Number of blocks containing boot code */

};
\end{verbatim}
The elements in this structure, except the first one, are also initialized
by keywords in the mount list.
\smallskip{}

{\tt de\_TableSize} defines how many elements in this structure are actually
valid and thsu may be accessed by the \emph{handler} or \emph{file
system}. It is \emph{not} a byte count, but an element count, excluding {\tt
  de\_TableSize}. In other words, the {\tt DosEnvec} is a typical BCPL
vector whose vector size is indicated in its first element --- note that all
elements of the structure are 32-bits wide.
\smallskip{}

The keyword {\tt SECTORSIZE} and {\tt BLOCKSIZE} set both {\tt
  de\_SizeBlock}. While the {\tt Mountlist} keywords take a byte count, this
byte count is divided by 4 to form a long-word count that is inserted into
{\tt de\_SizeBlock}. As the name suggests, it defines the size of a storage
unit on a medium. Typical values are 128 for 512 byte blocks, or 1024 for
4096 byte blocks. However, not all file systems support all block sizes, and
some only support the default value of 128, i.e. 512 byte blocks, the {\tt
  Mount} command fills in without further information.
\smallskip{}

{\tt de\_SecOrg} is not used and shall be~0; consequently, the {\tt Mount}
command does not provide a keyword to set it.
\smallskip{}

The {\tt SURFACES} keyword sets {\tt de\_Surfaces}. A possible meaning for
this member is to interpret it as the number of read-write heads of a
magnetic disk drive. However, as the exec device {\tt trackdisk} interface
for magnetic storage media does not actually allow access to such low-level
features that are rather abstracted away by the device, \emph{file systems}
rather use this value along with {\tt de\_BlocksPerTrack} the number of
cylinders computed from {\tt de\_LowCyl} and {\tt de\_HighCyl} to determine
the capacity of the medium.
\smallskip{}

The {\tt SECTORSPERBLOCK} keyword sets the {\tt de\_SectorsPerBlock}, and
thus the number of physical sectors on a disk the \emph{file system}
combines to one longical storage block. Not all \emph{file systems} support
values different from~1 here; the FFS does, and always reads and writes data
in units of {\tt de\_SectorsPerBlock} times {\tt de\_SizeBlock} of
long-words. For the exec {\tt trackdisk} interface, the byte size is the
only value that matters; however, the ``direct SCSI'' transfer latest FFS
releases offer addresses the disk in terms of physical sectors, and then
{\tt de\_SizeBlock} defines the size of a sector in long-words as addressed
by SCSI commands, whereas {\tt de\_SectorsPerBlock} is the number of
physical sectors the FFS reads for one logical block.
\smallskip{}

The {\tt SECTORSPERTRACK} and {\tt BLOCKSPERTRACK} keywords set both the
{\tt de\_BlocksPerTrack} element of the {\tt DosEnvec} structure. The first
name is actually most appropriate as this element defines the number of
physical sectors, and not the number of logical blocks a track of a disk
contains. Thus, naming is a historical accident. As for the {\tt SURFACES}
keyword, the number of sectors per track is only in so far relevant as it
defines along with the first and last cylinder the storage capacity of the
medium or partition. The values never enter the exec layer.
\smallskip{}

The {\tt RESERVED} keyword sets the {\tt de\_Reserved} element of {\tt
  DosEnvec} and defines the number of (logical) blocks not used by the
\emph{file system} at the start of the disk or partition. For floppies,
these reserved blocks hold a (minimal) boot procedure that initializes the
\emph{dos.library}.
\smallskip{}

The {\tt PREALLOC} keyword installs the {\tt de\_PreAlloc} element, which is
supposed to be the number of logical blocks set aside at the end of the
partition. However, current FFS versions completely ignore this element.
\smallskip{}

The {\tt INTERLEAVE} keyword defines the lower 16 bits of the {\tt
  de\_Interleave} element. TRIPOS might have reserved the entire long-word
to define the interleave factor of the disk, and the difference between two
sector addresses the file system is supposed to reserve for subsequent
storage. This interleave factor helped to speed up transfers for ancient
harddisks, but neither the original OFS nor the latest FFS make use of this
mechanism and allocate sectors contiguously, i.e. with an interleave factor
of~1. The upper 16 bits of {\tt de\_Interleave} suit now a different
purpose and are set by separate keywords of {\tt Mount}.
\smallskip{}

The {\tt LOWCYL} keyword initializes the {\tt de\_LowCyl} element of the
{\tt DosEnvec} structure. It sets the lower end of the partition on the
storage medium, i.e. {\tt de\_LowCyl} $\times$ {\tt de\_Surfaces} $\times$
{\tt de\_BlocksPerTrack} + {\tt de\_Reserved} $\times$ {\tt
  de\_SectorsPerBlock} is the first physical sector number on a disk that
can carry payload data of the file system.
\smallskip{}

The {\tt HIGHCYL} keyword sets the {\tt de\_HighCyl} element; it defines the
(inclusive) upper end of the partition in units of cylinders. That is, ({\tt
  de\_HighCyl} + 1) $\times$ {\tt de\_Surfaces} $\times$ {\tt
  de\_BlocksPerTrack} $- 1$ is the last sector of the partition or medium the
\emph{file system} can allocate for payload data.
\smallskip{}

The {\tt BUFFERS} keyword sets the {\tt de\_NumBuffers} element; it defines
the (initial) number of file system buffers allocated for caching metadata
and storing data not directly accessible through the exec device driver. The
number of buffers may be changed later with {\tt
  AddBuffers()}\key{AddBuffers()},
see section~\ref{sec:addbuffers}. Each buffer is one (logical) block large.
\smallskip{}

The {\tt BUFMEMTYPE} defines the {\tt de\_BufMemType} element. It defines
the memory type, i.e. the second argument of {\tt AllocMem()}, for
allocating memory keeping the file system buffers. While exec device drivers
should be able read and write data to any memory type, several legacy rivers
may not be able reach all memory; this may be due to limitations of the
hardware such that Zorro-II hardware cannot reach 32-bit memory. Thus,
depending on limitations of the {\tt fssm\_Device}, it is unfortunately
up to the user to provide a suitable {\tt BUFMEMTYPE}.
\smallskip{}

The {\tt MASK} keyword defines the {\tt de\_Mask} element of the
{\tt DosEnvec} structure. The mask is a workaround for defect device drivers
that cannot read or write to all memory types. In particular, if the address
of the host memory buffer has bits set in positions where the mask contains 0
bits, the\emph{file system} shall assume that the device cannot reach this
memory. Instead, it shall perform input or output indirectly through its
buffers, and copy with the CPU between those buffers and the target or
source memory block.

\punchline{Masking Defects}{The purpose of the mask is to hide defects in
  device drivers and provide a working system in the absence of a fully
  functional device driver. A rather typical value for the mask is {\tt
    0x00ffffff}, indicating that the device cannot reach 32-bit memory. A
  suitable memory type would then be {\tt MEMF\_24BITDMA | MEMF\_PUBLIC},
  i.e. 513 as decimal value. This requests 24-bit memory for the buffers.
  Note that providing a mask is useless if the memory type does not allocate
  memory that fits to the mask.}

The {\tt MAXTRANSFER} keyword sets {\tt de\_MaxTransfer}. This value sets
the maximum number of bytes the \emph{file system} shall read or write by a
single I/O operation. Similar to {\tt MASK}, it is a workaround required to
avoid problems with defect device drivers that corrupt data if too many
bytes are read or written in one go.

\punchline{MaxTransfer is not a rate}{The MaxTransfer keyword or element
  describe a byte count that, when exceeded, requests the file system to
  break up transfers. While that implicitly limits the throughput of the
  device, it does not define a rate (i.e. in units of bytes per second), as
  the problem device drivers have is typically not the transfer rate, but
  the amount of data to transfer.}

The {\tt BOOTPRI} keyword sets the {\tt de\_BootPri} element which defines
the order in which the system attempts to boot from a partition or
medium. Obvously, it makes little sense to set this keyword in a {\tt
  Mountlist} that is interpreted after the system had already
booted. However, autobooting devices may set an appropriate value here, for
example by reading it from the RDB of its disk.
\smallskip{}

The {\tt DOSTYPE} keyword sets the {\tt de\_DosType} element, identifying
the type and flavour of the file system to use for the medium or
partitiion. If the {\tt FILESYSTEM} keyword is present, but the {\tt
  FORCELOAD} is either not present or set to 0, then the {\tt Mount} command
first attempts to find a suitable file system in the {\tt
  FileSystem.resource} whose {\tt fse\_DosType} matches {\tt de\_DosType},
avoiding to load the same file system again. If a match is found, the {\tt
  FileSysEntry} of the resource is used to initialize the {\tt DosEnvec}, in
particular {\tt dol\_SegList}. Table~\ref{table:ffsflavours} in
lists the available file systems.
\smallskip{}

\begin{rkrmtable}{Fast File System Flavours} \label{table:ffsflavours}
{\bf FFS Flavour} & {\bf Description} \\ \hline \hline
{\tt ID\_DOS\_DISK} & Original file system (OFS) \\ \hline
{\tt ID\_FFS\_DISK} & First version of FFS \\ \hline
{\tt ID\_INTER\_DOS\_DISK} & International variant of OFS \\ \hline
{\tt ID\_INTER\_FFS\_DISK} & International variant of FFS \\ \hline
{\tt ID\_FASTDIR\_DOS\_DISK} & OFS variant with directory cache \\ \hline
{\tt ID\_FASTDIR\_FFS\_DISK} & FFS variant with directory cache \\ \hline
{\tt ID\_LONG\_DOS\_DISK} & OFS variant with 106 character file name size \\ \hline
{\tt ID\_LONG\_FFS\_DISK} & FFS variant with 106 character file name size \\ \hline
{\tt ID\_COMPLONG\_FFS\_DISK} & FFS with 54 character file names compatible
to FFS \\ \hline \hline
{\tt 'MSD\textbackslash0'} & FAT on a disk without partition table \\ \hline
{\tt 'MDD\textbackslash0'} & identical to the above, FAT on a floppy \\ \hline
{\tt 'MSH\textbackslash0'} & FAT on a partition \\ \hline
{\tt 'FAT\textbackslash0'} & FAT, switched by the SuperFloppy disk \\ \hline \hline
{\tt 'CD0\textbackslash0'} & Original CD File system \\ \hline
{\tt 'CD0\textbackslash1'} & CD File System with Joliet support \\ \hline
\end{rkrmtable}

The first part of the table indicates various versions of the ROM file
system; the original version from TRIPOS is here denoted as OFS, though this
name mostly distignuishes it from its later reimplementation, the FFS.
\smallskip{}

The OFS variants embed additional administration information into the
data blocks and thus carry less payload data per block, and for that
are more robust, but are slower as the data cannot be transmitted by
DMA into the host memory but requires an additional copy. The first
FFS variant addresses this issue. Both first types use, however, a
non-suitable algorithm for case-insensitive comparison of file names
and thus do not interpret character from the extended ISO-Latin-1 set
(i.e. printable characters outside the ASCII range) correctly. Thus,
the first two types should be avoided.
\smallskip{}

Proper case-insensitive interpretation of file names was added
afterwards, leading to the next two flavours which are otherwise
identical. All types from that point on in
table~\ref{table:ffsflavours} until its end use the correct algorithm
to compare file names.
\smallskip{}

The next two versions administrate an additional directory cache;
while this cache typically speeds up listing the directory, it also
requires additional update steps when adding or renaming files, making
such operations slower and more error prone. These variants
unfortunately also lack a good algorithm to clean up the cache if
objects are continuously added and removed from directories.  These
variants are not generally recommended and should be considered
experimental.
\smallskip{}

The {\tt LONG} variants of OFS and FFS allow file names of up to 106
characters by using a slightly modified block syntax which overcomes
the 30 character file name limit all above variants suffer from. They
also use the correct case-insensitive file name comparison. In some
rare cases, the administration information is augmented by one
additional block keeping a long comment.
\smallskip{}

The last variant offers a compatible form of long file names that is
backwards compatible to earlier variants of the FFS. The file name
limit is here 54 characters, though older versions of the FFS can
still read the disk correctly, even though they will not be able to
locate or list longer file names. This variant is also experimental.
\medskip{}

The next group of types indicates various flavours of the MS-DOS FAT file
system. The first two types are identical and correspond to a file system on
a single disk without a partition table, as found on floppy disks. They are
unsuitable for harddisk partitions and thumbdrive partitions.
\smallskip{}

The second type indicates FAT on a Master Boot Record (MBR) partition as
used on (legacy) PC hardware. As AmigaDOS does not natively support the MBR,
the file system here (as an architectural tweak) interprets the partition
table. Which partition is used is then depending on the last character of
the device name, i.e. {\tt dol\_Name}. The {\tt C} character indicates the
first partition, adpoting the convention of the operating system to which
FAT is native, the second partition is indicated by the last character of
{\tt dol\_Name} being {\tt D} and so on.
\smallskip{}

The last type indicates a file system either on a floppy or the first
partition of a MBR-formatted disk, depending on the {\tt SUPERFLOPPY}
keyword, see below.
\medskip{}

The last group indicates various versions of the CD-Rom --- actually ISO
Rock Ridge --- file system. The first type is the original file system that
came with V40 of AmigaDOS, the second the extended version that includes
support for Joliet extensions and audio track support. Otherwise, the types
are identical.
\medskip{}

The {\tt BAUD} keyword fills the {\tt de\_Baud} element; it is obviously not
used by \emph{file systems} but extended handlers that are indicated by
the {\tt EHANDLER} keyword. For them, it provides the baud rate for an
(assumed) serial connection.
\smallskip{}

The {\tt CONTROL} keyword sets the {\tt de\_Control} element. Even though
this element is here indicated as an {\tt ULONG}, it can be either an
integer or a string. In the latter case, the argument to {\tt CONTROL} shall
be enclosed in double quotes, and the {\tt Mount} command then places a
\emph{BPTR} to a \emph{BSTR} in this element. Again, it is up to the user to
learn from the handler documentation what the handler expects to find in the
{\tt DosEnvec} structure as there is no type check and no place where the
type is indicated.
\smallskip{}

The {\tt BOOTBLOCKS} keyword initializes the {\tt de\_BootBlocks} element;
it is currently not used by any AmigaDOS file system. The FFS instead
depends on {\tt de\_Reserved}.
\smallskip{}

The {\tt SUPERFLOPPY} keyword takes a boolean 0 or 1 argument and by that
either sets or clears the {\tt ENVF\_SUPERFLOPPY} flag. This flag has been
cut off (or reserved) from the otherwise deprecated and thus unused {\tt
  de\_Interleave} element. It is by default cleared.
\smallskip{}

If this flag in {\tt de\_Interleave} is set, then the file system is
informed that the partition extends over the entire medium and no partition
table or RDB is found. Instead, to find the size of the medium, the file
system is authorized to issue a {\tt TD\_GETGEOMETRY} command to the low
level device driver which will report the layout of the disk. This driver
information is then used to adjust {\tt de\_LowCyl}, {\tt de\_HighCyl}, {\tt
  de\_SizeBlock} and {\tt de\_Surfaces}. Thus, a file system mounted with
this flag set is able to extract the device layout directly from the
hardware driver. This is important for drives that allow variously sized
media, such as floppy disks (supporting both DD and HD disks) as well as ZIP
drives (supporting 100MB to 250MB drives).
\smallskip{}

AmigaDOS up to release V40 hardwired this special case to the {\tt
  trackdisk.device} and {\tt carddisk.device}, i.e. the floppy and memory
cards in the PCMCIA slot, though newer releases allow to extend this
mechanism to other device drivers as well. As of V47, the FAT and ROM file
system both support this mechanism, though it has to be enabled with the
{\tt 'FAT\textbackslash0'} {\tt dostype} for the former driver.
\medskip{}

The {\tt SCSIDIRECT} keyword is also a boolean 0/1 indicator and controls
the {\tt ENVF\_SCSIDIRECT} flag which is also part of the otherwise
deprecated {\tt de\_Interleave} element. It is cleared by default,
indicating that the file system should use the {\tt trackdisk} command set
to access data.
\smallskip{}

If this flag is enabled, the file system is instructed to communicate with
the underlying device through the {\tt HD\_SCSICMD} interface, i.e. SCSI
commands. This may help some legacy device drivers that do not speak the
64-bit dialect of the {\tt trackdisk} commands to access data beyond the 4GB
barrier. Very anchient device drivers may not even support this command
type.
\medskip{}

The {\tt ENABLENSD} keyword is again a boolean 0/1 indicator for the
{\tt ENVF\_DISABLENSD} flag cut off from the {\tt de\_Interleave} field; it
is, however, set in inverse logic, i.e. the {\tt ENVF\_DISABLENSD} is set if
the mount parameter is 0, and reverse.
\smallskip{}

If the flag in {\tt de\_Interleave} is set, and thus {\tt ENABLENSD} is set
to $0$ in the mount list, the file system is instructed not to attempt to
use {\tt NSD}-style commands to access data beyond the 4GB barrier. This may
be necessary on some device drivers that ignore the most significant bits of
the {\tt io\_Command} field or react otherwise allergic to commands beyond
the usual range.
\smallskip{}

Unfortunately, multiple command sets exist to access (moderately) large
disks. If {\tt DIRECTSCSI} is enabled, SCSI commands will always be used,
even for probing the medium size if {\tt SUPERFLOPPY} is set. If SCSI
commands are not enabled, the FFS first attempts to use regular
{\tt trackdisk} commands if the requested region of the device does not cross
the 4GB barrier. If that is not possible, it probes the {\tt TD64} command
set as it is historically the most popular extension. As last resort, it
tries {\tt NSD} commands. This last step can be disabled by the line {\tt
  ENABLENSD = 0} in the {\tt Mountlist} if it creates problems.
\medskip{}

The {\tt ACTIVATE} keyword in the {\tt Mountlist} is synonym to the {\tt
  MOUNT} keyword, and it also takes a boolean 0/1 indicator. If it is set,
then the {\tt Mount} command will already load and initiate the handler
corresponding to the mount entry, even if it is at this point not yet
needed.
\smallskip{}

The {\tt FORCELOAD} keyword of the {\tt Mountlist}, finally, is another
boolean 0/1 flag. If it is set to 1, it indicates to the {\tt Mount} command
not to scan the {\tt FileSystem.resource} for a fitting {\tt dostype} but
rather forcibly load the \emph{file system} from the path indicated by the
{\tt FILESYSTEM} keyword. This option is, for example, useful for testing.

\section{Finding Handler or File System Ports}

The following functions find the \emph{MsgPort} of the \emph{handler}
or \emph{file system} that is responsible for a given object. The
functions search the \emph{device list}, check whether the handler is
already loaded or load it if necessary, then check whether the handler
is already running, and if not, launch an instance of it. If
\emph{multi-assigns} are involved, it can become necessary to contact
multiple \emph{file systems} to resolve the task and thus to iterate
through multiple potential \emph{file systems} to find the right one.

\subsection{Iterate through Devices Matching a Path}

The {\tt GetDeviceProc()}\mkey{GetDeviceProc()} find a handler, or the
next handler responsible for a given path. Once the handler has been
identified, or iteration through matching handlers is to be aborted,
{\tt FreeDeviceProc()} shall be called to release temporary resources.

\begin{verbatim}
devproc = GetDeviceProc(name, devproc)
D0                      D1     D2

struct DevProc *GetDeviceProc(STRPTR, struct DevProc *)
\end{verbatim}

This function takes a path in {\tt name} and either {\tt NULL} on the
first iteration or a {\tt DevProc} structure from a previous iteration
and returns either a {\tt DevProc} structure in case a matching
handler could be identified, or {\tt NULL} if no matching handler
could be found or all possible matches have been iterated over already
already.

\punchline{Give back what you got}{To release all temporary resources,
  the {\tt DevProc} structure returned by {\tt GetDeviceProc()} shall be
  either be released through {\tt FreeDeviceProc()} then aborting the scan,
  or used as first argument for {\tt GetDeviceProc()} to continue the
  iteration. The last call to this function will return {\tt NULL} and then
  also release all resources.}

The {\tt DevProc} structure, defined in {\tt dos/dosextens.h}
looks as follows:

\key{DevProc}
\begin{verbatim}
struct DevProc {
        struct MsgPort *dvp_Port;
        BPTR            dvp_Lock;
        ULONG           dvp_Flags;
        struct DosList *dvp_DevNode;    /* DON'T TOUCH OR USE! */
};
\end{verbatim}

{\tt dvp\_Port} is a pointer to a candidate \emph{MsgPort} that should
be tried to resolve {\tt name}.
\smallskip{}

If the matching handler is a \emph{file system}, then {\tt dvp\_Lock}
is a \emph{lock} of a directory. The path in {\tt name}is a path
relative to this directory. This \emph{lock} shall not be released,
but it may be copied with {\tt DupLock}\key{DupLock()}.
\smallskip{}

{\tt dvp\_Flags} identifies the nature of the found port. If the bit
{\tt DVPB\_ASSIGN} is set, i.e {\tt dvp\_Flags \& DVPF\_ASSIGN} is
non-zero, then the found match is part of a \emph{multi-assign} and
{\tt GetDeviceProc()} may be called again with the {\tt devproc}
argument just returned as second argument. This will return another
candidate for a path. {\tt DVPB\_UNLOCK} is another bit of the flags
but shall not be interpreted and is only used internally by the function.
\smallskip{}

The member {\tt dvp\_DevNode} shall not be touched or used and is
required internally by the function.
\medskip{}

If the function returns {\tt NULL}, then {\tt IoErr()}\key{IoErr()}
provides additional information on the failure. If the error code is
{\tt ERROR\_NO\_MORE\_ENTRIES}, then the last directory of a
\emph{multi-assign} has been reached. If the error code is {\tt
  ERROR\_DEVICE\_NOT\_MOUNTED}, then no matching device could be
found. Other errors may be returned, e.g. if the function could not
allocate sufficient memory for its operation.
\smallskip{}

Unfortunately, the function does not set {\tt IoErr()} consistently if
{\tt GetDeviceProc()} is called again on an existing {\tt DevProc}
structure as second argument with {\tt DVPB\_ASSIGN} cleared. {\tt
  IoErr()} remains then unaltered and it is therefore advisable to
clear it upfront.
\smallskip{}

The function also returns {\tt NULL} if {\tt name} corresponds to the
{\tt NIL:} pseudo-device and then sets {\tt IoErr()} to {\tt
  ERROR\_DEVICE\_NOT\_MOUNTED}. This is not fully correct, and callers
need to be aware of this defect.
\smallskip{}

Also, {\tt GetDeviceProc} does not handle the path ``{\tt *}'' at all,
even though it indicates the current console and the
\emph{Console-Handler} is responsible for it.  This case also needs to
be detected by the caller, and in such a case,
{\tt GetConsoleTask()}\key{GetConsoleTask()} delivers the correct port.

\punchline{Does not like all paths}{The {\tt GetDeviceProc()} function
  unfortunately does not handle all device specifiers correctly, and some
  special cases need to be filtered out by the caller. Namely ``{\tt *}''
  indicating the current console, and {\tt NIL:} for the {\tt NIL}
  pseudo-device are not handled here.}
 
\subsection{Releasing DevProc Information}

The {\tt FreeDeviceProc()}\mkey{FreeDeviceProc()} function releases a
{\tt DevProc}\key{DevProc} structure previously returned by {\tt
  GetDeviceProc()}\key{GetDeviceProc()} and releases all temporary
resources allocated by this function. It shall be called as soon as
the {\tt DevProc} structure is no longer needed.

\begin{verbatim}
FreeDeviceProc(devproc)
                 D1

void FreeDeviceProc(struct DevProc *)
\end{verbatim}

This function releases the {\tt DevProc} structure and all its
resources from an iteration through one or multiple
{\tt GetDeviceProc()} calls. If {\tt GetDeviceProc()} returned {\tt NULL}
itself it had already released such resources itself and no further
activity is necessary.
\smallskip{}

The {\tt dvp\_Port} or {\tt dvp\_Lock} within the {\tt DevProc}
structure shall not be used after releasing it with {\tt
  FreeDeviceProc()}. If a \emph{lock} is needed afterwards, a copy of
{\tt dvp\_Lock} shall be made with {\tt DupLock()}\key{DupLock()}. If
the port of the \emph{handler} or \emph{file system} is needed
afterwards, a resource of this handler shall be obtained, e.g. by
opening a file or obtaining a lock on it. Both the {\tt
  FileHandle}\key{FileHandle} and the {\tt FileLock}\key{FileLock}
structures contain a pointer to the port of the corresponding handler.
\smallskip{}

It is safe to call {\tt FreeDeviceProc()} with a {\tt NULL} argument;
this performs no activity.
\smallskip{}

This function does not set {\tt IoErr()} consistently and no
particular value may be assumed. It may or may not alter its value.

\subsection{Legacy Handler Port Access}

The {\tt DeviceProc()}\mkey{DeviceProc()} function is a legacy variant
of {\tt GetDeviceProc()}\key{GetDeviceProc()} that should not be used
anymore. It is not able to reliably provide locks to \emph{assigns}
and will not work through all directories of a \emph{multi-assign}.

\begin{verbatim}
process = DeviceProc( name )
 D0                    D1

struct MsgPort *DeviceProc (STRPTR)
\end{verbatim}

This function returns a pointer to a port of a \emph{handler} or
\emph{file system}able to handle the path {\tt name}. It returns
{\tt NULL} on error in which case it sets {\tt IoErr()}\key{IoErr()}.
\smallskip{}

If the passed in {\tt name} is part of an \emph{assign}, the handler
port of the directory the assign binds to is returned, and {\tt
  IoErr()} is set to the \emph{lock} of the assign. Unfortunately, one
cannot safely make use of this \emph{lock} as the \emph{device list}
may be altered any time, including the time between the return from
this function and its first use by the caller. Thus, {\tt
  GetDeviceProc()} shall be used instead which locks resources such as
the \emph{device list}; they are released through {\tt
  FreeDeviceProc()}.

\punchline{Obsolete and not fully functional}{{\tt DeviceProc()} function
  does not operate properly on \emph{multi-assigns} where it only provides
  the port and \emph{lock} to the first directory participating in the
  assign. It also returns {\tt NULL} for \emph{non-binding assigns} as there
  is no way to release a temporary lock obtained on the target of the
  \emph{assign}. Same as {\tt GetDeviceProc()}, it does not properly handle
  {\tt NIL:} and ``{\tt *}''.}

\subsection{Obtaining the Current Console Handler} \label{sec:getconsoletask}

The {\tt GetConsoleTask()}\mkey{GetConsoleTask()} function returns the
\emph{MsgPort} of the handler responsible for the console of the
calling process, that is, the process that takes care of the file name
``{\tt *}'' or paths relative to {\tt CONSOLE:}.

\begin{verbatim}
port = GetConsoleTask()
 D0

struct MsgPort *GetConsoleTask(void)
\end{verbatim}

This function returns a port to the handler of the console of the
calling process, or {\tt NULL} in case there is no console associated
to the caller. The latter holds for example for programs started from
the workbench. It does not alter {\tt IoErr()}.

\subsection{Obtaining the Default File System} \label{sec:getfilesystask}

The {\tt GetFileSysTask()}\mkey{GetFileSysTask()} function returns the
\emph{MsgPort} of the default \emph{file system} of the caller. The
default \emph{file system} is used as fall-back if a
\emph{file system} is required for a path relative to the {\tt ZERO} lock, and
the path itself does not contain an indication of the responsible
handler, i.e. is a relative path itself.
\smallskip{}

The default \emph{file system} is typically the boot file system, or
the file system of the {\tt SYS:} \emph{assign}, though it can be
changed with {\tt SetFileSysTask()} at any point.

\begin{verbatim}
port = GetFileSysTask()
 D0

struct MsgPort *GetFileSysTask(void)
\end{verbatim}

This function returns the port of the default file system of this
task. It does not alter {\tt IoErr()}. Note that {\tt SYS:} itself is
an \emph{assign} and paths starting with {\tt SYS:} do therefore not
require resolution through this function, though the default
\emph{file system} and the file system handling {\tt SYS:} are
typically identical. However, as the former is returned by {\tt
  GetFileSysTask()} and the latter is part of the \emph{device list}
\emph{assign}, they can be different.

\section{Iterating and Accessing the Device List}

While {\tt GetDeviceProc()}\key{GetDeviceProc()} uses the \emph{device
  list} to locate a particular \emph{MsgPort} and \emph{Lock}, all
other members of the {\tt DosList} structure remain unavailable. For
them, the \emph{device list} containing these structures need to be
scanned manually. The \emph{dos.library} provides functions to grant
access, search and release access to this list.

\subsection{Gaining Access to the Device List} \label{sec:lockdoslist}

The {\tt LockDosList()}\mkey{LockDosList()} function requests shared
or exclusive access to a subset of entries of the \emph{device list}
containing all \emph{handlers}, \emph{volumes} and \emph{assigns} and
blocks until access is granted. It requires as input multiple sets
that specify which parts of the list to access:

\begin{verbatim}
dlist = LockDosList(flags)
 D0                   D1

struct DosList *LockDosList(ULONG)
\end{verbatim}

This function grants access to a subset of entries of the \emph{device
  list} indicated by {\tt flags}, and returns an opaque handle through
which elements of the list can be accessed. For this, see
{\tt FindDosEntry()}\key{FindDosEntry()}.
\smallskip{}

The {\tt flags} value shall be combination of the following values, all
defined in {\tt dos/dosextens.h}:

\begin{rkrmtable}{LockDosList Flags} \label{table:lockdoslistflags}
{\tt Flags} & {\bf Description}\\ \hline \hline
{\tt LDF\_DEVICES} & Access \emph{handlers} and \emph{file system} entries, see~\ref{sec:deviceoverview} \\ \hline
{\tt LDF\_VOLUMES} & Access \emph{volumnes}, see~\ref{sec:volumelist} \\ \hline
{\tt LDF\_ASSIGNS} & Access \emph{assigns}, see~\ref{sec:assignlist} \\ \hline \hline
{\tt LDF\_ENTRY}  & Lock access to a {\tt DosList} entries \\ \hline
{\tt LDF\_DELETE} & Lock \emph{device list} for deletion \\ \hline \hline
{\tt LDF\_READ} & Shared access to the \emph{device list} \\ \hline
{\tt LDF\_WRITE} & Exclusive access to the \emph{device list} \\ \hline
\end{rkrmtable}

At least {\tt LDF\_READ} or {\tt LDF\_WRITE} shall be included in the
flags, they shall not be set both. The three first flags may also be
combined to access multiple types.
\smallskip{}

{\tt LDF\_ENTRY} and {\tt LDF\_DELETE} are additional flags that
moderate access to entries of the \emph{device list}. If {\tt
  LDF\_ENTRY} is set, then exclusive access to the selected entries is
requested and entries shall not be altered or removed. The {\tt
  LDF\_ENTRY} flag shall not be combined with {\tt LDF\_READ}. If
{\tt LDF\_DELETE} is set, then access is granted for removing entries
from the list.
\medskip{}

The result code {\tt dlist} is \emph{not} a pointer to a {\tt DosList}
structure, but only a handle that may be passed into {\tt
  FindDosEntry()}\key{FindDosEntry()} or {\tt
  NextDosEntry()}\key{NextDosEntry}. If {\tt dlist} is {\tt NULL},
then locking failed because the combination of {\tt flags} passed in
was invalid.
\smallskip{}

This function does not alter {\tt IoErr()}.

\subsection{Requesting Access to the Device List}

The {\tt AttemptLockDosList()}\mkey{AttemptLockDosList()} requests
access to the \emph{device list} or a subset of its entries, and, in
case it cannot gain access, returns {\tt NULL}. Unlike
{\tt LockDosList()}\key{LockDosList()}, it does not block.

\begin{verbatim}
dlist = AttemptLockDosList(flags)
D0                          D1

struct DosList *AttemptLockDosList(ULONG)
\end{verbatim}

The {\tt flags} argument specifies which elements of the \emph{device
  list} are requested for access, and which type of access is
required. The flags are a combination of the flags listed in
table~\ref{table:lockdoslistflags}, and the semantics of the flags are
exactly as specified for {\tt LockDosList()}\key{LockDosList()}, see
there for details.
\smallskip{}

The result code is either a (non-{\tt NULL}) handle that may be passed
into {\tt FindDosEntry()}\key{FindDosEntry()} or {\tt
  NextDosEntry()}\key{NextDosEntry()} in case access could be granted,
or {\tt NULL}. In the latter case, the list is either currently locked
and access cannot be granted without blocking, or flags are
invalid. These two cases of failure cannot be distinguished
unfortunately.
\smallskip{}

This function does not alter {\tt IoErr()}.

\subsection{Release Access to the Device List}

The {\tt UnLockDosList()}\mkey{UnLockDosList()} function releases
access to the \emph{device list} once obtained through {\tt
  LockDosList()}\key{LockDosList()}.

\begin{verbatim}
UnLockDosList(flags)
                D1

void UnLockDosList(ULONG)
\end{verbatim}

This function releases access to the \emph{device list} again. The
{\tt flags} argument shall be identical to the {\tt flags}argument
provided to {\tt LockDosList()}\key{LockDosList()}.

\subsection{Iterate through the Device List}

The {\tt NextDosEntry()}\mkey{NextDosEntry()} iterates to the next
entry in the \emph{device list} given the current entry or the handle
returned by {\tt LockDosList()}.

\begin{verbatim}
newdlist = NextDosEntry(dlist,flags)
 D0                       D1    D2

struct DosList *NextDosEntry(struct DosList *,ULONG)
\end{verbatim}

This function returns the next {\tt DosList}\key{DosList} structure of the
\emph{device list} which shall have been locked with {\tt LockDosList()}. The
{\tt dlist} argument shall be either the return code of a previous
{\tt NextDosEntry()} or {\tt FindDosEntry()}\key{FindDosEntry()}
call, or the handle returned by {\tt LockDosEntry()}.
\smallskip{}

The {\tt flags} argument shall be a subset of the {\tt flags} argument
into {\tt LockDosList()} and specifies the type of {\tt DosList}
structures that shall be found. Only the first 3 elements of
Table~\ref{table:lockdoslistflags} are relevant here, all other flags
are ignored but may be included.
\smallskip{}

The {\tt newdlist} result is either a pointer to a {\tt DosList}
structure of the requested type, or {\tt NULL} if the end of list has
been reached. This function does not alter {\tt IoErr()}.

\subsection{Find a Device List Entry by Name}

The {\tt FindDosEntry()}\mkey{FindDosEntry()} function finds a
{\tt DosList}\key{DosList} structure of a particular type and particular
name, from a particular entry on, or the handle returned by
{\tt LockDosList()}\key{LockDosList()}.

\begin{verbatim}
newdlist = FindDosEntry(dlist,name,flags)
D0                       D1    D2   D3

struct DosList *FindDosEntry(struct DosList *,STRPTR,ULONG)
\end{verbatim}

This function scans through the \emph{device list} starting at the
entry {\tt dlist}, or the handle returned by {\tt LockDosList()}, and
returns the next {\tt DosList} structure that is of the type indicated
by {\tt flags} and has the name {\tt name}.
\smallskip{}

The {\tt flags} shall be a subset of the {\tt flags} argument passed
into {\tt LockDosList()}. Only the first 3 elements of
Table~\ref{table:lockdoslistflags} are relevant here, all other flags
are ignored but may be included.
\smallskip{}

The {\tt name} argument is the (case-insensitive) name of the assign,
handler, file system or volume the function should look for. The name
\emph{shall not} include the colon ('{\tt :}') that separates the name from
the remaining components of a path, see section~\ref{sec:paths}. It may be
{\tt NULL} in which case every entry of the requested type matches.
\smallskip{}

The returned {\tt newdlist} is a pointer to a {\tt DosList} structure
that matches the name (if provided) and flags passed in, or {\tt NULL}
in case no match could be found and the entire list has been
scanned. Note that the returned {\tt DosList} may be identical to the
{\tt dlist} passed in if it already fits the requirements. Thus
potentially, {\tt NextDosList()} may be called upfront to scan from
the subsequent entry.
\smallskip{}

Passing {\tt NULL} as {\tt dlist} is safe and returns {\tt NULL},
i.e. the end of the list. Note that the (pseudo-) devices from
tables~\ref{table:specialdevices} and \ref{table:specialassigns} are
not part of the \emph{device list}, i.e. {\tt NIL}, {\tt CONSOLE},
{\tt *} and {\tt PROGDIR} cannot be found and are special cases of
{\tt GetDeviceProc()}\key{GetDeviceProc()}.
\smallskip{}

This function does not alter {\tt IoErr()}.

\subsection{Accessing Mount Parameters}

Once a {\tt DosList} structure has been identified, e.g. by {\tt
  FindDosEntry()}, it is tempting to understand whether the entry belongs to
an assign or a volume, or a handler or file system, and in the latter two
cases, to find the mount parameters of the handler or file system.
\smallskip{}

The first level of identification is easy and works through the {\tt
  dol\_Type} element of the {\tt DosList} structure; table
\ref{table:doslisttypes} in section~\ref{sec:devicelist} lists the possible
entry types. As seen there, however, \emph{handlers} and \emph{file systems}
share the same type, namely {\tt DLT\_DEVICE}.
\smallskip{}

Information on how a \emph{file system} or a \emph{handler} should be
configured is found in the {\tt dol\_Startup} field; it is, however, up to
the handler to interpret it, and AmigaDOS does not define what exactly it
can contain. The {\tt Mount} command can place three different types of
objects here: An integer value, a \emph{BPTR} to a \emph{BSTR}, or a
\emph{BPTR} to a {\tt FileSysStartupMsg}.
\smallskip{}

Unfortunately, there is no totally safe way how to distinguish these types,
and AmigaDOS does not provide any further source of information to learn
which type a handler expects here --- thus a heuristics is needed to tell
them apart.
\smallskip{}

In the first step, one should check whether the {\tt dol\_Startup} field is
actually a \emph{BPTR} pointing to valid memory. This is even the case for
\emph{file systems} mounted by the ROM, e.g. the {\tt df0:} device:

\begin{verbatim}
void AnalyzeDosList(struct DosList *dl)
{
LONG *startup;

  s=(LONG *)(dl->dol_Startup);
  if (s && TypeOfMem(BADDR(s)) && (LONG)s!=-1L && (LONG)s>0x100 
        && ((LONG)s & 0xc0000000)==0) {
        /* Looks like a plausible BPTR */
        AnalyzeStartup((LONG *)(BADDR(s)));
  } else {
        /* Likely some sort of handler, and s is
        ** probably some integer
        */
        ....
  }
}
\end{verbatim}

The above algorithm uses {\tt TypeOfMem()} to test whether a pointer goes
into valid memory, and also checks the topmost two bits of the
\emph{BPTR}. As \emph{BPTR}s are created by right-shifting a pointer by 2
bits, the two MSBs should thus be zero.
\smallskip{}

In the second step, the heuristics attempts to understand whether the
\emph{BPTR} in {\tt dol\_Startup} actually points to a {\tt
  FileSysStartupMsg} or to a \emph{BSTR}. For that, it attempts to learn
whether the {\tt fssm\_Device} element is a valid \emph{BSTR} and whether
the {\tt fssm\_Envion} element is also a valid \emph{BPTR}.

\begin{verbatim}
void AnalyzeStartup(LONG *startupmsg)
{
BOOL isfsstart=TRUE;
UBYTE *text;

  /* This checks whether fssm_Device 
  ** is meaningful in order to derive
  ** 
  if (startupmsg[1] & 0xc0000000) {
     /* Certainly not a BPTR to
     ** a device name, bail out
     */
     isfsstart = FALSE;
  } else {
     /* Hopefully, a BPTR to a BSTR */
     text=((char *)BADDR(startupmsg[1]))+1;
     if (!TypeOfMem(text)) {
       /* No, that does not work. */
       isfsstart = FALSE;
     } else {
       /* Now check the want-to-be fssm_Envion */
       if (startupmsg[2] & 0xc0000000) {
         isfsstart = FALSE;
       } else if (startupmsg[2]!=NULL && 
                (!TypeOfMem(BADDR(startupmsg[2])))) {
         isfsstart = FALSE;
       }
     }
   }
   
   /*
   ** But could possibly be a string
   */
   if (isfsstart==FALSE) {
    if (TypeOfMem(startupmsg)) {
     /* This is probably a string.
     ** "mount" puts NUL-terminated strings in 
     ** here.
     */
     text = ((UBYTE *)startupmsg)+1;
     ...
    } else {
     struct FileSysStartupMsg *fssm;
     fssm = (struct FileSysStartupMsg *)startupmsg;
     /*
     ** Access fssm->fssm_Device,fssm_Unit,fssm_Flags
     */
     ...
     if ((fssm->fssm_Environ & 0xc0000000) == 0) {
      LONG *ptr = BADDR(fssm->fssm_Environ);
      if (ptr && (TypeOfMem(ptr))) {
       struct DosEnvec *env;
       env = (struct DosEnvec *)ptr;
       /* Hopefully an environment */
       if (env->de_TableSize > 0) {
         /* Ok, this is probably good enough... use the
         ** elements of the environment up to the
         ** one indicated by env->de_TableSize
         */
       }
     }
   }
 }
}
\end{verbatim}

Even if this function is able to identify an {\tt DosEnvec} structure with
high probability, it can happen that the environment vector identified this
way does not contain all the elements documented in {\tt
  dos/filehandler.h}. Only the first {\tt de\_TableSize} elements are
present and can be accessed, so some additional care shall be taken when
interpreting this structure.
\smallskip{}

While the above is just a heuristic and is therefore not guaranteed to work,
practical experience of the author has shown that it has so far been able to
extract environment information from all handlers or file systems that came
into his hand.
\smallskip{}

Nevertheless, getting hands on the {\tt FileSysStartupMsg} from an unknown
handler is not completely waterproof at this moment, and to this end the
author of~\cite{guru} proposed to introduce a {\tt DosPacket} (see
section~\ref{sec:packettypes}) by which a handler can be requested to reveal
its startup message. Unfortunately, to date this packet has not found wide
adoption, and the above heuristics may be used as an interim solution.
\smallskip{}

Authors of \emph{handlers} and \emph{file systems} have less to worry
about. When they document their requirements properly, e.g. by including an
example {\tt Mountlist} with their product, ``only'' user errors can
generate startup messages the handler cannot interpret properly. Thus, in
general, handlers should be written in an ``optimistic'' way (unlike the
above heuristic) assuming that {\tt dol\_Startup} is what they do
expect. All AmigaDOS handlers are written in such a way, e.g. the FFS
expects without verification that the value in {\tt dol\_Startup} is,
indeed, a {\tt FileSysStartupMsg}, even though it can be fooled by an
incorrect {\tt Mountlist} and by that crash the system.

\section{Adding or Removing Entries to the Device List}

The \emph{dos.library} provides two service functions to add or remove
{\tt DosList} structures from the \emph{device list}. They secure the
\emph{dos.library} internal state from inconsistencies as other
processes may attempt to access the \emph{device list} simultaneously,
and they also ensure proper linkage of the structures.
\smallskip{}

\punchline{Locking the device list in file systems}{There is one particular
  race condition \emph{file system} authors should be aware of. When opening
  a file, or obtaining a \emph{lock}, the \emph{dos.library} calls through
  {\tt GetDeviceProc()} to identify a \emph{handler} responsible for the
  requested path. As {\tt GetDeviceProc()}\key{LockDosList()} requires
  access to the \emph{device list}, it will secure access to it through {\tt
    LockDosList()}\key{LockDosList()}, then possibly start up the
  \emph{handler}, and then unlock the list. Thus, at the time the handler is
  initiated, it may find the \emph{device list} unaccessible. Attempting to
  lock it would result in a \emph{deadlock} situation as the
  \emph{dos.library} waits for the \emph{handler} to reply its startup
  packet, and the \emph{handler} waits for the \emph{dos.library} to grant
  access to the \emph{device list}.  The following sections provide
  workarounds how to avoid this situation, see also
  section~\ref{sec:handler} for details on the \emph{handler} and \emph{file
  system} startup mechanism.}

\subsection{Adding an Entry to the Device List}

The {\tt AddDosEntry()}\mkey{AddDosEntry()} adds an initialized {\tt
  DosList} structure to the \emph{device list}.

\begin{verbatim}
success = AddDosEntry(dlist)
D0                     D1

LONG AddDosEntry(struct DosList *)
\end{verbatim}

This function takes an initialized {\tt DosList} entry pointed to by
{\tt dlist} and attempts to add it to the \emph{device list}. For
this, it requests write access to the list, i.e. locking of the
\emph{device list} through the caller is not necessary.
The {\tt DosList} may be either created manually, by
{\tt MakeDosEntry()}\key{MakeDosEntry()} of the \emph{dos.library}
or by {\tt MakeDosNode()}\key{MakeDosNode()} of the \emph{expansion.library}.
While there the structure is called a {\tt DeviceNode}, it is still a
particular incarnation of a {\tt DosList} and may be safely used here.
\medskip{}

\emph{Assigns} \emph{shall not} be added to the \emph{device list}
through this function, but rather through the functions in
section~\ref{sec:assigns}. This avoids memory management problems when
releasing or changing assigns.
\smallskip{}

Particular care needs to be taken if this function is called from
within a \emph{handler} or \emph{file system}, e.g. to add a
\emph{volume} representing an inserted medium. As the list may be
locked by the \emph{dos.library} to secure the list from modifications
within a {\tt GetDeviceProc()}\key{GetDeviceProc()} function, a
deadlock may result where \emph{file system} and \emph{dos.library}
mutually block access. To prevent this from happening handlers should
check upfront whether the \emph{device list} is available for
modifications by {\tt AttemptLockDosList()}\key{AttemptLockDosList()}, e.g.

\begin{verbatim}
if (AttemptLockDosList(LDF_VOLUMES|LDF_WRITE)) {
  rc = AddDosEntry(volumenode);
  UnLockDosList(LDF_VOLUMES|LDF_WRITE);
}
\end{verbatim}
when adding a {\tt DosList} entry of type {\tt DLT\_VOLUME}. If
attempting to get write access failed, the handler should check for
incoming requests, handle them, and attempt adding the entry later.
\smallskip{}

The function fails if an entry is to be added and an entry of the same
name, regardless its type, is already present on the list. The only
exception is that the list may contain two \emph{volumes} of the same
name, provided provided their creation date {\tt dol\_VolumeDate}
differs, see section~\ref{sec:devicelist}.
\smallskip{}

If successful, the function returns non-zero, but then does not alter
{\tt IoErr()}. The {\tt DosList} is then enqueued in the
\emph{dos.library} database and it and its members shall then no
longer be altered or released by the caller. On failure, the function
returns $0$ and {\tt IoErr()} is set to {\tt ERROR\_OBJECT\_EXISTS}.

\subsection{Removing an Entry from the Device List}

The {\tt RemDosEntry()}\mkey{RemDosEntry()} removes a {\tt DosList}
entry from the \emph{device list}, making it unacessible for AmigaDOS.

\begin{verbatim}
success = RemDosEntry(dlist)
D0                     D1

BOOL RemDosEntry(struct DosList *)
\end{verbatim}

This function attempts to find the {\tt DosList} structure pointed to
by {\tt dlist} in the \emph{device list} and, if present, removes
it. Unlike what some other documentation says, this function locks the
\emph{device list} properly before attempting to remove an entry,
locking it upfront is not necessary.
\smallskip{}

The function does \emph{not} attempt to release the memory allocated
for the {\tt DosList} passed in, or any of its members, it just
removes the {\tt DosList} from the \emph{device list}. While
\emph{file systems} may know how they allocated the {\tt DosList}
structures represening their \emph{volumes} and hence should be aware
how to release the memory taken by them, there is no good solution on
how to recycle memory for {\tt DosList} structures representing
\emph{handlers}, \emph{file systems} or \emph{assigns}. Some manual
footwork is currently required, see also {\tt
  FreeDosNode()}\key{FreeDosNode()}. In particular, as entries
representing \emph{handlers} and \emph{file systems} may have been
created in multiple ways, their memory cannot be safely recycled.
\smallskip{}

Particular care needs to be taken if this function is called from
within a \emph{handler} or \emph{file system}, e.g. to remove a
\emph{volume} representing a removed medium. As the list may be
locked by the \emph{dos.library} to secure the list from modifications
within a {\tt GetDeviceProc()}\key{GetDeviceProc()} function, a
deadlock may result where \emph{file system} and \emph{dos.library}
mutually block access. To prevent this from happening handlers should
check upfront whether the \emph{device list} is available for
modifications by {\tt AttemptLockDosList()}\key{AttemptLockDosList()}, e.g.

\begin{verbatim}
if (AttemptLockDosList(LDF_DELETE|LDF_ENTRY|LDF_WRITE)) {
  rc = RemDosEntry(volumenode);
  UnLockDosList(LDF_DELETE|LDF_ENTRY|LDF_WRITE);
}
\end{verbatim}
when removing a {\tt DosList} entry. If attempting to get write access
failed, the handler should check for incoming requests, handle them,
and attempt adding the entry later.
\smallskip{}

This function returns a success indicator; it returns non-zero if the
function succeeds, and $0$ in case it fails. The only reason for
failure is that {\tt dlist} is not a member of the
\emph{device list}. This function does not touch {\tt IoErr()}.

\section{Creating and Deleting Device List Entries}

AmigaOs offers multiple functions to create {\tt DosList}
structures. The {\tt MakeDosEntry()}\key{MakeDosEntry()} function is a
low-level function that allocates a {\tt DosList} but only performs
minimal initialization of the structure. For \emph{assigns}, the
functions in section~\ref{sec:assigns} shall be used as they include
complete initialization of the {\tt DosList}, and for \emph{handlers}
and \emph{file systems}, the \emph{expansion.library} function
{\tt MakeDosNode()}\key{MakeDosNode()} is a proper alternative.
Releasing {\tt DosList}s along with all its resources is unfortunately
much harder. For \emph{assigns}, the algorithm in
section~\ref{sec:releaseentry} provides a workable function based on
{\tt FreeDosEntry()}\key{FreeDosEntry()}.
\smallskip{}

{\tt DosLists} representing \emph{Volumes} are build and released by
\emph{file systems}; it depends on them which resources need to be
released along with the {\tt DosList} structure itself. While it is
recommended that \emph{file systems} should go through
{\tt MakeDosEntry()}\key{MakeDosEntry()} and {\tt FreeDosEntry()}\key{FreeDosEntry()}, it
is not a requirement.
\smallskip{}

Releasing a {\tt DosList} representing a \emph{handler} or \emph{file
  system} is currently not possible in a completely robust way. It is
suggested just to unlink such nodes if absolutely necessary, but
tolerate the memory leak.

\subsection{Creating a Device List Entry}

The {\tt MakeDosEntry()}\mkey{MakeDosEntry()} creates an empty
{\tt DosList} structure of the given type, and makes all elementary
initializations. It does not acquire any additional resources, and neither
inserts it into the \emph{device list}.
\smallskip{}

If an \emph{assign} is to be created, the functions in
section~\ref{sec:assigns} are better alternatives and should be
preferred as they perform a more sophisticated initialization.

\begin{verbatim}
newdlist = MakeDosEntry(name, type)
D0                       D1    D2

struct DosList *MakeDosEntry(STRPTR, LONG)
\end{verbatim}

This function allocates a {\tt DosList} structure and initializes its
{\tt dol\_Type} to {\tt type}. The {\tt type} argument shall be one of
the values from table~\ref{table:doslisttypes}. The function also
makes a copy of {\tt name} and initializes the {\tt dol\_Name} to a
\emph{BSTR} copy of {\tt name}, which is a {\tt NUL} terminated C string.
\smallskip{}

Note that this function performs only minimal initialization of the
{\tt DosList} structure. All other members except {\tt dol\_Type} and
{\tt dol\_Name} are initialized to $0$.
\smallskip{}

This function either returns the allocated structure, or {\tt NULL}
for failure. In the latter case, {\tt IoErr()} is set to {\tt
  ERROR\_NO\_FREE\_STORE}. On success, {\tt IoErr()} remains
unaltered.

\subsection{Releasing a Device List Entry} \label{sec:releaseentry}

The {\tt FreeDosEntry()}\mkey{FreeDosEntry()} function releases
a {\tt DosList} structure allocated by {\tt MakeDosEntry()}\key{MakeDosEntry()}.
The {\tt DosList} shall be already removed from the \emph{device list} by
\emph{RemDosEntry()}. While this call releases the memory holding the
name of the entry, and also the {\tt DosList} structure itself, it
does not release any other resources. They shall be released by the
caller of this function. Furthermore, this function shall not be
called if the {\tt DosList} structure was allocated by any other means
than {\tt MakeDosEntry()}.

\begin{verbatim}
FreeDosEntry(dlist)
               D1

void FreeDosEntry(struct DosList *)
\end{verbatim}

This function releases the {\tt DosList} structure pointed to by
{\tt dlist} and its name, but only these two resources, and no other
resources.
\smallskip{}

If {\tt dol\_Type} is {\tt DLT\_DEVICE}, corresponding to
\emph{handlers} or \emph{file systems}, this function should better
not be called at all as the means of how the {\tt DosList} was
allocated is unclear. In such a case, a memory leak is the least
dangerous side effect.
\smallskip{}

If {\tt dol\_Type} is {\tt DLT\_DIRECTORY} or {\tt DLT\_LATE}, then
{\tt dol\_Lock} should be unlocked. If {\tt dol\_List} is non-{\tt
  NULL}, then each entry of the {\tt AssignList} structure shall be
released, along with the lock kept within. For {\tt DLT\_LATE} and
{\tt DLT\_NONBINDING}, the {\tt dol\_AssignName} function shall also
be released. The following code segment releases all resources for
\emph{assigns}:

\begin{verbatim}
    struct AssignList *al,*next;
    UnLock(dol->dol_Lock);
    al = dol->dol_misc.dol_assign.dol_List;
    while(al) {
        next = al->al_Next;
        UnLock(al->al_Lock);
        FreeVec(al);
        al = next;
    }
    FreeVec(dol->dol_misc.dol_assign.dol_AssignName);
    FreeDosEntry(dol);
\end{verbatim}

The above code reflects the way how resources were originally
allocated by the \emph{dos.library}.
\smallskip{}

If the type is {\tt DLT\_VOLUME}, it is up to the \emph{file system}
to release any resources it allocated along with the {\tt DosList}. It is file
system dependent which resources can or should be released. {\tt
  DosList} entries of this type should only be touched by the
\emph{file system} that created them.
\smallskip{}

This function cannot fail, and it does not touch {\tt IoErr()}.

\section{Creating and Updating Assigns} \label{sec:assigns}
While {\tt MakeDosEntry()}\key{MakeDosEntry()} creates a {\tt DosList}
entry for the \emph{device list}, it only performs minimal
initialization of the structure. For \emph{assigns}, specifically, the
\emph{dos.library} provides specialized functions that allocate,
initialize and enqueue {\tt DosList} structures representing assigns
in a single call and are thus easier to use.

\subsection{Create and Add a Regular Assign}

The {\tt AssignAdd()}\mkey{AssignAdd()} function creates a new assign
to a directory from a \emph{lock}, and then enqueues it into the
\emph{device list}.

\begin{verbatim}
success = AssignLock(name,lock)
D0                    D1   D2

BOOL AssignLock(STRPTR,BPTR)
\end{verbatim}
This function creates a (regular) \emph{assign} onto the directory
identified by {\tt lock}. The \emph{assign} created under the name as
given by {\tt name}. The name shall not include a trailing colon
(``{\tt :}'') that separates the \emph{assign} name from the rest of
the path. The lock shall be a \emph{shared lock}.

If the function is successful, it returns a non-zero result code. The
{\tt lock} is then absorbed into the \emph{assign} and shall no longer
be used by the calling program. On success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and the {\tt lock} remains
available to the caller. {\tt IoErr()}\key{IoErr()} is set to an error code
identifying the cause of the failure.
{\tt ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is
returned if the function run out of memory. If a {\tt DosList} of the
same name (regardless of which type) already exists, the error code is
{\tt ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Create a Non-Binding Assign}

The {\tt AssignPath()}\mkey{AssignPath()} function creates a
\emph{non-binding assign} and adds it to the \emph{device list}. This
type of assign binds to a path independent of the volume the path is
located on; that is, the \emph{assign} resolves to whatever
\emph{volume}, \emph{handler} or even other \emph{assign} matches the
path.

\begin{verbatim}
success = AssignLate(name,path)
D0                    D1   D2

BOOL AssignLate(STRPTR,STRPTR)
\end{verbatim}
This function creates a \emph{non-binding} assign whose name is given
by the first argument, and which resolves to the path given as second
argument, and then adds the \emph{assign} to the \emph{device
  list}. The {\tt name} shall not contain a trailing colon (``{\tt
  :}''). While not a formal requirement of the function or
\emph{non-binding assigns}, the {\tt path} should better be an
absolute path as otherwise resolution of the created \emph{assign} can
be very confusing --- it is then resolved relative to the current
directory of the calling process.

If the function is successful, it returns a non-zero result code. On
success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and {\tt IoErr()}\key{IoErr()} is set to an
error code identifying the cause of the failure. {\tt
  ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is returned if the function run out of
memory. If a {\tt DosList} of the same name (regardless of which type)
already exists, the error code is {\tt ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Create a Late Assign}

The {\tt AssignLate()}\mkey{AssignLate()} function creates a
\emph{late assign} whose target is initially given by a path; but
after its first resolution, the \emph{assign} reverts to a
\emph{regular assigns} such that the target of the \emph{assign} will
point to the same directory of the volume from that point on. This has
the advantage that the target of the assign does not need to be
available at creation time of the assign, yet remains unchanged after
its first usage.

\begin{verbatim}
success = AssignLate(name,path)
D0                    D1   D2

BOOL AssignLate(STRPTR,STRPTR)
\end{verbatim}
This function creates a \emph{late binding assign} of the name {\tt
  name} pointing to {\tt path} as its destination and adds it to the
\emph{device list}. The {\tt name} shall not contain a trailing colon
(``{\tt :}''). While not explicitly required by this function, the
{\tt path} should better be an absolute path as otherwise
resolving the \emph{assign} can be very confusing. The {\tt path}
is then relative to the current directory of the process using
the \emph{assign} the first time.

If the function is successful, it returns a non-zero result code. On
success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and {\tt IoErr()}\key{IoErr()} is
set to an error code identifying the cause of the failure. {\tt
  ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is returned if
the function run out of memory.  If a {\tt DosList} of the same name
(regardless of which type) already exists, the error code is {\tt
  ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Add a Directory to a Multi-Assign}

The {\tt AssignAdd()}\mkey{AssignAdd()} function adds a directory,
identified by a \emph{lock}, to an already existing \emph{regular} or
\emph{multi-assign}. On success, a \emph{regular assign} is then
converted into a \emph{multi-assign}.

\begin{verbatim}
success = AssignAdd(name,lock)
D0                   D1   D2

BOOL AssignAdd(STRPTR,BPTR)
\end{verbatim}
This function adds the {\tt lock} at the end of the target directory
list of the \emph{assign} identified by {\tt name}. The {\tt name}
does not contain a trailing colon (``{\tt :}'').

A {\tt DosList} of the given {\tt name} shall already when entering
this function, and this {\tt DosList} shall be a \emph{regular
  assign}. Attempting to add a directory to a \emph{handler},
\emph{file system}, \emph{volume} or any other type of \emph{assign}
fails.

On success, the function returns a non-zero result code. In such a
case, the {\tt lock} is absorbed into the \emph{assign} and shall no
longer be used by the caller. The \emph{assign} is converted into a
\emph{multi-assign} on access if it is not already one. The {\tt lock}
is added at the end of the directory list, i.e. the new directory is
scanned last when resolving the \emph{assign}.

On error, the function returns $0$ and the {\tt lock} remains
available to the caller. Unfortunately, this function does not set
{\tt IoErr()}\key{IoErr()} consistently, i.e. it is unclear on failure
what caused the error, i.e. whether the function run out of memory,
whether no fitting \emph{device list} entry was found, or whether the
entry found was not a \emph{regular assign}.

\subsection{Remove a Directory From a Multi-Assign}

The {\tt RemAssignList()}\mkey{RemAssignList()} function removes a
directory, represented by a {\tt lock}, from a {\tt multi-assign}. If
only a single directory remains in the \emph{multi-assign}, it is
converted into a \emph{regular assign}. If the \emph{assign} was a
regular assign, and the only directory is removed from it, the
\emph{assign} itself is removed from the \emph{device list} and
released, destroying it and releasing all resources.

\begin{verbatim}
success = RemAssignList(name,lock)
D0                       D1   D2

BOOL RemAssignList(STRPTR,BPTR)
\end{verbatim}
This function removes the directory identified by {\tt lock} from a
\emph{regular} or \emph{multi-assign} identified by {\tt name}. The
name shall not contain a trailing colon (``{\tt :}''). If only a
single directory remains in the \emph{assign}, it is converted to a
\emph{regular assign}. If no directory remains at all, the
\emph{assign} is deleted and removed from the \emph{device list}. The
{\tt lock} remains available to the caller, regardless of the
result code. Note that the {\tt lock} passed in does not need to be
identical to the \emph{lock} contained in the \emph{assign}, but it
needs to be a \emph{lock} on the same directory. This function uses
{\tt SameLock()}\key{SameLock()} function to compare the two locks.

On success, the function returns a non-zero result code in {\tt
  success}.  On error, the function returns $0$. Unfortunately, it
does not set {\tt IoErr()} consistently in all cases, and thus, the
cause of an error cannot be determined upon return. Possible causes
of error are that {\tt name} does not exist, or that it is not a
\emph{assign} or a \emph{multi-assign}.

\chapter{Pattern Matching} \label{sec:patternmatch}
Unlike other operating systems, it is neither the file system nor the shell
that expands wild cards, or patterns. Instead, separate functions exist
that, given a wildcard, scan a directory or an entire directory tree and
deliver all files, links and directories that match a given pattern.
\smallskip{}

The pattern matcher syntax is build on special characters or \emph{tokens}
that define which names to match. The following tokens are currently
defined:
\begin{itemize}
  \item[{\tt ?}] The question mark matches a single, arbitrary character
    within a component. When using the pattern matcher for scanning
    directories, the question mark does not match the component separator,
    i.e. the slash (``{\tt /}) and the colon (``{\tt :}'') that separates
    the path from the device name. Note in particular that the question mark
    also matches the dot (``{\tt .}'') which is not a special character
    under AmigaDOS.
  \item[{\tt \#}] The hash mark matches zero or more repeats of the token
    immediately following it. In particular, the combination ``{\tt \#?}''
    matches zero or more arbitrary characters. If a group of more than one
    token is required to describe which combination needs to match, this
    group needs to be enclosed in brackets.
  \item[{\tt ()}] The brackets bind tokens together forming a single
    token. This is particularly useful for the hash mark {\tt \#} as it
    allows to formulate repeats of longer character or token groups. For
    example, {\tt \#(ab)} indicates zero or more repeats of the character
    sequence {\tt ab}, such as {\tt ab}, {\tt abab} or {\tt ababab}.
  \item[{\tt \textasciitilde{} }] The ASCII tilde (``{\tt \textasciitilde{}}'') matches names that do not
    match the next token. This is particularly valuable for filtering out
    the workbench icon files that end on {\tt .info}, i.e. {\tt \textasciitilde{}(\#?.info)}
    matches all files that do not end with {\tt .info}.
  \item[{\tt[]}] The square brackets (``{\tt []}'') matches a single
    character from a range, e.g. {\tt [a-z]} matches a single alphabetic
    character and {\tt [0-9]} matches a single digit. Multiple ranges and
    individual characters can be combined, for example {\tt [ab]} matches
    the characters {\tt a} and {\tt b}, whereas {\tt [a-cx-z]} matches the
    characters from {\tt a} to {\tt c} and from {\tt x} to {\tt z}. If the
    minus sign (``{\tt -}'') is supposed to be part of the range, it shall
    appear first, directly within the bracket, e.g. {\tt [-a-c]} matches the
    dash and the characters {\tt a} to {\tt c}. If the dash is the last
    character in the range, all characters up to the end of the ASCII range,
    i.e. {\tt 0x7f} match, but none of the extended ISO Latin 1 characters
    match. If the closing square bracket (``{\tt ]}'') is to matched, it
    shall be escaped by an apostroph (``{\tt '}''), i.e. {\tt [[-']]}
    matches the opening and the closing bracket. If the pattern matcher is
    used for scanning directories, the above example does not match the
    slash (``{\tt /}'') even though its code point lies between the
    opening and closing bracket because the slash cannot be part of a
    component name and rather separates components. If the first character
    of the range is an ASCII tilde (``{\tt \textasciitilde{}}''), then the
    character class matches all characters \emph{not} in the class,
    i.e. {\tt [\textasciitilde{}a-z]} matches all characters except
    alphabetic characters. In all other places, the tilde stands for itself.
  \item[{\tt '}] The apostroph ({\tt '}) is the escape character of the
    pattern matcher and indicates that the next character is not a token of
    the matcher, but rather stands for itself. Thus, {\tt '?} matches the
    question mark, and only the question mark, and no other character.
  \item[{\tt \%}] The percent sign (``{\tt \%}'') matches the empty string.
  \item[{\tt |}] The vertical bar (``{\tt |}'') defines alternatives and
    matches the token to its left or the token to its right. The
    alternatives along with the vertical bar shall be enclosed in round
    brackets to bind them, i.e. {\tt (a|b)} is either the character {\tt a}
    or {\tt b} and therefore matches the same strings {\tt [ab]} matches. A
    particular example is {\tt \textasciitilde{}((\#?.info)|.backdrop)}
    which matches all files not used by the workbench for storing
    meta-information. 
\end{itemize}   

\punchline{The Asterisk {\tt *} is not a Wildcard}{Unlike many other
operating systems, the asterisk (``{\tt *}'') has a (two) other meanings
under AmigaDOS. It rather refers to the current console as file name, or
is the escape character for quotation and control sequences; those are
properties AmigaDOS inherits from the BCPL syntax and TRIPOS. While there
is a flag in the \emph{dos.library} that makes the asterisk \emph{also}
available as a wildcard, such usage is discouraged because it can lead to
situations where the asterisk is interpreted differently than intended ---
as it has already two other meanings.}

Pattern matching works in in two steps: In the first step, the pattern is
tokenized into an internal representation, which is then later on used to
perform the actual match of a string against a wildcard. The directory
scanning function {\tt MatchFirst()}\key{MatchFirst()} performs this
conversion internally, and thus no additional preparation is required by the
caller in this case. However, if the pattern matcher is used to search for
strings or wildcards within a text file, the pattern tokenizers {\tt
  ParsePattern()}\key{ParsePattern()} or its case-insensitive counterpart
{\tt ParsePatternNoCase()}\key{ParsePatternNoCase()} shall be called first.

\punchline{Only ISO-Latin Codepoints}{The pre-parsing step that prepares
  from the input pattern its tokenized version uses the code points {\tt
    0x80} to {\tt 0x9f} for tokenized versions of wild-cards and other
  instructions for the pattern matcher. This is identical to the extended
  ISO-Latin control sequence region, and does not represent printable
  characters.  While file names on AmigaDOS \emph{file systems} may in
  principle include such code-points, patterns of the pattern matcher
  \emph{shall not} contain unprintable code points from the region {\tt
    0x00} to {\tt 0x1f} or from {\tt 0x80} to {\tt 0x9f}. These regions are
  reserved for the pattern matcher.}

\section{Scanning Directories}

The prime purpose of the pattern matcher is to scan a directory, or even a
tree of directories, identifying all \emph{file system} objects such as
files, links or directories that match a given pattern. The pattern matcher
can even descend recursively into sub-directories if instructed to do
so. This service is used by many shell commands stored in the {\tt C:}
\emph{assign}. The directory scanner requires the following steps:
\smallskip{}

First, the user shall provide an {\tt AnchorPath} structure. This structure
contains the state of the directory matcher, including the {\tt
  FileInfoBlock}\key{FileInfoBlock} structure of the matched object. This
structure is defined in section~\ref{sec:fib}. Optionally, the {\tt
  AnchorPath} structure may also contain the complete (relative) path of the
matched object. This structure shall then be initialized, setting all flags
required, see below for their definition.

\punchline{Must be Long-Word Aligned}{As the {\tt AnchorPath} structure
  embeds a {\tt FileInfoBlock} structure that requires long-word alignment,
  the {\tt AnchorPath} structure shall be aligned to long-word boundaries as
  well. The simplest way to ensure this is to allocate it with either {\tt
    AllocMem()} or {\tt AllocVec()}, see also section~\ref{sec:bptrs}.}

Then, with the initialized {\tt AnchorPath} structure, {\tt MatchFirst()}
shall be called, returning the first match of the pattern if there is
any. The {\tt AnchorPath} structure then contains all information on the
found match.
\smallskip{}

If there is any match, and the match is a directory the caller wants to
enter recursively, the {\tt APF\_DODIR} flag of the {\tt AnchorPath}
structure may be set. Then, {\tt MatchNext()} may be called to continue the
scan, potentially entering this directory. Once the end of a recursively
entered directory has been reached, {\tt MatchNext()} sets the {\tt
  APF\_DIDDIR} flag, then reverts back to the parent directory continuing
the scan there. As {\tt APF\_DIDDIR} is never cleared by the pattern
matcher, the caller should clear it once the end of a sub-directory had been
noticed.
\smallskip{}

The above iterative procedure of {\tt MatchNext()} may continue, either
until the user or the running program requests termination, or until {\tt
  MatchNext()} returns an error. Then, finally, the scan is aborted and all
resources but the {\tt AnchorPath} structure shall be released by calling
{\tt MatchNext()}.
\medskip{}

The {\tt AnchorPath} structure is defined in {\tt dos/dosasl.h} and looks as
follows:

\mkey{AnchorPath}
\begin{verbatim}
struct AnchorPath {
        struct AChain   *ap_Base;
#define ap_First ap_Base
        struct AChain   *ap_Last;
#define ap_Current ap_Last
        LONG    ap_BreakBits;
        LONG    ap_FoundBreak;
        BYTE    ap_Flags;
        BYTE    ap_Reserved;
        WORD    ap_Strlen;
        struct  FileInfoBlock ap_Info;
        UBYTE   ap_Buf[1];
};
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt ap\_Base} and {\tt ap\_Last} are pointers to an {\tt AChain} structure
that is also defined in {\tt dos/dosasl.h}. This structure is allocated and
released by the \emph{dos.library}, transparently to the caller. The {\tt
  AChain} structure describes a directory in the potentially recursive scan
through a directory tree. {\tt ap\_Base} describes the topmost directory at
which the scan started, whereas {\tt ap\_Last} describes the directory which
is currently being scanned.
\smallskip{}

The {\tt AChain} structure is also defined in {\tt dos/dosasl.h}:

\mkey{AChain}
\begin{verbatim}
struct AChain {
	struct AChain *an_Child;
	struct AChain *an_Parent;
	BPTR	an_Lock;
	struct FileInfoBlock an_Info;
	BYTE	an_Flags;
	UBYTE	an_String[1];
};
\end{verbatim}

{\tt an\_Child} and {\tt an\_Parent} are only used internally and shall not
be interpreted by the caller.
\smallskip{}

{\tt an\_Lock} is a lock to the directory described by this {\tt AChain}
structure. In particular, {\tt ap\_Last->an\_Lock} is a \emph{lock} to the
directory that is currently being scanned, and {\tt ap\_Base->an\_Lock} a
lock to the topmost directory at which the scan started. These two locks
have been obtained and will be unlocked by the \emph{dos.library}; they may
be used by the caller provided they are not unlocked manually.
\smallskip{}

{\tt an\_Info} is only used internally and is the {\tt
  FileInfoBlock}\key{FileInfoBlock} of the directory being describes by the
{\tt AChain} structure, see section~\ref{sec:fib}.
\smallskip{}

{\tt an\_Flags} is only used internally, and {\tt an\_String} can contain
potentially the path to the directory; both shall not be modified or
interreted by the caller.
\medskip{}

{\tt ap\_BreakBits} of the {\tt AnchorPath} structure shall be initialized
to the signal mask upon which {\tt MatchNext()} aborts a directory
scan. This is typically a combination of signal masks found in
{\tt dos/dos.h}, e.g. {\tt SIGBREAKF\_CTRL\_C} to abort on {\tt Ctrl-C} in
the console.
\smallskip{}

{\tt ap\_FoundBreak} contains, if {\tt MatchNext()} aborts with
{\tt ERROR\_BREAK}, the signal mask that caused the abortion.
\smallskip{}

{\tt ap\_Flags} contains multiple flags that can be set or inspected by the
caller while scanning a directory. In particular:
\smallskip{}

{\tt APF\_DOWILD} while documented, is not used nor set at all by the
pattern matcher.
\smallskip{}

{\tt APF\_ITSWILD} is set by {\tt MatchFirst()} if the pattern includes a
wildcard and more than a single \emph{file system} object may
match. Otherwise, no directory scan is performed. The user may also set this
flag to enforce a scan. This may resolve situations in which matching an
explicit path without a wildcard is not possible because the object is
locked exclusively.
\smallskip{}

{\tt APF\_DODIR} may be set or reset by the caller of {\tt MatchNext()} to
enforce entering a directory recursively, or avoid entering a
directory. This flag is cleared by {\tt MatchNext()} when entering a
directory, and it shall only be set by the caller if a match describes a
directory.
\smallskip{}

{\tt APF\_DIDDIR} is set by {\tt MatchNext()} if the end of a recursively
entered directory has been reached, and thus the parent directory is
re-entered. As this flag is never cleared by the pattern matcher, it should
be cleared by the caller.
\smallskip{}

{\tt APF\_NOMEMERR} is an internal flag that should not be interpreted; it
is set if an error is encountered while scanning a directory. It is not
necessarily restricted to memory allocation errors.
\smallskip{}

{\tt APF\_DODOT} is, even though documented, not actually used.
\smallskip{}

{\tt APF\_DirChanged} is a flag that is set by {\tt MatchNext()} if the
scanned directory changes, either by entering a directory recursively, or by
leaving a directory. It is also cleared if the directory is the same as in
the previous call.
\smallskip{}

{\tt APF\_FollowHLinks} may be set by the caller to indicate that hard links
to directories shall be followed, and such directories shall be recursively
entered if {\tt APF\_DODIR} is set as well. Otherwise, hard links to
directories are not entered. Softlinks are neither entered, this this cannot
be changed by any flag. A potential danger of links is that they may cause
endless recursion if a link within a directory points to a parent
directory. Thus, callers should be aware of such situations and store
directories that have already been analyzed. Otherwise, it is safer to keep
this flag cleared.
\medskip{}

{\tt ap\_Strlen} is the size of the buffer {\tt ap\_Buf} that contains the
full path of the matched entry. This buffer shall be allocated by the user
at the end of the {\tt AnchorPath} structure. Unlike what the name suggests,
this is not a string length, but the byte size of the buffer, including the
terminating {\tt NUL} byte of a string. If the full path of the match does
not fit into this buffer, it is truncated \emph{without} proper string
termination and the error code {\tt ERROR\_BUFFER\_OVERFLOW} is returned. If
the full path is not required, this member shall be set to~$0$.
\smallskip{}

{\tt ap\_Info} contains the {\tt FileInfoBlock}\key{FileInfoBlock} of the
matched entry, including all metadata the file system has available for
it. Note that {\tt fib\_FileFile} only contains the name of the object, not
its full path.
\smallskip{}

{\tt ap\_Buf} is filled with the full path to the matched object if {\tt
  ap\_Strlen} is non-zero. This buffer shall be allocated by the caller at
the end of the {\tt AnchorPath} structure, i.e. for a buffer of $l$ bytes,
in total {\tt sizeof(AnchorPath)+l-1} bytes are required to store the
structure and the buffer. The byte size of this additional buffer shall be
placed in {\tt ap\_Strlen}. If this buffer is not required, {\tt ap\_Strlen}
shall be set to~$0$.

\subsection{Starting a Directory Scan}

The {\tt MatchFirst()}\mkey{MatchFirst()} function starts a directory scan,
locating all objects matching a pattern and potentially entering directories
recursively.

\begin{verbatim}
error = MatchFirst(pat, AnchorPath)
D0                 D1       D2

LONG MatchFirst(STRPTR, struct AnchorPath *)
\end{verbatim}

This function starts a directory scan, locating all objects matching the
pattern {\tt pat}. This pattern does \emph{not} require pre-parsing
(e.g. the functions in section~\ref{sec:stringpat}), {\tt MatchFirst()}
performs the parsing.
\smallskip{}

{\tt AnchorPath} shall be a pointer to an {\tt AnchorPath} structure
allocated and initialized by the caller. In particular, {\tt ap\_BreakBits}
shall be initialized to a signal mask on which the scan terminates, {\tt
  ap\_FoundBreak} to~$0$, and {\tt ap\_Strlen} to the size of the buffer
{\tt ap\_Buf} which is filled by the path name of the matching objects. If
this path name is not required, {\tt ap\_Strlen} shall be set to~$0$. {\tt
  ap\_Flags} shall be set to the flags you need, see the parent section.
\smallskip{}

Unlike many other functions, {\tt MatchFirst()} returns an error code
directly, and not a success/failure indicator. That is,~$0$ indicates
success. In particular, if {\tt ERROR\_BREAK} is returned in case any of the
signal bits in {\tt ap->ap\_BreakBits} have been received during the scan.
\smallskip{}

On success, {\tt ap->ap\_Info.fib\_FileName} contains the name of the first
matched object, the directory represented as a \emph{lock} containing the
object is available in {\tt ap->ap\_Current->an\_Lock}. You would typically set
the current directory to this lock, then access this object, then revert the
lock. This lock \emph{shall not} be released; this is performed by the
pattern matcher itself as needed.
\smallskip{}

If the full path of the matching object is needed, an additional buffer
shall be allocated at the end of the {\tt AnchorPath}, and the size of the
buffer shall be placed into {\tt ap\_Strlen}. The function then fills in the
path into {\tt ap\_Buf}.
\smallskip{}

If the matching object is a directory, i.e.
{\tt ap->ap\_Info.fib\_DirEntryType} is positive and not equal to
{\tt ST\_SOFTLINK}, the caller may request to enter this directory
by setting {\tt APF\_DODIR} in {\tt ap->ap\_Flags}.

\subsection{Continuing a Directory Scan}

The {\tt MatchNext()}\mkey{MatchNext()} function continues a directory scan
initiated by {\tt MatchFirst()}\key{MatchNext()}, returning the next
matching object, or an error.

\begin{verbatim}
error = MatchNext(AnchorPath)
D0                    D1

LONG MatchNext(struct AnchorPath *)
\end{verbatim}

This function takes an existing {\tt AnchorPath} structure, as prepared by a
previous {\tt MatchFirst()} or {\tt MatchNext()} function, and finds the
next matching object. Unlike most other functions of the \emph{dos.library},
this function returns an error code on failure and~$0$ for success. It does
\emph{not} return a boolean success indicator. In particular, if
{\tt ERROR\_BREAK} is returned in case any of the signal bits in
{\tt ap->ap\_BreakBits} have been received.
\smallskip{}

As for {\tt MatchFirst()}, this call fills {\tt ap->ap\_Info} with meta
information on the found object, in particular its file name, and
{\tt ap->ap\_Current->an\_Lock} the lock of the directory containing the
object. As for {\tt MatchFirst()}, {\tt APF\_DODIR} can be set to enter
directories recursively, and {\tt ap->ap\_Buf} will be filled with the
full path of the found object if {\tt ap->ap\_Strlen} is non-zero.

\subsection{Terminating a Directory Scan}

The {\tt MatchEnd()}\mkey{MatchEnd()} function terminates a running scan,
and releases all resources associated with the scan. It does not release the
{\tt AnchorPath} structure.

\begin{verbatim}
MatchEnd(AnchorPath)
             D1

VOID MatchEnd(struct AnchorPath *)
\end{verbatim}

This function ends a directory scan started by
{\tt MatchFirst()}\key{MatchFirst()} and releases all resources associated
to the scan. This function shall be called regardless whether the scan is
aborted due to exhaustion (i.e. {\tt ERROR\_NO\_MORE\_ENTRIES}, by error, or
by choice of the scanning program (i.e. the desired object has been detected
and no further matches are required).

\section{Matching Strings against Patterns} \label{sec:stringpat}

While the prime purpose of the pattern matcher is to scan directories, it
can also be used to check whether an arbitrary string matches a wildcard,
for example to scan for a pattern within a text document. This requires two
steps: In the first step, the wildcard is preparsed, generating a tokenized
version of the pattern. The second step checks whether a given input string
matches the pattern. You would typically tokenize the pattern once, and then
use it to match multiple strings to the pattern.
\smallskip{}

Two versions of the tokenizer and pattern matcher exist: One pair that is
case-sensitive, and the second pair is case-insensitive. Note that AmigaDOS
file names are case-insensitive, so the {\tt MatchFirst()}\key{MatchFirst()}
and {\tt MatchNext()}\key{MatchNext()} functions internally only use the
second pair.
\smallskip{}

The buffer for the tokenized version of the pattern shall be allocated by
the caller. It requires a buffer that is at least {\tt 2 + (n << 1)} bytes
large, where $n$ is the length of the input wildcard. 

\subsection{Tokenizing a Case-Sensitive Pattern}

The {\tt ParsePattern()}\mkey{ParsePattern()} function tokenizes a pattern
for case-sensitive string matching. This tokenized version is then later on
used to test a string for a match.

\begin{verbatim}
IsWild = ParsePattern(Source, Dest, DestLength)
d0                      D1     D2      D3

LONG ParsePattern(STRPTR, STRPTR, LONG)
\end{verbatim}

This function tokenizes a wildcard pattern in {\tt Source}, generating a
tokenized version of the pattern in {\tt Dest}. The size (capacity) of the
target buffer is {\tt DestLength} bytes. This size shall be at least
{\tt 2 + (n << 1)} bytes large, where {\tt n} is the length of the input
pattern. However, as future implementations can require larger buffers, the
result code shall be checked nevertheless for error conditions. The result
code {\tt IsWild} is one of the following:
\smallskip{}

{\tt 1} is returned if the source contained wildcards.
\smallskip{}

{\tt 0} is returned if the source contains no wildcards. In this case, the
tokenized pattern may still be used to match a string against the pattern,
though a simple string comparison would also work.
\smallskip{}

{\tt -1} is returned in case of an error, either because the input pattern
is ill-formed, or because {\tt DestLength} is too short. In such a case,
{\tt IoErr()} should be used to obtain the reason of the failure.

\subsection{Tokenizing a Case-Insensitive Pattern} \label{sec:parsepatternnocase}

The {\tt ParsePatternNoCase()}\mkey{ParsePatternNoCase()} function tokenizes
a pattern for case-insensitive string matching. This tokenized version is then
later on used to test a string for a match. This version is suitable for
matching file names, but is otherwise similar to {\tt
  ParsePattern()}\key{ParsePattern()}.

\begin{verbatim}
IsWild = ParsePatternNoCase(Source, Dest, DestLength)
d0                            D1     D2      D3

LONG ParsePatternNoCase(STRPTR, STRPTR, LONG)
\end{verbatim}

This function tokenizes a wildcard pattern in {\tt Source}, generating a
tokenized version of the pattern in {\tt Dest}. The size (capacity) of the
target buffer is {\tt DestLength} bytes. This size shall be at least
{\tt 2 + (n << 1)} bytes large, where {\tt n} is the length of the input
pattern. However, as future implementations can require larger buffers, the
result code shall be checked nevertheless for error conditions. The result
code {\tt IsWild} is one of the following:
\smallskip{}

{\tt 1} is returned if the source contained wildcards.
\smallskip{}

{\tt 0} is returned if the source contains no wildcards. In this case, the
tokenized pattern may still be used to match a string against the pattern,
though a simple case-insensitive string comparison would also work.
\smallskip{}

{\tt -1} is returned in case of an error, either because the input pattern
is ill-formed, or because {\tt DestLength} is too short. In such a case,
{\tt IoErr()} should be used to obtain the reason of the failure.

\subsection{Match a String against a Pattern}

The {\tt MatchPattern()}\mkey{MatchPattern()} function matches an input
string against a tokenized pattern, in a case sensitive way.

\begin{verbatim}
match = MatchPattern(pat, str)
D0                   D1   D2

BOOL MatchPattern(STRPTR, STRPTR)
\end{verbatim}

This function matches the string {\tt str} against the tokenized pattern
{\tt pat}, returning an indicator whether the string matches the
pattern. This function is case-sensitive. The pattern {\tt pat} shall have
been tokenized by {\tt ParsePattern()}.
\smallskip{}

The result code {\tt match} is non-zero in case the string matches, or~$0$
in case either the string did not match, or the function run out of
stack. The latter two cases can be distinguished by {\tt
  IoErr()}\key{IoErr()}. In case the string did not match, {\tt IoErr()}
returns~$0$, or a non-zero error code otherwise. A possible error code is
{\tt ERROR\_TOO\_MANY\_LEVELS} indicating that the pattern matcher run out
of stack due to too many levels of recursion.
\smallskip{}

The caller shall have at least~$1500$ bytes of stack space available to
avoid race conditions, despite the function checking for out-of-stack
conditions.

\subsection{Match a String against a Pattern ignoring Case}

The {\tt MatchPatternNoCase()}\mkey{MatchPatternNoCase()} function matches
an input string against a tokenized pattern ignoring the case.

\begin{verbatim}
match = MatchPatternNoCase(pat, str)
D0                         D1   D2

BOOL MatchPatternCase(STRPTR, STRPTR)
\end{verbatim}

This function matches the string {\tt str} against the tokenized pattern
{\tt pat}, returning an indicator whether the string matches the
pattern. This function is case-insensitive. The pattern {\tt pat} shall have
been tokenized by {\tt ParsePatternNoCase()}.
\smallskip{}

The result code {\tt match} is non-zero in case the string matches, or~$0$
in case either the string did not match, or the function run out of
stack. The latter two cases can be distinguished by
{\tt IoErr()}\key{IoErr()}. In case the string did not match, {\tt IoErr()}
returns~$0$, or a non-zero error code otherwise. A possible error
code is {\tt ERROR\_TOO\_MANY\_LEVELS} indicating that the pattern matcher
run out of stack due to too many levels of recursion.
\smallskip{}

The caller shall have at least~$1500$ bytes of stack space available to
avoid race conditions, despite the function checking for out-of-stack
conditions.

\chapter{Processes} \label{sec:process}

\emph{Processes}\mkey{Process} are extensions of exec \emph{tasks}, and as
such scheduled by exec. The most important extensions are that processes
include a message port in the form of a \emph{MsgPort} structure for
inter-process communication to \emph{handlers}, a current directory to
resolve relative paths, and the last input/output error as returned by the
{\tt IoErr()}\key{IoErr()} function.
\smallskip{}

\emph{Processes} are represented by the {\tt Process} structure documented
in {\tt dos/dosextens.h}. It reads as follows:
\begin{verbatim}
struct Process {
    struct  Task    pr_Task;
    struct  MsgPort pr_MsgPort;
    WORD    pr_Pad;
    BPTR    pr_SegList;
    LONG    pr_StackSize;
    APTR    pr_GlobVec;
    LONG    pr_TaskNum;
    BPTR    pr_StackBase;
    LONG    pr_Result2;
    BPTR    pr_CurrentDir;
    BPTR    pr_CIS;
    BPTR    pr_COS;
    APTR    pr_ConsoleTask;
    APTR    pr_FileSystemTask;
    BPTR    pr_CLI;
    APTR    pr_ReturnAddr;
    APTR    pr_PktWait;	
    APTR    pr_WindowPtr;

    /* following definitions are new with 2.0 */
    BPTR    pr_HomeDir;
    LONG    pr_Flags;
    void    (*pr_ExitCode)();
    LONG    pr_ExitData;
    UBYTE   *pr_Arguments;
    struct MinList pr_LocalVars;
    ULONG   pr_ShellPrivate;
    BPTR    pr_CES;
};  /* Process */
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt pr\_Task} is the exec task structure defined in {\tt exec/tasks.h}. It
is required by the exec scheduler. The only difference between an exec {\tt
  Task} and a {\tt Process} is that {\tt pr\_Task.tc\_Node.ln\_Type} is set
to {\tt NT\_PROCESS} instead to {\tt NT\_TASK}. Prior starting the process,
the \emph{dos.library} also pushes the stack size onto the stack, i.e. {\tt
  (ULONG *)(pr\_Task.tc\_Upper)[-1]} contains the size of the stack in
bytes. Some binaries, in particular those compiled with the Aztec (Manx)
compiler depend on this value.
\smallskip{}

{\tt pr\_MsgPort} is a message port structure as defined in {\tt
  exec/ports.h}. This port is used by many functions of the
\emph{dos.library} to communicate with \emph{handlers} and \emph{file
systems}. Details of the communication protocol are given in
section~\ref{sec:handlers}.
\smallskip{}

{\tt pr\_Pad} is unused and only included in the structure to ensure that
all following members are aligned to 32-bit boundaries.
\smallskip{}

{\tt pr\_SegList} contains an array of \emph{segments} containing
AmigaDOS functions. The first entry in this array is a 32-bit integer
indicating the number of valid elements, the remaining entries are
\emph{BPTRs} to segments of AmigaDOS and the loaded binary. Some
entries may be {\tt ZERO} indicating that the corresponding entry is
currently not used. Segments are explained in more detail in
section~\ref{sec:segments}. Typically, entries $1$ and $2$ are system
segments containing AmigaDOS functions, entry $3$ is used for the
loaded binary, and entry $4$ the segment of the shell. This, however,
only reflects the current usage of segments, and later versions of
AmigaDOS may populate this vector differently. The segments contained
in this vector are used by the AmigaDOS runtime binder to build the
\emph{Global Vector}\key{Global Vector} of processes using BCPL
linkage. As BPCL is phased out, this vector is of no particular
importance today anymore, and can be ignored for almost all
purposes. The only exception is the \emph{Shell} which shall prepare
this vector to ensure that commands written in BCPL function
properly. More on this in section~\ref{sec:shell}.

{\tt pr\_StackSize} is the size of the process stack in bytes. It is always
a multiple of 4 bytes long.
\smallskip{}

{\tt pr\_GlobVec} is another BCPL legacy. It contains the \emph{Global
  Vector} of the process. For binaries using the BCPL linkages, this
is a custom-build array of global data and function entry points from
{\tt pr\_SegList}. For C and assembler binaries, the \emph{Global
  Vector}\key{Global Vector} is the system shared vector; it contains
\emph{dos.library} global data required by some of its functions, such
as base pointers to system libraries. As no particular advantage can
be taken from this vector (anymore) as all functions available in it
are also available as \emph{dos.library} entry points, it should be
left alone.
\smallskip{}

{\tt pr\_TaskNum} is an integer allocated by the system for processes that
execute a shell, or are binaries that have been launched by the shell. The
number here corresponds to the integer printed by the {\tt Status}
command. Note that AmigaDOS does not use task numbers consistently,
i.e. processes that are started from the workbench or have been created by
some other means are not identified by a task number. In such a case, this
member remains~$0$.
\smallskip{}

{\tt pr\_StackBase} is a \emph{BPTR} to the address of the lower end of the
stack, i.e. the end of the C or assembler stack. As the BCPL stack grows in
opposide direction, it is the start of the BCPL stack. While it is
initialized, it is not used by the \emph{dos.library} at all.
\smallskip{}

{\tt pr\_Result2} is the secondary result code set by many functions of the
\emph{dos.library}. The value stored here is delivered by {\tt IoErr()}\key{IoErr()}.
\smallskip{}

{\tt pr\_CurrentDir} is the \emph{lock} representing the current directory
of the process. All relative paths are resolved from this \emph{lock},
i.e. they are relative to {\tt pr\_CurrentDir}. If this member is {\tt ZERO},
the current directory is the root directory of the file system stored in
{\tt pr\_FileSystemTask}. As the latter is (unless altered) the file system
of the boot volume, this is usually identical to the directory identified by
the {\tt SYS} assign.
\smallskip{}

{\tt pr\_CIS} is \emph{file handle} of the standard input stream of the
process. It is also returned by {\tt Input()}\key{Input()}. It can be {\tt
  ZERO} in case the process does not have a standard input stream. This is
\emph{not} equivalenqt to a {\tt NIL:} input handle --- in fact, any attempt
to read from a non-existing input stream will crash. Processes started from
the workbench do not have an input stream, unless one is installed here with
{\tt SelectInput()}\key{SelectInput()}.
\smallskip{}

{\tt pr\_COS} is the \emph{file handle} of the standard output stream of the
process. It is also returned by the {\tt Output()}\key{Output()} function of
the \emph{dos.library}. It can be {\tt ZERO} in case the process does not
have a standard output stream, which is not equivalent to a {\tt NIL:} file
handle. Any attempt to output to {\tt ZERO} will crash the system. Processes
started from the workbench do not have an output stream, unless one is
installed with {\tt SelectOutput()}\key{SelectOutput()}.
\smallskip{}

{\tt pr\_ConsoleTask} is the \emph{MsgPort} of the console within which this
process is run, if such a console exists. This \emph{handler} is contacted
when opening ``{\tt *}'' or a path relative to {\tt CONSOLE:}. Processes
started from the workbench do not have a console, unless one is installed
with {\tt SetConsoleTask()}\key{SetConsoleTask()}.
\smallskip{}

{\tt pr\_FilesSystemTask} is the \emph{MsgPort} of the file system that is
contacted in case a relative path is to be resolved relative to the {\tt
  ZERO} lock. This member is initialized to the \emph{MsgPort} of the file
system the system was booted from, but can be changed by {\tt
  SetFileSysTask()}\key{SetFileSysTask()}. This member is also returned by
{\tt GetFileSysTask()}\key{SetFileSysTask()}.
\smallskip{}

{\tt pr\_CLI} is a \emph{BPTR} to the {\tt CommandLineInterface}
\key{CommandLineInterface} structure containing information on the Shell
this process is running in. If this process is not part of a Shell, this
member is {\tt ZERO}. This is for example the case for programs started from
the workbench, or \emph{handler} or \emph{file system}.
\smallskip{}

{\tt pr\_ReturnAddr} is another \emph{BCPL} legacy and should not be used by
new implementations. It points to the BCPL stack frame of the process or the
command overloading the process, and used there to restore the previous
stack frame for the {\tt Exit()}\key{Exit()} function. This is typically the
process cleanup code for processes initialized by {\tt
  CreateProc()}\key{CreateProc()} or {\tt
  CreateNewProc()}\key{CreateNewProc()}, or the shell command shutdown code
placed there by {\tt RunCommand()}. This cleanup process does not, however,
release any other resources obtained by user code. BCPL code or custom
startup code could deposit here pointer to a BCPL stack frame for a custom
shutdown mechanism.
\smallskip{}

The BCPL stack frame is described by the following (undocumented) structure:
\mkey{BCPL stack frame}
\begin{verbatim}
struct BCPLStackFrame {
       ULONG bpsf_StackSize;
       APTR  bpsf_PreviousStack;
};
\end{verbatim}
where {\tt bpsf\_StackSize} is the stack size of the current (active) stack,
and {\tt bpsf\_PreviousStack} the stack of the caller; to restore the
previous stack, this value is placed in the CPU register {\tt A7}.
\medskip{}

{\tt pr\_PktWait} is a function that is called when waiting for
inter-process communication, in particular when waiting for a returning
packet set out to a handler. If this is {\tt NULL}, the system default
function is used.  The signature of this function is
\begin{verbatim}
msg = (*pr_PktWait)(void)
D0

struct Message *(*pr_PktWait)(void)
\end{verbatim}

that is, no particular arguments are delivered, the process must be obtained
from {\tt exec}, and the message received shall be delivered back into
register {\tt D0}. The returned pointer shall not be {\tt NULL}, rather,
this function shall block until a message has been received. For details,
see the {\tt DoPkt()}\key{DoPkt()} function and section~\ref{sec:handlers}.
\smallskip{}

{\tt pr\_WindowPtr} is, unlike what the name suggests, a pointer to an
\emph{intuition} {\tt Screen} structure, see {\tt intuition/screens.h}, on
which error requesters will appear. If this is {\tt NULL}, error requesters
appear on the workbench screen, and if this is set to {\tt (APTR)(-1L)},
error requesters will be suppressed at all, and the implied response to them
is to cancel the operation. This error requester is specified in more detail
with the {\tt ErrorReport()}\key{ErrorReport()} function.
\smallskip{}

{\tt pr\_HomeDir} is the \emph{lock} to the directory containing the binary
that is currently executed as this process, if such a directory exists. It
is {\tt ZERO} if the binary is resident. This \emph{lock} is filled in by
the Shell or the Workbench when loading and starting a process. It is used
to resolve paths relative to the {\tt PROGDIR} pseudo-assign, see
section~\ref{table:specialassigns}. If this lock is {\tt ZERO}, any attempt
to resolve a path within {\tt PROGDIR:} will create a request to inserted a
volume {\tt PROGDIR:}, which is probably not a very useful reaction of
AmigaDOS.
\smallskip{}

{\tt pr\_Flags} are system-use only flags that shall not be used or
interpreted. They are used by the system process shutdown code to identify
which resources need to be released, but future systems may find additional
uses for this member.
\smallskip{}

{\tt pr\_ExitCode()} is a pointer to a function that is called by AmigaDOS
as part of the process shutdown code, and as such quite more useful that
{\tt pr\_ReturnAddr}. The function prototype is as follows:

\begin{verbatim}
returncode = ExitFunc(rc,exitdata)
D0                    D0 D1

LONG ExitFunc(LONG,LONG)
\end{verbatim}

The value of {\tt rc} is the return code process, i.e. the value left in
register {\tt D0} when the code drops off the final {\tt RTS}, and {\tt
  exitdata} is taken from {\tt pr\_ExitData}. The {\tt returncode} is a
modified version of the process return code that is, however, ignored.
\smallskip{}

{\tt pr\_ExitData} is used as argument for the {\tt pr\_ExitCode()}
function, see above.
\smallskip{}

{\tt pr\_Arguments} is a pointer to the command line arguments of the
process if it corresponds to a command started from the Shell. This is a
{\tt NUL} terminated string. This argument string can also be found in
register {\tt A0} for programs started from the Shell, or in the buffer of
{\tt pr\_CIS}. The {\tt ReadArgs()}\key{ReadArgs()} function takes it from
the latter source, and not from {\tt pr\_Arguments}. Otherwise, this member
remains {\tt NULL}.
\smallskip{}

{\tt pr\_LocalVars} is a {\tt MinList} structure, as defined in {\tt
  exec/lists.h}, that contains local variables specific to the shell within
which the process is executed, if any. The structure of such variables is
defined in {\tt dos/var.h}. This structure is specified in
section~\ref{sec:shell}.
\smallskip{}

{\tt pr\_ShellPrivate} is reserved for the Shell and its value shall not be
used, modified or interpreted. It is currently unused, but can be used by
future releases.
\smallskip{}

{\tt pr\_CES} is the \emph{file handle} to be used for error output. This
stream gues usually to the console the process runs in, if such a console
exists. This handle can be changed by {\tt SelectError()}\key{SelectError()}.
If {\tt pr\_CES} is {\tt NULL}, processes should fall back to {\tt pr\_COS}
for printing errors. Preferably, processes should use the
{ErrorOutput()}\key{ErrorOutput()} function to obtain an error stream,
though.

\section{Creating and Terminating Processes}

AmigaDOS provides several functions to create functions: {\tt
  CreateNewProc()}\key{CreateNewProc()} is the revised and most flexible
function for launching a process, taking many parameters in the form of a
tag list. The legacy function{\tt CreateProc()}\key{CreateProc()} supports
less options, but available under all Os versions. Shells as created by the
{\tt System()}\key{System()} function implicitly also create processes, but
are not discussed here, but in section~\ref{sec:shell}. Therefore, {\tt
  System()} shares a couple of options with {\tt CreateNewProc()}.
\smallskip{}

There is surprisingly not a single function to delete processes. Processes
die whenever their execution drops off at the end of the {\tt main()}
function, or whenever execution reaches the final {\tt RTS} instruction of
the main program function. The {\tt Exit()}\key{Exit()} function also
terminates a process, but shall be called from within the process, and is
typically not suitable as it does not release resources acquired by the
program itself, but only those allocated by the system itself.

\subsection{Creating a New Process from a TagList} \label{sec:createnewproc}

The {\tt CreateNewProc()}\mkey{CreateNewProc()} function takes a {\tt
  TagItem} array as defined in {\tt utility/tagitem.h} and launches a new
process from this list. The tags this function takes are defined in {\tt
  dos/dostags.h}.

\begin{verbatim}
process = CreateNewProc(tags)
D0                       D1

struct Process *CreateNewProc(struct TagItem *)

process = CreateNewProcTagList(tags)
D0                              D1

struct Process *CreateNewProcTagList(struct TagItem *)

process = CreateNewProcTags(Tag1, ...)

struct Process *CreateNewProcTags(ULONG, ...)
\end{verbatim}

The above functions are all equivalent, just the calling conventions are
different. For {\tt CreateNewProcTags()}, the {\tt TagList} is created by
the compiler on the stack and a pointer is then implicitly passed into the
function. The following tags are recognized by the function:
\smallskip{}

{\tt NP\_Seglist} takes a \emph{BPTR} to a segment list as returned by {\tt
  LoadSeg()} and launches the process at the first byte of the first segment
of the list.
\smallskip{}

{\tt NP\_FreeSeglist} is a boolean indicator that defines whether the
segment provided to {\tt NP\_Seglist} is released when the process
terminates. Unlike what the official documentation claims, the default value
of this tag is {\tt DOSFALSE}, i.e. the segment is \emph{not} released.
\smallskip{}

{\tt NP\_Entry} is mutually exclusive to {\tt NP\_Seglist} and defines an
absolute address (and not a segment) as entry point of the process to be
created. If this tag is provided, then {\tt NP\_FreeSeglist} shall
\emph{not} be set a non-zero value. Either {\tt NP\_Entry} or {\tt
  NP\_Seglist} shall be included.
\smallskip{}
     
{\tt NP\_Input} sets the input file handle, i.e. {\tt pr\_CIS} of the
process to be created. This tag takes a \emph{BPTR} to a \emph{file
handle}. The default is \emph{not} to set the input file handle, e.g. to
leave it {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseInput} selects whether the input file handle, if provided,
will be closed when the process terminates. If non-zero, the input file handle
will be closed, otherwise it remains opened. The default is to close the
input file handle.
\smallskip{}

{\tt NP\_Output} sets the output file handle, i.e. {\tt pr\_COS} of the
process to be created. This tag takes a \emph{BPTR} to a \emph{file
handle}. The default is to leave the output at {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseOutput} selects whether the output file handle, if
provided, will be closed when the process terminates. If non-zero, the
output file handle will be closed, otherwise it remains open. The default is
to close the output file handle.
\smallskip{}

{\tt NP\_Error} sets the error file handle, i.e. {\tt pr\_CES} of the
process to be created. This tag also takes a \emph{BPTR} to a \emph{file
handle}. The default is to leave the error output handle at {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseError} selects whether the rror file handle, if provided, will
be closed when the process terminates. If non-zero, the error file handle
will be closed, otherwise it remains open. The default is \emph{not} to
close the error file handle. This (different) default is to ensure backwards
compatibility.
\smallskip{}

{\tt NP\_CurrentDir} sets the current directory of the process to be
created. The argument is a \emph{Lock}. The default is to duplicate the
current directory of the caller with {\tt DupLock()}\key{DupLock()} if the
caller is a process, or leave the current directory at {\tt ZERO}.
The current directory of the process, i.e. {\tt pr\_CurrentDir}, is released
when the process terminates, unless {\tt NP\_CurrentDir} is set to {\tt ZERO}. 
\smallskip{}

{\tt NP\_StackSize} sets the stack size of the process to be created in
bytes. The default is a stack size of $4000$ bytes.
\smallskip{}

{\tt NP\_Name} is a pointer to a {\tt NUL} terminated string to which the
task name of the process to be created is set. This string is copied before
the process is launched, and the copy is released automatically when the
process terminates. The default process name is ``{\tt New Process}''.
\smallskip{}

{\tt NP\_Priority} sets the priority of the process to be created. The tag
value shall be an integer in the range~$-128$ to~$127$, though useful values
are in the range of~$0$ to~$20$. The default is~$0$.
\smallskip{}

{\tt NP\_ConsoleTask} specifies a pointer to a \emph{MsgPort} to the handler
that is responsible for the console of the process to be created. That is,
if the created process opens ``{\tt *}'' or a path relative to {\tt
  CONSOLE:}, it will use the specified handler. The default is to use the
console handler if the caller is a process, or {\tt NULL} if the caller is 
only a task.
\smallskip{}

While not explicitly available as a tag, the default file system of the created
process, i.e. {\tt pr\_FileSystemTask}, is set to the default file system of
the calling process if the caller is a process, or otherwise use the default
file system from the \emph{dos.library}. This file system is contacted to
resolve paths relative to the {\tt ZERO} lock.
\smallskip{}

{\tt NP\_WindowPtr} specifies a pointer to a {\tt Screen} on which error
requesters will be displayed, $0$ to display requesters on the workbench, or
$-1$ to suppress error requesters. It will be installed in the {\tt
  pr\_WindowPtr} of the process to be created. The default is to copy the
pointer from the calling process if the window pointer of the parent is $0$
or $-1$. The tag does not copy any other value of {\tt pr\_WindowPtr} from
the parent. To set the {\tt pr\_WindowPtr} of the created process to the
value of the calling process, the tag must be explicitly provided. If called
from a task and not a process, the default is {\tt NULL}. The reason why
{\tt pr\_WindowPtr} is not explicitly copied is that the caller shall ensure
that the screen is not closed while any pointers are still pointing to its
structure.
\smallskip{}

{\tt NP\_HomeDir} sets the {\tt pr\_HomeDir} \emph{lock} which is used to
resolve paths relative to the {\tt PROGDIR:} pseudo-assign. The default is
to copy {\tt pr\_HomeDir} of the calling process, or {\tt ZERO} in case the
caller is a task. This \emph{lock} is released when the process terminates,
i.e. the \emph{lock} provided as argument here remains available to the
caller, and shall be released by the caller in one way or another.
\smallskip{}

{\tt NP\_CopyVars} determines if the local shell variables in
{\tt pr\_LocalVars} of the calling process are copied into the variables of the
process to be created. If set to non-zero, a copy of the variables of the
calling process are made, otherwise the new process does not receive any
shell variables by itself. The latter also happens if the caller is a task
and not a process. The variables are automatically released when the new
process terminates.
\smallskip{}

{\tt NP\_Cli} determines whether the new process will receive a new shell
environment in the form of a {\tt CommandLineInterface} structure. If
non-zero, a new CLI structure will be created and a \emph{BPTR} to this
structure will be filled into the {\tt pr\_CLI} member of the process to be
created. The new shell environment will be a copy of the shell environment
of the caller if one is present, or a shell environment initialized with all
defaults. This means that the prompt, the path, and the command name will be
copied over. If~$0$, no such environment will be created. The latter is also the
default.
\smallskip{}

{\tt NP\_Path} provides a chained list of \emph{locks} within which commands
are searched. This is the same list the {\tt PATH} command adjusts, see
section~\ref{sec:shell} for details on this structure. This tag only applies
if {\tt NP\_Cli} is non-zero to create a shell environment. This chained
list is \emph{not} copied, and will be released when the created process
terminates; hence, the locks provided here are \emph{no longer} available to
the caller if {\tt CreateNewProc()} succeeds. If {\tt CreateNewProc()}
fails, the entire lock list remains a property of the caller and thus needs
to be potentially released there. The default, if this tag is not provided, is
to copy the paths of the caller if the calling process has a non-zero
{\tt pr\_CLI} structure.
\smallskip{}

{\tt NP\_CommandName} provides the name of the command being executed within
the shell environment if {\tt NP\_Cli} indicates that one is to be
created. The default is to copy the command name of the shell environment of
the calling process if one exists, or to leave the command name empty if
none is provided. The command name is copied into the shell environment of
the process being created and thus remains available to the caller. More on
the shell environment is found in section~\ref{sec:shell}.
\smallskip{}

{\tt NP\_Arguments} provides command line arguments for the process to be
created. This is a {\tt NUL} terminated string that is copied into the
process to be created, and will also be released there. If provided, the
arguments are copied in {\tt pr\_Arguments} of the process to be created,
and will also be loaded into registers {\tt A0} and its length into
{\tt D0}. If {\tt NP\_Arguments} are non-zero, a non-{\tt ZERO} {\tt
  NP\_Input} file handle shall also provided. This is because the arguments
are also copied into the buffer associated to the input \emph{file handle}
to make them available to {\tt ReadArgs()}\key{ReadArgs()}, or any other
function that performs buffered read from {\tt pr\_CIS}, see
section~\ref{sec:bufferedio} for details.
\smallskip{}

{\tt NP\_ExitCode} determines a pointer to function that is called when the
created process terminates. This pointer is filled into {\tt
  pr\_ExitCode}. See section~\ref{sec:process} for the description and the
signature of this function.
\smallskip{}

{\tt NP\_ExitData} provides an argument that will be passed into the {\tt
  NP\_ExitCode} function in register {\tt D1} when the process terminates.
\smallskip{}

While the official documentation also mentions the tags {\tt
  NP\_NotifyOnDeath} and {\tt NP\_Synchronous}, these tags are currently
ignored and do not perform any function.
\medskip{}

The {\tt CreateNewProc()} function returns on success a pointer to the
{\tt Process} structure just created. At this stage, the process has already
been launched and, depending on its priority, may already be running. On
failure, the function returns {\tt NULL}. Unfortunately, it does not set
{\tt IoErr()} consistently on failure.

\subsection{Create a Process (Legacy)}

The {\tt CreateProc()}\mkey{CreateProc()} function creates a process from a
segment list, a name, a priority and a stack size. It is a legacy call that
is not as flexible as {\tt CreateNewProc()}\key{CreateNewProc()}, and only
exists for backwards compatibility reasons.

\begin{verbatim}
process = CreateProc( name, pri, seglist, stackSize )
D0                    D1    D2   D3       D4

struct MsgPort *CreateProc(STRPTR, LONG, BPTR, LONG)
\end{verbatim}

This function creates a process of the name {\tt name} running at priority
{\tt pri}. The process starts at the first byte of the first segment of the
segment list passed in as {\tt seglist}, and a stack size of {\tt stackSize}
bytes will be allocated for the process.
\smallskip{}

The process is initialized as follows: {\tt pr\_ConsoleTask} and
{\tt pr\_WindowPtr} are copied from the calling process, or are set
to {\tt NULL} respective~$0$ if called from the task. The member
{\tt pr\_FileSystemTask} is also copied from the calling process, or
is initialized from the default file system from the
\emph{dos.library} if called from a task.
\smallskip{}

Input, output and error file handles are set to {\tt ZERO}, and no shell
environment is created either. The current directory and home directory are
also left at {\tt ZERO}. No arguments are provided to the called function,
and no shell variables are copied.
\smallskip{}

If the call succeeds, the returned value {\tt process} is a pointer to the
\emph{MsgPort} of the created process. It is \emph{not} a pointer to a
process itself.
\smallskip{}

On failure, the function returns {\tt NULL}. Unfortunately, it does not set
{\tt IoErr()} consistently in case of failure, thus the cause of the problem
cannot be easily identified.

\subsection{Terminating a Process}

The {\tt Exit()}\mkey{Exit()} function terminates the calling process or the
calling command line executable. In the latter case, control is returned to
the calling shell, in the former case, the process is removed from the exec
scheduler.
\smallskip{}

However, tis function does not release any resources except those implicitly
allocated when creating the process through {\tt
  CreateNewProc()}\key{CreateNewProc()}, {\tt
  CreateProc()}\key{CreateProc()} or {\tt RunCommand()}\key{RunCommand()}
and the calling shell. As it misses to release resources allocated by you or
the compiler startup code, this function \emph{should not be used} and
rather a compiler or language specific shutdown function should be
preferred. The C standard library provides {\tt exit()} which releases
resources allocated through this library.

\begin{verbatim}
Exit( returnCode )
      D1

void Exit(LONG)
\end{verbatim}

This call either terminates the calling process, in which case the argument
is ignored, or returns to the calling shell, then delivering {\tt
  returnCode} as result code. It uses the BCPL stack frame pointed to by
{\tt pr\_ReturnAddr}, removes this stack frame, initializes the new stack
from the stack frame there and then returns to whatever created the
stack frame. This is typically either the process shutdown code of AmigaDOS, or
the shell command shutdown code installed by {\tt RunCommand()}. In the
former code, {\tt pr\_ExitCode()} may be used to implement additional
cleanup activities.
\smallskip{}

This function is a BCPL legacy function that is also part of the
\emph{Global Vector}\key{Global Vector}; BCPL programs would typically
overload its entry in this vector to implement a custom shutdown
mechanism.

\section{Process Properties Accessor Functions}

The most important members of the process structure described in
section~\ref{sec:process} are accessible through getter and setter
functions. They implicitly relate to the calling process, and are the
preferred way of getting access to the {\tt Process} structure. The
functions listed in this section do not touch {\tt IoErr()} except
explicitly stated.

\subsection{Retrieve the Process Input File Handle}

The {\tt Input()}\mkey{Input()} function returns the input file handle of
the calling process if one is installed. If no input file handle is provided,
the function returns {\tt ZERO}.

\begin{verbatim}
file = Input()
D0

BPTR Input(void)
\end{verbatim}

This function returns a \emph{BPTR} to the input \emph{file handle} of the
calling process, or {\tt ZERO} if none is defined. This is approximately
identical to {\tt stdin} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectInput()}\key{SelectInput()}.

\subsection{Replace the Input File Handle}

The {\tt SelectInput()}\mkey{SelectInput()} function replaces the input
\emph{file handle} of the calling process with its argument and returns the
previously used input handle.

\begin{verbatim}
old_fh = SelectInput(fh)
D0                   D1

BPTR SelectInput(BPTR)
\end{verbatim}

This call replaces the input \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used input
\emph{file handle}.

\subsection{Retrieve the Output File Handle}

The {\tt Output()}\mkey{Output()} function returns the output file handle of
the calling process if one is installed. If no output file handle is provided,
the function returns {\tt ZERO}.

\begin{verbatim}
file = Output()
D0

BPTR Output(void)
\end{verbatim}

This function returns a \emph{BPTR} to the output \emph{file handle} of the
calling process, or {\tt ZERO} if none is defined. This is approximately
identical to {\tt stdout} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectOutput()}\key{SelectOutput()}.

\subsection{Replace the Output File Handle}

The {\tt SelectOutput()}\mkey{SelectOutput()} function replaces the output
\emph{file handle} of the calling process with its argument and returns the
previously used output handle.

\begin{verbatim}
old_fh = SelectOutput(fh)
D0                    D1

BPTR SelectOutput(BPTR)
\end{verbatim}

This call replaces the output \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used output
\emph{file handle}.

\subsection{Retrieve the Error File Handle}

The {\tt ErrorOutput()}\mkey{ErrorOutput()} function returns the file handle
through which diagnostic or error outputs should be printed. It uses either
{\tt pr\_CES} if this handle is non-{\tt ZERO}, or {\tt pr\_COS} if the
former is {\tt ZERO}. If neither an error output nor a regular output is
provided, this function returns {\tt ZERO}.

\begin{verbatim}
file = ErrorOutput()
D0

BPTR ErrorOutput(void)
\end{verbatim}

This function returns a \emph{BPTR} to the error \emph{file handle} of the
calling process, or falls back to the \emph{BPTR} of the output \emph{file
handle} if the former is not available. This is the file handle through
which diagnostic output should be printed and is therefore approximately
identical to {\tt stderr} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectError()}\key{SelectError()}.

\subsection{Replace the Error File Handle}

The {\tt SelectError()}\mkey{SelectError()} function replaces the error
\emph{file handle} of the calling process with its argument and returns the
previously used error handle.

\begin{verbatim}
old_fh = SelectError(fh)
D0                   D1

BPTR SelectError(BPTR)
\end{verbatim}

This call replaces the error \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used error
\emph{file handle}.

\subsection{Retrieve the Current Directory}

The {\tt GetCurrentDir()}\mkey{GetCurrentDir()} function returns the current
directory of the directory, indicated by a \emph{lock} on this object. This
\emph{lock}, and the \emph{file system} that created the lock are used to
resolve relative paths, see also section~\ref{sec:paths}.

\begin{verbatim}
lock = GetCurrentDir(void)
D0

BPTR GetCurrentDir()
\end{verbatim}

This function returns the \emph{lock} to the current directory, unlike the
{\tt CurrentDir()}\key{CurrentDir()} function which also changes it.

\subsection{Replace the Current Directory} \label{sec:currentdir}

The {\tt CurrentDir()}\mkey{CurrentDir()} selects and retrieves the current
directory of the calling process. The directory is indicated by a
\emph{lock} to this object. This \emph{lock}, and the \emph{file system}
that created the lock are used to resolve relative paths, see also
section~\ref{sec:paths}.

\begin{verbatim}
oldLock = CurrentDir( lock )
D0                    D1

BPTR CurrentDir(BPTR)
\end{verbatim}
This function sets the current directory to {\tt lock} and returns in
{\tt oldLock} the previously installed current directory. The passed in
{\tt lock} then becomes part of the process and shall not be released by
{\tt UnLock()}\key{UnLock()} until another \emph{lock} is installed as current
directory.
\smallskip{}

If the current directory is {\tt ZERO}, paths are relative to the root
directory of the \emph{file system} set in the {\tt pr\_FileSystemTask} member
of the calling process. It may be changed by
{\tt SetFileSysTask()}\key{SetFileSysTask()} described in
section~\ref{sec:setfilesystask}. AmigaDOS installs there the \emph{file
system} of the boot volume, unless a user installs a different
default \emph{file system}.

\subsection{Return the Latest Error Code} \label{sec:ioerr}

The {\tt IoErr()}\mkey{IoErr()} function returns the secondary result code
of the most recent AmigaDOS operation. This code is, in case of failure,
typically an error code indicating the nature of the failure.

\begin{verbatim}
error = IoErr()
D0

LONG IoErr(void)
\end{verbatim}
This function returns the secondary result code of the last call to the
\emph{dos.library} that provides such result. Unfortunately, not all
functions set {\tt IoErr()} consistently; all unbuffered operations in
section~\ref{sec:unbuffered} provide an error code in case of failure, or
deliver~$0$ as secondary result in case of success. The buffered functions
in section~\ref{sec:bufferedio} generally only set a secondary result code
in case an I/O operation is required, but do not touch {\tt IoErr()} if the
call can be satisfied from the caller. Whether a function of the
\emph{dos.library} touches {\tt IoErr()} is stated in the description of the
corresponding function --- unfortunately, the \emph{dos.library} does not
handle {\tt IoErr()} consistently.
\smallskip{}

Some functions provide a secondary result code different from an error code,
and thus make such additional return value available through
{\tt IoErr()}. Such additional return values are also explicitly mentioned in
the description of the corresponding function. A particular example is
{\tt DeviceProc()}\key{DeviceProc()}, which returns the (first) lock of a
regular assign in {\tt IoErr()}, but additional functions exist.
\medskip{}

Most error codes are defined in {\tt dos/dos.h}, with some additional error
codes only used by the pattern matcher (see section~\ref{sec:patternmatch})
in {\tt dos/dosasl.h}. Generally, \emph{handlers} and \emph{file systems}
can select error codes as they seem fit, the list below provides a general
indication how the codes are used by the \emph{dos.library} itself, or what
their suggested usage is:
\smallskip{}

{\tt ERROR\_NO\_FREE\_STORE}: This error code is set if the system run out
of memory. Actually, this error code is not set by the \emph{dos.library},
but rather by the \emph{exec.library} memory allocation functions.
\smallskip{}

{\tt ERROR\_TASK\_TABLE\_FULL}: This error code is no longer in
use. Previous releases of AmigaDOS created it if more than~$10$ shell
processes were about to be created. As this limitation was removed, the
error code remains currently unused.
\smallskip{}

{\tt ERROR\_BAD\_TEMPLATE}: This error code indicates that the command line
template for {\tt ReadArgs()}\key{ReadArgs()} is syntactical incorrect. It
is also set by the pattern matcher in case the pattern is syntactically
incorrect.
\smallskip{}

{\tt ERROR\_BAD\_NUMBER}: This error code indicates that a string could not
be converted to a number.
\smallskip{}

{\tt ERROR\_REQUIRED\_ARG\_MISSING}: This error code is set by
{\tt ReadArgs()}\key{ReadArgs()} if a non-optional argument is not
provided.
\smallskip{}

{\tt ERROR\_KEY\_NEEDS\_ARG}: This error code is also used by the argument
parser {\tt ReadArgs()}\key{ReadArgs()} if an argument key is provided on
the command line, but a corresponding argument value is missing.
\smallskip{}

{\tt ERROR\_TOO\_MANY\_ARGS}: This error code can also be set by
{\tt ReadArgs()}\key{ReadArgs()}; it indicates that more arguments are
provided than indicated in the template.
\smallskip{}

{\tt ERROR\_UNMATCHED\_QUOTES}: This error code indicates that a closing
quote is missing for at least one opening quote. It is also set by the
argument parser and {\tt ReadItem()}\key{ReadItem()}.
\smallskip{}

{\tt ERROR\_LINE\_TOO\_LONG}: This error code is a general indicator that a
user provided buffer is too small to buffer a string. It is for example used
again by the argument parser and the path manipulation functions in
section~\ref{sec:workpaths}.
\smallskip{}

{\tt ERROR\_FILE\_NOT\_OBJECT}: This error code is generated by the \emph{Shell}
if an attempt is made to execute a file that is neither a script, nor an
executable nor a file that can be opened by a viewer.
\smallskip{}

{\tt ERROR\_INVALID\_RESIDENT\_LIBRARY}: While this error code is not in use
by the \emph{dos.library}, several \emph{handlers} and other Os components
use it to indicate that a required library or device is not available.
\smallskip{}

{\tt ERROR\_NO\_DEFAULT\_DIR}: This is error code is also not in use. Its
intended purpose is unclear.
\smallskip{}

{\tt ERROR\_OBJECT\_IN\_USE}: This error code is used by multiple Os
components to indicate that a particular operation cannot be performed
because the object to be modified is in use. AmigaDOS uses it, for example,
to indicate that a \emph{lock} was obtained on an object that is supposed to
be modified or deleted, and thus cannot be modified or removed.
\smallskip{}

{\tt ERROR\_OBJECT\_EXISTS}: This error code is a generic error indicator
that an operation could not be performed because another object already
exists in place, and is used as such by multiple Os components. AmigaDOS
\emph{file systems} use it, for example, when attempting to create a
directory, but a file or a directory of the requested name is already
present. 
\smallskip{}

{\tt ERROR\_DIR\_NOT\_FOUND}: This error code indicates that the target
directory is not found. Of the AmigaDOS ROM components, only the shell uses
it on an attempt to change the working directory to a non-working target
directory.
\smallskip{}

{\tt ERROR\_OBJECT\_NOT\_FOUND}: This is a generic error code that indicates
that the object on which a particular operation is to be performed does not
exist. It is for example generated on an attempt to open a non-existing file
or to lock a file or directory that could not be found.
\smallskip{}

{\tt ERROR\_BAD\_STREAM\_NAME}: This error code is currently not in use by
AmigaDOS ROM components. Its purpose is unclear.
\smallskip{}

{\tt ERROR\_OBJECT\_TOO\_LARGE}: This error could be used to indicate that
an object is beyond the size a \emph{handler} or \emph{file system} is able
to handle. Note that a full disk (or full storage medium) is indicated by
{\tt ERROR\_DISK\_FULL}, and not this error. However, currently no AmigaDOS
component uses this error, even though the FFS should probably return it on
an attempt to create or access files larger than~2GB.
\smallskip{}

{\tt ERROR\_ACTION\_NOT\_KNOWN}: This is a generic error code that is
returned by many \emph{handlers} or \emph{file systems} when an action (in
the form of a \emph{packet}) is requested the handler does not support or
understand. For example, this error is created when attempting to create a
directory on a console handler.
\smallskip{}

{\tt ERROR\_INVALID\_COMPONENT\_NAME}: This is an error that is raised by
file systems when providing an invalid path, or a path that contains
components that are syntactically incorrect. For example, the colon (``{\tt
  :}'') shall only appear one in a path as separator between the device name
and the path within the device. A colon within a component is therefore a
syntactical error. Also, all Amiga ROM file systems do not accept code
points below {\tt 0x20}, i.e. ASCII control characters.
\smallskip{}

{\tt ERROR\_INVALID\_LOCK}: This error is raised if a value is passed in as
a \emph{lock} that is, in fact, not a valid lock of the target \emph{file
system}. For example, an attempt to use a \emph{file handle} as a lock will
result in such an error condition. Note, however, that \emph{file systems}
can, but do not need to check locks for validity. Passing incorrect objects
to \emph{file systems} can raise multiple error conditions of which this
error code is probably the most harmless.
\smallskip{}

{\tt ERROR\_OBJECT\_WRONG\_TYPE}: This error code indicates that a
particular operation is not applicable to a target object, even though the
target object is valid and existing. For example, an attempt to open an
existing directory for reading as a file will raise this error.
\smallskip{}

{\tt ERROR\_DISK\_NOT\_VALIDATED}: This error indicates that the inserted
medium is currently not validated, i.e. not checked for consistency. Such a
consistency check (or validation) may be currently ongoing. This error is
for example generated  if a write operation is attempted on an FFS volume
whose validation is still ongoing. In such a case, retrying the operation
later may solve the problem already.
\smallskip{}

{\tt ERROR\_DISK\_WRITE\_PROTECTED}: This indicates that an attempt was made
to write to a medium, e.g. a disk, that is write-protected, or that cannot
be written to, such as an attempt to write to a CD-ROM.
\smallskip{}

{\tt ERROR\_RENAME\_ACROSS\_DEVICES}: Generated if an attempt is made to
move an object to a target directory that is located on a different medium
or different \emph{file system} than the source directory. This cannot
succeed, instead the object (and its subobjects) need to be copied manually.
\smallskip{}

{\tt ERROR\_DIRECTORY\_NOT\_EMPTY}: Indicates that an attempt was made to
delete a directory that is not empty. First, all the files within a
directory must be deleted before the directory itself may be deleted.
\smallskip{}

{\tt ERROR\_TOO\_MANY\_LEVELS}: This error code is generated if too many
softlinks refer iteratively to other softlinks. In order to avoid an endless
indirection of softlinks referring to each other, the \emph{dos.library}
aborts following softlinks after 15 passes; application programs attempting
to resolve softlinks themselves through {\tt ReadLink()}\key{ReadLink()}
should implement a similar mechanism, see also section~\ref{sec:readlink}.
\smallskip{}

{\tt ERROR\_DEVICE\_NOT\_MOUNTED}: This error indicates that an access was
attempted to either a \emph{handler}, \emph{file system} or \emph{assign}
that is not known to the system, or to a volume that is currently not
inserted in any known drive.
\smallskip{}

{\tt ERROR\_SEEK\_ERROR}: This error is generated by an attempt to {\tt
  Seek()} to a file position that is either negative, or behind the end of
the file. It is also signalled if the mode of {\tt Seek()}\key{Seek()} or
{\tt SetFileSize()}\key{SetFileSize()} is none of the modes indicated in
table~\ref{table:seekmode}. The FFS also sets this mode if it cannot read
one of its administration blocks.
\smallskip{}

{\tt ERROR\_COMMENT\_TOO\_BIG}: This error is raised if the size of the
comment is too large to be stored in in the metadata of the \emph{file
system}. Note that while \emph{file systems} shall validate the size of the
comment, it shall silently truncate file names to the maximal size possible.
\smallskip{}

{\tt ERROR\_DISK\_FULL}: Generated by \emph{file systems} when an attempt is
made to write more data to a medium than it is possible to hold, i.e. when
the target medium is full.
\smallskip{}

{\tt ERROR\_DELETE\_PROTECTED}: This error is generated by \emph{file
systems} if an attempt is made to delete a file that is delete protected,
i.e. whose {\tt FIBB\_DELETE} protection bit is set, see
table~\ref{table:protectionbits} in section~\ref{sec:fib}.
\smallskip{}

{\tt ERROR\_WRITE\_PROTECTED}: This error is generated by \emph{file
systems} if a write is attempted  to a file that is write protected,
i.e. whose {\tt FIBB\_WRITE} bit is set.
\smallskip{}

{\tt ERROR\_READ\_PROTECTED}: This error is generated on an attempt to read
from a while whose {\t FIBB\_READ} bit is set to indicate read protection.
\smallskip{}

{\tt ERROR\_NOT\_A\_DOS\_DISK}: This error is generated by a \emph{file
system} on an attempt to read a disk that is not strutured according to the
requirements of the \emph{file system}, i.e. that is initialized by another
incompatbile \emph{file system} different from the mounted
one. Unfortunately, AmigaDOS does not have a control instance that selects
file systems according to the disk layout.
\smallskip{}

{\tt ERROR\_NO\_MORE\_ENTRIES}: This secondary result code does not really
indicate an error condition, it just reports to the caller that the end of a
directory has been reached when scanning it by
{\tt ExNext()}\key{ExNext()} or {\tt ExAll()}\key{ExAll()}.
\smallskip{}

{\tt ERROR\_IS\_SOFT\_LINK}: This error code is generated by
\emph{file systems} on an attempt to access a \emph{soft link}. For many
functions, the \emph{dos.library} recognizes this error and then resolves
the link through {\tt ReadLink()}\key{ReadLink()} within the library, not
requiring intervention of the caller. However, not all functions of the
\emph{dos.library} are aware of \emph{soft links}, see
section~\ref{sec:links} for the list.
\smallskip{}

{\tt ERROR\_OBJECT\_LINKED}: This error code is currently not used by
AmigaDOS and its intended use is not known.
\smallskip{}

{\tt ERROR\_BAD\_HUNK}: Generated by {\tt LoadSeg()}\key{LoadSeg()} and {\tt
  NewLoadSeg()}\key{NewLoadSeg()}, this error code indicates that the binary
file includes a hunk type that is not supported or recognized by
AmigaDOS. The hunk format for binary executables is documented in
section~\ref{sec:loadseg()}.
\smallskip{}

{\tt ERROR\_NOT\_IMPLEMENTED}: This error code is not used by any ROM
component, but several workbench components signal this error indicating
that the requested function is not supported by this component. For example,
the {\tt Format} command generates it on an attempt to format a disk with
long file names if the target file system does not support them.
\smallskip{}

{\tt ERROR\_RECORD\_NOT\_LOCKED}: Issued by \emph{file systems} and their
record-locking subsystem if an attempt is made to release a record that is,
actually, not locked.
\smallskip{}

{\tt ERROR\_LOCK\_COLLISION}: This error is also created by the
record-locking subsystem of \emph{file systems} if attempt is made to
exclusively lock the same region within a file by two write locks.
\smallskip{}

{\tt ERROR\_LOCK\_TIMEOUT}: Also generated by the record-locking mechanism
of \emph{file systems} if an attempt was made to exclusively lock a region
of a file that is exclusively locked already, and the attempt failed because
the region did not became available before the lock timed out.
\smallskip{}

{\tt ERROR\_UNLOCK\_ERROR}: This error is currently not generated by any
\emph{file system}, though could be used to indicate that an attempt to
unlock a record failed for an unknown reason.
\smallskip{}

{\tt ERROR\_BUFFER\_OVERFLOW}: This error is raised by the pattern matcher
and indicates that the buffer allocated in the {\tt AnchorPath} structure is
too small to keep the fully expanded matching file name, see also
section~\ref{sec:pattern}.
\smallskip{}

{\tt ERROR\_BREAK}: This error is also raised by the pattern matcher if it
received an external signal for aborting a directory scan for objects. Such
signals are raised, for example, by the user through the console by pressing
{\tt Ctrl + C} through {\tt Ctrl + F}.
\smallskip{}

{\tt ERROR\_NOT\_EXECUTABLE}: This error is generated by the workbench on an
attempt to start an application icon from a file whose {FIBB\_EXECUTE} is
set, indicating that the file is not executable. Why the workbench does not
use the same error code as the \emph{Shell} remains unclear.

\subsection{Setting IoErr}

The {\tt SetIoErr()}\mkey{SetIoErr()} function sets the value returned by
the next call to {\tt IoErr()}\key{IoErr()} and thus initializes or resets
the next IO error.

\begin{verbatim}
oldcode = SetIoErr(code)
D0                 D1

LONG SetIoErr(LONG);
\end{verbatim}

This function sets the next value returned by {\tt IoErr()}; this can be
necessary because some functions of the \emph{dos.library} do not update
this value in all cases. A particular example are the buffered I/O functions
introduced in section~\ref{sec:bufferdio} that do not touch {\tt IoErr()} in
case the input or output operation can be satisfied from the buffer. A good
practise is to call {\tt SetIoErr(0)} upfront to ensure that these functions
leave~a $0$ in {\tt IoErr()} on success.
\smallskip{}

This function returns the previous value of {\tt IoErr()}, and thus the same
value {\tt IoErr()} would return.

\subsection{Select the Console Handler}

The {\tt SetConsoleTask()}\mkey{SetConsoleTask()} function selects the
\emph{handler} responsible for the ``{\tt *}'' file name and {\tt CONSOLE:}
pseudo-device.

\begin{verbatim}
oldport = SetConsoleTask(port)
D0                        D1

struct MsgPort *SetConsoleTask(struct MsgPort *)
\end{verbatim}

This function selects the \emph{MsgPort} of the console handler. AmigaDOS
will contact this handler for opening the ``{\tt *}'' as file name, or a
file relative to the {\tt CONSOLE:} pseudo-device. Note that the argument is
not a pointer to the \emph{handler} process, but rather to a \emph{MsgPort}
through which this process can be contacted. It returns the previously used
console handler \emph{MsgPort}. 
\smallskip{}

This function is the setter function corresponding to the
{\tt GetConsoleTask()}\key{GetConsoleTask()} getter function introduced in
section~\ref{sec:getconsoletask}.

\subsection{Select the Default File System} \label{sec:setfilesystask}

The {\tt SetFileSysTask()}\mkey{SetFileSysTask()} function selects the
handler responsible for resolving paths relative to the {\tt ZERO} lock.

\begin{verbatim}
oldport = SetFileSysTask(port)
D0                        D1

struct MsgPort *SetFileSysTask(struct MsgPort *)
\end{verbatim}

This function selects the \emph{MsgPort} of the default \emph{file
system}. AmigaDOS will contact this \emph{file system} if a path relative to
the {\tt ZERO} lock is resolved, e.g. a relative path name if the current
directory is {\tt ZERO}. This \emph{file system} should be identical to the
\emph{file system} of the {\tt SYS:} assign, and should therefore not be
relaced as otherwise resolving file names may be inconsistent between
processes.
\smallskip{}

Note that the argument is not a pointer to the \emph{handler} process, but
rather to a \emph{MsgPort} through which this process can be contacted. It
returns the previously used default file system \emph{MsgPort}. This
function is the setter equivalent of {\tt
  GetFileSysTask()}\key{GetFileSysTask()} introduced in
section~\ref{sec:getfilesystask}.

\subsection{Retrieve the Lock to the Program Directory}

The {\tt GetProgramDir()}\mkey{GetProgramDir()} returns a lock to the
directory that contains the binary from which the caller executes, if
such a directory exists. If the executable was made resident, this
function returns {\tt ZERO}.

\begin{verbatim}
lock = GetProgramDir()
D0

BPTR GetProgramDir(void)
\end{verbatim}

The lock returned by this function corresponds to the {\tt PROGDIR:}
(pseudo)-assign and the {\tt pr\_HomeDir} member of the {\tt Process}
structure, with the only exception that {\tt ZERO} does not correspond
to the root directory of the boot volume, but rather indicates that no
home directory exists.

\subsection{Set the Program Directory}

The {\tt SetProgramDir}\mkey{SetProgramDir()} sets the directory
within which the executing program is made to believe of getting
started from, and the directory that corresponds to the {\tt PROGDIR:}
pseudo-assign.

\begin{verbatim}
oldlock = SetProgramDir(lock)
D0		         D1

BPTR SetProgramDir(BPTR)
\end{verbatim}

This function installs {\tt lock} into {\tt pr\_HomeDir} of the {\tt
  Process} structure. This {\tt lock} is supposed to belong to the
directory the currently executing program was loaded from and is used
to resolve the {\tt PROGDIR:} pseudo-assign. If {\tt ZERO} is
installed, the current process will be unable to resolve this
pseudo-assign.

\subsection{Retrieve Command Line Arguments} \label{sec:getargstr}

The {\tt GetArgStr()}\mkey{GetArgStr()} function returns the command
line arguments, if any, of the calling process. If called from the
workbench, this function returns {\tt NULL}.

\begin{verbatim}
ptr = GetArgStr()
D0

STRPTR GetArgStr(void)
\end{verbatim}

This function returns the command line arguments as {\tt
  NUL}-terminated string. This is the same string the process finds in
register {\tt a0} on startup, or that is placed into the file buffer
of the {\tt Input()} file handle. This function returns {\tt NULL} if
the program was run from the workbench; it is equivalent to reading
the {\tt pr\_Arguments} member of the {\tt Process} structure.

\subsection{Set the Command Line Arguments}

The {\tt SetArgStr()}\mkey{SetArgStr()} function sets the string
returned by {\tt GetArgStr()}\key{GetArgStr()}. It cannot set the
command line arguments as seen by {\tt ReadArgs()}\key{ReadArgs()}.

\begin{verbatim}
oldptr = SetArgStr(ptr)
D0		   D1

STRPTR SetArgStr(STRPTR)
\end{verbatim}

This function requires a pointer to a {\tt NUL} terminated string as
{\tt ptr} and installs it to {\tt pr\_Arguments} member of the
{\tt Process} structure. This is unfortunately of limited use as the
{\tt ReadArgs()}\key{ReadArgs()} function takes the command line
arguments from a different source, namely the input buffer of the
{\tt Input()} file handle. 

\chapter{Binary File Structure} \label{sec:binary}

% TODO: add library format.
The AmigaDOS \emph{Hunk} format represents executable and linkable
object files. While both formats are related, they are not identical;
executables can be loaded from the shell or the workbench from disk to
RAM, and then either overload the shell process, or a new process is
created from them. Object files are created as intermediate compiler
outputs; typically, each translation unit is compiled into one object
file which are then, in a final step, linked with a startup code and
object code libraries to form an executable.
\smallskip{}

An object or executable file in this format consists of multiple
\emph{hunks} (thus, the name). Hunks define either payload data as
indivisible \emph{segments} of code or data that is initialized or
loaded from disk, or additional meta-information interpreted by the
AmigaDOS loader, the {\tt LoadSeg()}\key{LoadSeg()} function. The
meta-information is used to relocate the payload to their final
position in memory, to define the size of the sections, to select the
memory type that is allocated for the segment, or to interrupt or
terminate the loading process.
\smallskip{}

Loaded executables are represented as singly linked list of segments
in memory, by a structure that looks as follows: \mkey{LoadedSegment}
\begin{verbatim} 
struct LoadedSegment {
    BPTR  NextSegment; /* BPTR to next segment or ZERO */
    ULONG Data[1];     /* Payload data */
};
\end{verbatim}
The above structure is \emph{not} documented and is not identical to
the {\tt Segment} in {\tt dos/dosextens.h}. The latter describes a
resident executable, see section~\ref{resident}, but also contains a
\emph{BPTR} to a segment in the above sense. Each segment of a binary
is allocated through {\tt AllocVec()} which is sometimes helpful as it
allows to retrieve size of the segment from the size of the allocated
memory block.
\smallskip{}

The hunk format distinguishes three types of \emph{segments}, each
represented by a hunk: \emph{code hunks} that should contain constant
data, most notably executable machine code and constant data
associated to this code, \emph{data hunks} that contain (variable)
data, and so called \emph{BSS} hunks that contain data that is
initialized to zero. Thus, the contents of \emph{BSS} hunks is not
represented on disk.

\punchline{Const is not enforced}{While \emph{code hunks} should
  contain executable code and other constant data, and \emph{data
    hunks} should contain variable data, nothing in AmigaDOS is able
  to enforce these conventions. In principle, \emph{data hunks} may
  contain executable machine code, and \emph{code hunks} may contain
  variable data. Note, however, that some third party tools may
  require programs to follow such conventions. Many commercial
  compilers structure their object code according to these
  conventions, or at least do so in their default configuration.}

Additional \emph{hunks} describe how to relocate the loaded code and
data. Relocation means that data within the hunk is corrected
according to the addresses this and other hunks are loaded to. The
relocation process takes an offset into one hunk, and adds to the
longword at this offset the absolute address of this or any other
hunk. That is, hunks on disk are represented as if their first byte is
placed at address~0, and relocation adjusts longwords within hunks to
the final positions in memory.
\smallskip{}

An extension of the executable file format is the \emph{overlay
  format} also supported by {\tt LoadSeg()}\key{LoadSeg()}. Here, only
a part of the file is loaded into memory, while the remaining parts
are only loaded on demand, potentially releasing other already loaded
parts from memory. Overlaid executables thus take less main memory,
though requires the volume containing the executable available all the
time.
\smallskip{}

AmigaDOS also contains a simple run-time binder that is only used by
compiled BCPL code, or by code that operates under such
requirements. The purpose of this binder is to populate the BCPL
\emph{global vector} of the loaded program. While this runtime binder
implements a legacy protocol, certain parts of AmigaDOS still
expect. These are \emph{handlers} or \emph{file systems} that use the
{\tt dol\_GlobVec} value of $0$ or $-2$, or corresponding {\tt
  GlobVec} entry in the mount list. While new handlers should not use
this BCPL legacy protocol, the ROM file system (the FFS) and the
port-handler currently still depend (or require) it, despite not being
written in BCPL. A second application of this run-time binding procol
is the shell which also depends on BCPL binding.

\section{Executable File Format}

The hunk format of executable files consists of 4-byte (longword) hunk
identifiers and subsequent data that is interpreted by the AmigaDOS
loader according to the introducing hunk identifier. The syntax of
such a file, and its hunks, is here presented in a pseudo-code, in
three-column tables.
\smallskip{}

The first column identifies the number of bits a syntax element
takes. Bits within a byte are read from most significant to least
significant bit, and bytes within a structure that extends over
multiple bytes are read from most significant to least significant
bit. That is, the binary file format follows the big-endian
convention. If the first column contains a question mark (``?''), the
structure is variably-sized, and the number of removed bits is defined
by the second column, or the section it refers to. If the first column
is empty, no bits are removed from the file.
\smallskip{}

The second column either identifies the member of a structure to which
the value removed from the stream is assigned, or contains pseudo-code
that describes how to process the values parsed from the stream. These
syntax elements follow closely the convention of the C language. In
particular {\tt if ({\it cond})} formulates a condition that is only
executed if {\it cond} is true, {\tt else} describes code that is
executed following an {\tt if} clause that is executed if {\it cond}
is false, and {\tt do} $\ldots$ {\tt while({\it cond})} indicates a
loop that continues as long as {\tt cond} is non-zero, and that may
alternatively be terminated by a {\tt break} within the body of the
loop. The expression {\tt i++} increments an internal state variable
{\tt i}, and the expression {\tt -{}-j} decrements an internal state
variable. The value of {\tt i++} is the value of $i$ before the
increment, and the value of {\tt -{}-j} is the value of $j$ after
decrementing it.
\smallskip{}

The following pseudo-code describes the top-level syntax of a binary
executable file AmigaDOS is able to bring to memory:

\begin{rkrmtabular}{Regular Executable File} \label{table:executable}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
? & \tt HUNK\_HEADER & Defines all segments, see section~\ref{sec:hunk_header} for details \\ \hline
 & \tt $i = t_{\mbox{num}}$ & Start with the first hunk, $t_{\mbox{num}}$ is defined in the {\tt HUNK\_HEADER} \\ \hline
 & \tt do \{ & Repeat until all hunks done \\ \hline
2  & \tt $\quad$ $\hat{m}_t[i]$ & These two bits are unused, but some utilities set it identical to $m_t[i]$, the memory type of the hunk, see~\ref{sec:hunk_header} \\ \hline
1  & \tt $\quad$ $a_f$ & Advisory hunk flag. \\ \hline
29 & \tt $\quad$ h & This is the hunk type \\ \hline
& \tt $\quad$ if (EOF) break; & Terminate loading on end of file \\ \hline
& \tt $\quad$ if ($a_f$) \{ & Check for bit $29$, these are advisory hunks \\ \hline
32 & \tt $\quad\quad$ l & Read length of advisory hunk \\ \hline
32 $\times$ l & & $l$ long words of hunk contents ignored \\ \hline
& \tt $\quad$ \} & \\ \hline
& \tt $\quad$ else if (h == HUNK\_END) i++; & Advance to next segment, see~\ref{sec:hunk_end} \\ \hline
& \tt $\quad$ else if (h == HUNK\_BREAK) break; & Terminate loading an overlay, see~\ref{sec:hunk_break} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_NAME) parse\_NAME; & See section~\ref{sec:hunk_name} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_CODE) parse\_CODE; & See section~\ref{sec:hunk_code} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DATA) parse\_DATA; & See section~\ref{sec:hunk_data} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_BSS) parse\_BSS; & See section~\ref{sec:hunk_bss} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELOC32) parse\_RELOC32; & See section~\ref{sec:hunk_reloc32} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_SYMBOL) parse\_SYMBOL; & See section~\ref{sec:hunk_symbol} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DEBUG) parse\_DEBUG; & See section~\ref{sec:hunk_debug} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_OVERLAY) \{ parse\_OVERLAY; break \} & See section~\ref{sec:hunk_overlay} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DREL32) parse\_RELOC32SHORT; & This is a compatibility kludge for some older versions of the \emph{dos.library}, new tools should use {\tt HUNK\_RELOC32SHORT} instead, see section~\ref{sec:hunk_reloc32short} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELOC32SHORT) parse\_RELOC32SHORT; & See section~\ref{sec:hunk_reloc32short} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELRELOC32) parse\_RELRELOC32; & See section~\ref{sec:hunk_relreloc32} \\ \hline
& \tt $\quad$ else ERROR\_BAD\_HUNK; & Everything else is invalid \\ \hline
& \tt \} while(true) & repeat until all hunks done \\ \hline
\end{longtable}
\end{rkrmtabular}

In particular, every executable shall start with the {\tt
  HUNK\_HEADER} identifier, the big-endian long-word {\tt 0x3f3}. The
following stream contains long-word identifiers of which the first
$2$~bits are ignored and masked out. Some tools (e.g. the {\tt Atom}
tool by CBM) places there memory requirements similar to what is
indicated in the {\tt HUNK\_HEADER}. They have there, however, no
effect as the segments are allocated within the {\tt HUNK\_HEADER} and
not at times the hunk type is encountered. \key{HUNK\_HEADER}
\smallskip{}

Bit $29$ ({\tt HUNKB\_ADVISORY})\mkey{HUNKB\_ADVISORY} has a special
meaning. If this bit is set, then the hunk contents is ignored. The
size of such an \emph{advisory} hunk is defined by a long-word
following the hunk type.
\smallskip{}

Loading a binary executable terminates on three conditions. Either, if
an end of file is encountered. This closes the file handle and returns
to the caller with the loaded segment list. Or, if a {\tt
  HUNK\_BREAK}\key{HUNK\_BREAK} or {\tt HUNK\_OVERLAY} are found. This
mechanism is used for \emph{overlaid} files. In the latter two cases,
the file remains open, and for {\tt HUNK\_OVERLAY}\key{HUNK\_OVERLAY},
information on the loaded file is injected into the first hunk of the
loaded data. More information on this mechanism is provided in
section~\ref{sec:overlays}.

\subsection{HUNK\_HEADER} \label{sec:hunk_header}

The {\tt HUNK\_HEADER}\mkey{HUNK\_HEADER} is the first hunk of every
executable file. It identifies the number of segments in an
executable, and the amount of memory to reserve for each
segment.
    
\begin{rkrmtabular}{Hunk Header Syntax} \label{table:hunk_header}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
32 & \tt HUNK\_HEADER [0x3f3] & Every executable file shall start with this hunk \\ \hline
32 & \tt $0$ & Number of resident libraries, BCPL legacy, shall be zero \\ \hline
32 & \tt $t_{\mbox{size}} \in [1,2^{31}-1]$ & Number of segments in binary \\ \hline
32 & \tt $t_{\mbox{num}} \in [0,t_{\mbox{size}}-1]$ & First segment to load \\ \hline
32 & \tt $t_{\mbox{max}} \in [t_{\mbox{num}},t_{\mbox{size}}-1]$ & Last segment to load (inclusive) \\ \hline
 & \tt for(i=$t_{\mbox{num}}$;$i \le t_{\mbox{max}}$;i++) \{ & Iterate over all hunks \\ \hline
2  & \tt $\quad$ $m_t[i]$ & Read memory type of the segment as 2 bits \\ \hline
30 & \tt $\quad$ $m_s[i]$ & Read memory size in long words as 30 bits \\ \hline
 & \tt $\quad$ if ($m[i]$ == 3) \{ & if the memory type is $3$ \\ \hline
32 & $\quad \quad m_t[i]$ & Memory type is explicitly provided \\ \hline
 & \tt $\quad$ \tt \} & End of special memory condition \\ \hline
 & \tt $\quad$ $m_a[i]$ = AllocVec(sizeof(BPTR) + $m_s[i] \times$ sizeof(LONG),$m_t[i] | $ \mbox{MEMF\_PUBLIC}) + sizeof(BPTR) &
Get memory for segment \\ \hline
 & \tt \} & End of loop over segments \\ \hline
\end{tabular}
\end{rkrmtabular}

The first member of a {\tt HUNK\_HEADER} shall always be $0$; it was
used by a legacy mechanism which allowed run-time binding of the
executable with dynamic libraries. While first versions of AmigaDOS
inherited this mechanism from TRIPOS, it was not particularly useful
as the calling conventions for such libraries did not follow the usual
conventions of AmigaDOS, i.e. with the library base in register {\tt
  a6}. Later versions of AmigaDOS, in particular its re-implementation
as of Kickstart v37, removed support for such libraries. As this
mechanism is no longer supported, it is not documented here. More
information is found in~\cite{guru}.
\smallskip{}

The second entry $t_{\mbox{size}}$ contains the number of segments the
executable consists of. In case of overlays, it is the total number of
segments that can be resident in memory at all times. See
section~\ref{sec:overlays} for more information. This value shall be
consistent for all {\tt HUNK\_HEADERS} within an overlaid file. In
regular executables, only a single {\tt HUNK\_HEADER} exists at the
beginning of the file.
\smallskip{}

The members $t_{\mbox{num}}$ and $t_{\mbox{max}}$ define the 0-based index of
the first and last segment to load within the branch of the overlay
tree described by this {\tt HUNK\_HEADER}. For a regular
(non-overlaid) file and for the root node of the overlay tree,
$t_{\mbox{num}}$ shall be $0$, that is, the first segment to load
is~$0$, the first index in the segment table. 
\smallskip{}

For regular files, $t_{\mbox{max}}$ shall be identical to
$t_{\mbox{size}}-1$, that is, the last segment to load is the last entry
in the segment table described by this {\tt HUNK\_HEADER}. For
overlaid files, the number may be smaller, i.e. not all segments may
be populated initially and loading may continue later on when
executing the binary.

\subsection{HUNK\_CODE} \label{sec:hunk_code}

This hunk should contain executable machine code and constant data. As
executables are started from the first byte of the first segment, the
first hunk of an executable should be a {\tt HUNK\_CODE}, and it should
start with a valid opcode. \mkey{HUNK\_CODE}
\smallskip{}

Compilers use typically this hunk to represent the {\tt text} segment,
i.e. compiled code and constant data.

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Code Syntax} \label{table:hunk_code}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3e9] & A hunk describing a segment of code and constant data \\ \hline
32 & \tt $l \le m_s[i]$ & Size of the payload\\ \hline
l $\times$ 32 & \tt Code & $l$ long words of payload \\ \hline
\end{tabular}
\end{rkrmtabular}

Note that the size of the payload loaded from the file may be less
than the size of the allocated segment as defined in {\tt
  HUNK\_HEADER}. In such a case, all bytes of the segment not included
in the {\tt HUNK\_CODE} are zero-initialized. AmigaDOS versions earlier than
v37 skipped this initialization. Due to a bug in the loader in later
versions, the initialization is also skipped of the hunk length~$l$ is~$0$.

\subsection{HUNK\_DATA} \label{sec:hunk_data}

This hunk should contain variable data, and it should not contain
executable code. Compilers typically use this hunk to represent
initialized data. \mkey{HUNK\_DATA}
\smallskip{}

The structure of this hunk is otherwise identical to {\tt HUNK\_CODE}:
\begin{rkrmtabular}{Hunk Data Syntax} \label{table:hunk_data}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3ea] & A hunk describing a segment of data\\ \hline
32 & \tt $l \le m_s[i]$ & Size of the payload\\ \hline
l $\times$ 32 & \tt Code & $l$ long words of payload \\ \hline
\end{tabular}
\end{rkrmtabular}

Similar to {\tt HUNK\_CODE}, the size of the payload defined by this
hunk may be less than the size of the segment allocated by {\tt
  HUNK\_HEADER}. Excess bytes are zero-initialized in all AmigaDOS
releases from v37 onwards. Due to a bug in the loader in later
versions, the initialization is also skipped of the hunk length~$l$ is~$0$.

\subsection{HUNK\_BSS} \label{sec:hunk_bss}

This hunk contains zero-initialized data; it does not define actual
payload. \mkey{HUNK\_BSS}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk BSS Syntax} \label{table:hunk_bss}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3eb] & A hunk describing zero-initialized data\\ \hline
32 & \tt $l \le m_s[i]$ & Size of the segment in long-words\\ \hline
\end{tabular}
\end{rkrmtabular}

Note that this hunk does not contain any payload; the segment
allocated from this hunk is always zero-initialized.
\smallskip{}

Due to a defect in AmigaDOS prior release v37, the BSS segment will not be
completely initialized to zero if the segment size is larger than 256K,
i.e. if $l > 2^{16}$. Also, these releases do not initialize long words
beyond the $l^{\mbox{\tiny th}}$ long-word to zero, i.e. the excess bytes
included if $l < m_s[i]$.

\subsection{HUNK\_RELOC32} \label{sec:hunk_reloc32}

This hunk contains relocation information for the previously loaded
segment; that is, it corrects addresses within this segment by
adding the absolute address of this or other segments to long words at
indicated offsets of the previous segments. \mkey{HUNK\_RELOC32}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Reloc32 Syntax} \label{table:hunk_reloc32}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC32 [0x3ec] & A hunk containing relocation information\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
32 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
32 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
32 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j]$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
\end{longtable}
\end{rkrmtabular}

That is, the hunk consists first of a counter that indicates the
number of relocation entries, followed by the hunk index relative to
which an address should be relocated. Then relocation entries follow;
each long-word defines an offset into the previously loaded segment to
relocate, that is, to fix up the address.
\smallskip{}

For AmigaDOS versions 37 and up (Kickstart 2.0 and later), the number of
relocation entries~$c$ shall not be larger than $2^{16}$. This is a known
defect of the loader that has currently not yet fixed. If more relocation
entries are needed, they shall be split into multiple chunks.

\subsection{HUNK\_RELOC32SHORT} \label{sec:hunk_reloc32short}

This hunk contains relocation information for the previously loaded
segment, and is almost similar to {\tt HUNK\_RELOC32}, except that
hunk indices, counts and offsets are only 16 bits in size. To ensure
that all hunks start at long-word boundaries, the hunk contains an
optional padding field at its end to align the next hunk
appropriately. \mkey{HUNK\_RELOC32SHORT}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Reloc32Short Syntax} \label{table:hunk_reloc32short}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC32SHORT [0x3fc] & A hunk containing relocation information\\ \hline
   & \tt $p$=$1$ & Padding count\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
16 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
16 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ $p$ += $c$ & Update padding count \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
16 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j]$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
   & \tt if ($p$ \& $1$) \{ & check whether padding is required. \\ \hline
16 & \tt $\quad$ & dummy for long-word alignment \\ \hline
   & \tt \} & \\ \hline
\end{longtable}
\end{rkrmtabular}

Due to an oversight, some versions of AmigaDOS do not understand the
hunk type {\tt 0x3fc} properly and use instead {\tt 0x3f7}. This
alternative (but incorrect) hunk type for the short version of the
relocation hunk is still supported currently.

\subsection{HUNK\_RELRELOC32} \label{sec:hunk_relreloc32}

This hunk contains relocation information for 32-bit relative displacements
the {\tt 68020} and later processors offer. Its purpose is to adjust the
offsets of a 32-bit wide PC-relative branches between
segments. \mkey{HUNK\_RELRELOC32}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk RelReloc32 Syntax} \label{table:hunk_relreloc32}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELRELOC32 [0x3fd] & A hunk containing relocation information\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
32 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
32 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
32 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j] - m_a[i] - r_o$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
\end{tabular}
\end{rkrmtabular}

For AmigaDOS versions 37 and up (Kickstart 2.0 and later), the number of
relocation entries~$c$ shall not be larger than $2^{16}$. This is a known
defect of the loader that has currently not yet fixed. If more relocation
entries are needed, they shall be split into multiple chunks.
\smallskip{}

Due to another defect, all elements of this hunk, namely $c$, $r_o$, $j$ and
$r_o$ are only 16 bit wide, which limits the usefulness of this hunk. It is
therefore recommended not to depend on this hunk type at all and avoid
32-bit wide branches between segments. Luckely, the support for this hunk
type is very limited.

\subsection{HUNK\_NAME} \label{sec:hunk_name}

This hunk defines a name for the current segment. The AmigaDOS loader
completely ignores this name, and it does not serve a particular
purpose for the executable file format. However, linkers that bind
object files together use the name to decide which segments to merge
together to a single segment. \mkey{HUNK\_NAME}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Name Syntax} \label{table:hunk_name}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_NAME [0x3e8] & A hunk assigning a name to the current segment\\ \hline
32 & \tt l & Size of the name in long-words \\ \hline
32 $\times$ l & \tt $h_n$ & Hunk name \\ \hline
\end{tabular}
\end{rkrmtabular}

The size of the name is not given in characters, but in 32-bit
units. The name is possibly zero-padded to the next 32-bit boundary to
fill an integer number of long-words. If the name fills an entire
number of long-words already, it is \emph{not} zero-terminated.
\smallskip{}

While the specification does not define a maximum size of the name,
the AmigaDOS loader fails on names longer than 124 character, i.e. 31
long-words.

\subsection{HUNK\_SYMBOL} \label{sec:hunk_symbol}

This hunk defines symbol names and corresponding symbol offsets or
values within the currently loaded segment. Again, the AmigaDOS loader
ignores this hunk, but the linker uses it to resolve symbols with
external linkage to bind multiple object files together. If the
symbol information is retained in the executable file, it may be used
for debugging purposes. \mkey{HUNK\_SYMBOL}
\smallskip{}

The syntax of this hunk reads as follows:
\begin{rkrmtabular}{Hunk Symbol Syntax} \label{table:hunk_symbol}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_SYMBOL [0x3f0] & A hunk assigning symbols to positions within a segment\\ \hline
   & \tt do \{ & Repeat $\ldots$ \\ \hline
8  & \tt $\quad$ $s_t$ & Symbol type \\ \hline
24 & \tt $\quad$ $s_l$ & Symbol length in long-words \\ \hline
   & \tt $\quad$ if ($s_l$ == 0) break & Terminate the hunk \\ \hline
32 $\times$ $s_l$ & \tt $\quad$ $s_n$ & Symbol name, potentially zero-padded \\ \hline
32 & \tt $\quad$ $s_v$ & Symbol value \\ \hline
   & \tt \} while(true) & until zero-sized symbol \\ \hline
\end{tabular}
\end{rkrmtabular}

The length of the symbol name is encoded in long-words, not in
characters. If it does not fill an integer number of long-words, it is
zero-padded; the name is not zero-terminated if it does fill an
integer number of long-words, though. The AmigaDOS loader is currently
limiting the maximum size of the symbol name to 124 characters,
i.e. $s_i < 32$.
\medskip{}

The symbol type $s_t$ defines the nature of the symbol. The symbol
types are defined in {\tt dos/doshunks.h} and shared with the {\tt
  HUNK\_EXT} hunk; the latter hunk type shall not appear in an
executable file, but may only appear in an object file, see
section~\ref{sec:hunk_ext}.\key{HUNK\_EXT}
\smallskip{}

The symbol type can be roughly classified into two classes: If bit $7$
of the type is clear, a symbol is \emph{defined} that may be
referenced by another object file. If bit $7$ is set, the symbol is
\emph{referenced} and requires resolution by a symbol definition with
bit 7 cleared upon linking. Executable files, and thus symbols within
{\tt HUNK\_SYMBOL}, may only contain symbol definitions as references
had been resolved by the linker before.
\smallskip{}

The following table contains the symbol types for definitions and
those may therefore may appear in both {\tt HUNK\_SYMBOL} as part of
executables and {\tt HUNK\_EXT}\key{HUNK\_EXT} as part of object
files; actually, {\tt HUNK\_SYMBOL} will typically only include the
first type of entry, i.e. {\tt EXT\_SYMB}:
\begin{rkrmtabular}{Symbol types in HUNK\_SYMBOL and HUNK\_EXT} \label{table:symboltypes}
\begin{tabular}{|lc|p{10cm}|} \hline
\tt EXT\_SYMB & [0x00] & Definition of a symbol, $s_v + m_a[i]$ is the address of the symbol \\ \hline

\tt EXT\_DEF & [0x01] & Relocation definition, $s_v + m_a[i]$ is the
address of the symbol. References to this symbol are converted into a
relocation information to the offset $s_v$ in hunk $i$. \\ \hline

\tt EXT\_ABS & [0x02] & Absolute value, $s_v$ is the value of the
symbol which is substituted into the executable by the linker. No
relocation information is created, the absolute value is just
substituted. \\ \hline

\tt EXT\_RES & [0x03] & Not longer supported as it is part of the
obsolete dynamic library run-time binding interface, see~\cite{guru}
for more details. \\ \hline
\end{tabular}
\end{rkrmtabular}

Additional symbol types representing references used within {\tt
  HUNK\_EXT}\key{HUNK\_EXT} are documented in
section~\ref{sec:hunk_ext}.

\subsection{HUNK\_DEBUG} \label{sec:hunk_debug}

This hunk contains debug information such as function names and line
number information. Generally, the contents of this hunk is compiler
or assembler specific, and the AmigaDOS loader does not interpret the
contents of this hunk at all, it is just skipped over. \mkey{HUNK\_DEBUG}
\smallskip{}

However, the debug information emitted by the SAS/C compiler for the
``line-debug'' option is also shared by other development tools such
as the DevPac assembler and will be documented here. In this format,
the debug hunk contains for each line of the source file an offset
into the hunk to the code that was compiled from this line.
\smallskip{}

The syntax of this hunk is as follows:
\begin{rkrmtabular}{Hunk Debug Syntax} \label{table:hunk_debug}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline    
   & HUNK\_DEBUG [0x3f1] & Hunk including debug information \\ \hline
32 & l > 3 & Size of the hunk in long-words \\ \hline
\multicolumn{3}{|l|}{Compiler- and configuration specific data for line-debug data:} \\ \hline
32 & \tt $h_o$ & Offset of symbols into the hunk \\ \hline
32 & \tt 'LINE' & These four bytes shall contain the
ASCII characters {\tt 'L','I','N','E'} identifying the type of the
debug information \\ \hline
32 & \tt $l_n$ & Size of the source file name in long-words \\ \hline
32 $\times l_n$ & $n_f$ & source file name that compiled to the current segment in $l_n$ long-words \\ \hline
   & \tt $l -= 3 + l_n$ & Remove long-words read so far \\ \hline
   & \tt while($l$ > 0) \{ & Repeat for all entries \\ \hline
8  & \tt $\quad$ & Dummy byte \\ \hline
24 & \tt $\quad$ $l_l$ & Line number within the source file \\ \hline
8  & \tt $\quad$ & Dummy byte \\ \hline
24 & \tt $\quad$ $l_v$ & Offset into the source file. The source file
at line $l_l$ is compiled or assembled to the code at at address
$m_a[i] + l_v$ and following. \\ \hline
   & \tt $\quad$ $l -= 2$ & Remove the read data \\ \hline
   & \tt \}; & Loop over the hunk. \\ \hline
\end{longtable}
\end{rkrmtabular}

The file name $n_f$ is encoded in $l_n$ long-words, and potentially
padded with $0$-bytes to fill an integer number of long-words. If it
already is an integer number of long-words sized, it is \emph{not}
zero-terminated.
\smallskip{}

The hunk offset $h_o$ is added to all offsets $l_v$ into the hunk to
determine the position of a symbol in the hunk.
\smallskip{}

While~\cite{Bantam} documents the entire hunk contents except the hunk
length~$l$ to be compiler dependent, it is is recommended for custom
debug hunks to always include the hunk offset $h_o$ and the ID field ---
{\tt 'LINE'} in this case --- to simplify linker designs.

\subsection{HUNK\_END} \label{sec:hunk_end}

This hunk terminates the current segment and advances to the next
segment, if any. It does not contain any data. \mkey{HUNK\_END}

\begin{rkrmtabular}{Hunk End Syntax} \label{table:hunk_end}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
  & \tt HUNK\_END [0x3f2] & Terminate a segment\\ \hline
\end{tabular}
\end{rkrmtabular}

\section{The AmigaDOS Loader} \label{sec:loader}

The \emph{dos.library} provides service functions for loading and
releasing binary executables in the \emph{Hunk} format introduced in
section~\ref{sec:binary}. The functions discussed in this section load
such binaries into memory, constructing a segment list from the hunks
found in the files, or release such files. Overlay files are discussed
separately in section~\ref{sec:overlays} due to their additional
complexity.

A segment list is a linearly linked list as defined in
section~\ref{sec:binary}, i.e. the first four bytes of every segment
form a \emph{BPTR} to the following segment of the loaded binary, or
{\tt ZERO} for the last segment.
\smallskip{}

The {\tt seglist} returned from the loader functions may be, for
example, passed into {\tt CreateNewProc()} as argument to the {\tt
  NP\_Seglist} tag for starting a new process.

\subsection{Loading an Executable} \label{sec:loadseg}

The {\tt LoadSeg()}\mkey{LoadSeg()} function loads an executable
binary in the Hunk format and returns a \emph{BPTR} to the first
segment:

\begin{verbatim}
seglist = LoadSeg( name )
D0                 D1

BPTR LoadSeg(STRPTR)
\end{verbatim}
This function loads the binary executable named {\tt name} and returns
a \emph{BPTR} to its first segment in case of success, or {\tt ZERO}
in case of failure. The {\tt name} is passed into the {\tt
  Open()}\key{Open()} function and follows the conventions of this
function for locating the file.
\smallskip{}

The segment list shall be removed from memory via {\tt
  UnLoadSeg()}\key{UnloadSeg()}.
\smallskip{}

This function sets {\tt IoErr()}\key{IoErr()} to an error code in case
of failure, or~$0$ in case of success.

\subsection{Loading an Executable with Additional Parameters} \label{sec:newloadseg}

The {\tt NewLoadSeg()}\mkey{NewLoadSeg()} function loads an
executable providing additional data for loading.

\begin{verbatim}
seglist = NewLoadSeg(file, tags)
D0                    D1    D2

BPTR NewLoadSeg(STRPTR, struct TagItem *)

seglist = NewLoadSegTagList(file, tags)
D0                           D1    D2

BPTR NewLoadSegTagList(STRPTR, struct TagItem *)

seglist = NewLoadSegTags(file, ...)

BPTR NewLoadSegTags(STRPTR, ...)
\end{verbatim}

This function loads a binary executable from {\tt file} and returns a
\emph{BPTR} to its first segment, similar to {\tt
  LoadSeg()}\key{LoadSeg()}.
\smallskip{}

Additional parameters may be provided in the form of a TagList, passed
in as {\tt tags}. The first two functions are identical and differ
only by their naming convention; the last function prototype also
refers to the same entry within the \emph{dos.library}, though uses a
different calling convention where the second and all following
arguments form the TagList itself. This TagList is build on the stack,
and the pointer to this stack-based TagList is passed in.
\smallskip{}

While this function looks quite useful, AmigaDOS does currently not
define any tags for this function, and thus no additional
functionality over {\tt LoadSeg()} is provided.
\smallskip{}

The segment list returned by this function shall be removed from
memory via {\tt UnLoadSeg()}\key{UnloadSeg()}, a specialized unloader
function is not required for this call.

\subsection{Loading an Executable through Call-Back Functions} \label{sec:internalloadseg}

The {\tt InternalLoadSeg()}\mkey{InternalLoadSeg()} function loads a
binary executable, retrieving data and memory through call-back
functions. While {\tt LoadSeg()}\key{LoadSeg()} always goes through
the \emph{dos.library} and the \emph{exec.library} for reading data
and allocating memory, this function instead calls through
user-provided functions.

\begin{verbatim}
seglist = InternalLoadSeg(fh,table,funcs)
D0                        D0  A0   A1   

BPTR InternalLoadSeg(BPTR,BPTR,struct LoadSegFuncs *)
\end{verbatim}
This function loads a binary executable in the hunk format from an
opaque file handle {\tt fh} through functions in the {\tt funcs}. The
{\tt table} argument shall be {\tt ZERO} when loading regular binaries
or the root node of an overlay file, and shall be a \emph{BPTR} to the
array containing pointers to all segments when loading a non-root
overlay node, see section~\ref{sec:overlays}.
\smallskip{}

The {\tt LSFuncs} structure contains function pointers through which
this function loads data or retrieves memory. It looks as follows: \mkey{LoadSegFuncs}
\begin{verbatim}
struct LoadSegFuncs {
    LONG __asm ReadFunc(register __d1 BPTR fh,
                        register __a0 APTR buffer,
                        register __d0 ULONG size,
                        register __a6 struct DosLibrary *DOSBase);
    APTR __asm AllocMem(register __d0 ULONG size,
                        register __d1 ULONG flags,
                        register __a6 struct ExecBase *SysBase);
    void __asm FreeMem (register __a1 APTR mem,
                        register __d0 ULONG size,
                        register __a6 struct ExecBase *SysBase);
}
\end{verbatim}
The {\tt ReadFunc()} function retrieves {\tt d0} bytes from an opaque
file handle passed into register {\tt d1} and places the read bytes
into the buffer pointed to by register {\tt a0}, it shall return the
number of bytes read in register {\tt d0}, or a negative value in case
of error. Note that the file handle {\tt d1} need not to be a file
handle as returned by the {\tt Open()}\key{Open()} function, it is
only a copy of the {\tt fh} argument provided to {\tt
  InternalLoadSeg()}. Register {\tt a6} is loaded by a pointer to the
\emph{dos.library}.
\smallskip{}

The {\tt AllocMem()} function allocates {\tt d0} bytes of memory,
using requirement flags from {\tt exec/memory.h} such as {\tt
  MEMF\_CHIP} to require chip memory or {\tt MEMF\_FAST} for fast
memory. This function shall return a pointer to the allocated memory
in register {\tt d0}, or {\tt NULL} in case of failure. Register {\tt a6}
is loaded with a pointer to the \emph{exec.library}.
\smallskip{}

The {\tt FreeMem()} function releases a block of {\tt d0} bytes
pointed to by {\tt a0}. Register {\tt a6} is loaded with a pointer to
the \emph{exec.library}.
\medskip{}

The purpose of this function is to load a segment or a binary without
having access to a file or a \emph{file system}; for example, this
function could load binaries from ROM-space, or from the Rigit Disk
Block of a boot partition. In particular, the {\tt fh} argument does
not need to be a regular \emph{file handle}; it is rather an opaque
value identifying the source. The {\tt InternalLoadSeg()} function
does not interpret this argument, but rather passes it into {\tt
  funcs->ReadFunc()} in register {\tt d1}.
\smallskip{}

When allocating memory, the {\tt InternalLoadSeg()} function follows
the conventions of the {\tt AllocVec()} and {\tt FreeVec()} functions
and stores the number of allocated bytes in the first four bytes of
the allocated memory block. In specific, the memory allocator and
memory releaser functions provided in the {\tt LoadSegFuncs} structure
\emph{do not need} to store the memory sizes, and the exec {\tt
  AllocMem()} and {\tt FreeMem()} functions satisfy the interfaces for
{\tt InternalLoadSeg()} function already.
\smallskip{}

This function does not set {\tt IoErr()}\key{IoErr()} consistently,
unless the functions within {\tt LoadSegFuncs} do. Callers should also
call {\tt SetIoErr(0)} upfront this function to identify all errors.

\subsection{Unloading a Binary} \label{sec:unloadseg}

The {\tt UnLoadSeg()}\mkey{UnLoadSeg()} function releases a linked
list of segments as returned by {\tt LoadSeg()}\key{LoadSeg()} or {\tt
  NewLoadSeg()}\key{NewLoadSeg()}.

\begin{verbatim}
success = UnLoadSeg( seglist )
D0                     D1

BOOL UnLoadSeg(BPTR)
\end{verbatim}
This function releases all segments chained together by {\tt
  LoadSeg()} and {\tt NewLoadSeg()} and returns their memory back into
the system pool. This function \emph{also} accepts overlaid segments,
see section~\ref{sec:overlays}, and releases additional resources
acquired for them.
\smallskip{}

Segment lists loaded through {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()} require in general a more
generic unloader. They shall be be released through {\tt
  InternalUnLoadSeg()}\key{InternalUnLoadSeg()} instead,
see~\ref{sec:internalunloadseg}.
\smallskip{}

This function returns a non-zero result in case of success, or~$0$ in
case of error. Currently, the only source of error is passing in {\tt
  ZERO} as segment list, all other cases will indicate success. In
particular, this function does not attempt to check return codes of
the function calls required to release resources associated to
overlaid files.

\subsection{UnLoading a Binary through Call-Back Functions} \label{sec:internalunloadseg}

The {\tt InternalUnLoadSeg()}\mkey{InternalUnLoadSeg()} function
releases a segment list loaded through {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()}.

\begin{verbatim}
success = InternalUnLoadSeg(seglist,FreeFunc)
D0                          D1       A1

BOOL InternalUnLoadSeg(BPTR,
                       void __asm (*)(register __a1 APTR,
                                      register __d0 ULONG,
                                      register __a6 struct ExecBase 
                                                    *SysBase))
\end{verbatim}
This function releases a segment list created by {\tt
  InternalLoadSeg()} passed in as {\tt seglist}. To release memory, it
uses a function pointed to by {\tt a1}. This function expects the
memory block to release in register {\tt a1} and its size in register
{\tt d0}. Additionally, register {\tt a6} will be populated by a
function to the \emph{exec.library}.
\smallskip{}

This function pointer should be identical to the {\tt FreeMem}
function pointer in the {\tt LoadSegFuncs} structure provided to {\tt
  InternalAllocMem()}, or at least shall be able to release memory
allocated by the {\tt AllocMem} function pointer in this structure.
Note that the {\tt InternalLoadSeg()} stores the sizes of the
allocated memory blocks itself and that {\tt FreeFunc} does not need
to retrieve them.
\smallskip{}

This function is also able to release overlaid binaries, but then
closes the file stored in the root node of the overlay tree (see
section~\ref{sec:overlays}) through the {\tt Close()} function of the
\emph{dos.library}. It therefore can only release overlaid files that
were loaded from regular \emph{file handles} obtained through {\tt
  Open()}\key{Open()}.
\smallskip{}

This function returns a non-negative result code in case of success,
or $0$ in case of failure. Currently, the only cause of failure is to
pass in a {\tt ZERO} segment list, the function does not check of the
result code of {\tt Close()} on the file handle of overlaid files. It
therefore neither sets {\tt IoErr()} consistently in case of failure.

\section{Overlays} \label{sec:overlays}

While regular binary executables are first brought to memory in entity
and then brought to execution, overlaid binaries only keep a fraction
of the executable code in memory and then load additional code parts
as required, potentially releasing other currently unused code parts
and thus making more memory available.
\smallskip{}

Overlays are an extension of the AmigaDOS hunk format that splits the
executable into a root node that is loaded initially and stays
resident for the lifetime of the program, and one or multiple
extension or overlay nodes that are loaded and unloaded on
demand. Locating the overlay nodes, loading them to memory and
releasing unused nodes is performed by the \emph{overlay manager}, a
short piece of program.
\smallskip{}

AmigaDOS does not provide a ROM-resident overlay manager itself,
i.e. the \emph{dos.library} does not provide an overlay manager
itself, though it provides services overlay managers may use. Instead,
the overlay manager is part of the root node of an overlaid binary,
and thus overlay management is fully under control of the application.
\smallskip{}

However, the Amiga linker \emph{ALink}, the Software Distillery linker
\emph{BLink} and the SAS/C linker \emph{SLink} include a standard
overlay manager, and this manager and its properties are discussed in
greater detail in this section.

\subsection{The Overlay File Format}

A binary file making use of overlays consists of several nodes, one
root node and several overlaid nodes. Nodes contain multiple
segments, defined through {\tt HUNK\_CODE}, {\tt HUNK\_DATA} or {\tt
  HUNK\_BSS} as in regular (non-overlaid) binary files.
\smallskip{}

Each node, the root node and all overlaid nodes start with a {\tt
  HUNK\_HEADER}\key{HUNK\_HEADER} identifying which segments are
contained in the node. The root node is terminated by a {\tt
  HUNK\_OVERLAY}\key{HUNK\_OVERLAY} on which loading stops; this hunk
contains additional data for the purpose of the overlay manager, and
therefore the data within this hunk depends on the overlay manager.
\smallskip{}

Every other overlay node terminates with a {\tt HUNK\_BREAK}, and
loading stops there as well. This hunk does not contain any data. The
overall structure of an overlaid binary therefore looks as follows:

\begin{rkrmtable}{Overlay File Format} \label{table:overlayformat}
{\bf Hunk Type}   & {\bf Description}\\ \hline \hline
\tt HUNK\_HEADER  & Defines segments for the root node \\ \hline
\tt HUNK\_CODE    & Contains the overlay manager and other resident code \\ \hline
\tt \ldots        & Other hunks, such as relocation information \\ \hline
\tt HUNK\_END     & Terminates the previous segment \\ \hline
\tt HUNK\_OVERLAY & Metadata for the overlay manager, see~\ref{sec:hunk_overlay} \\ \hline
\tt do \{         & Repeats over all overlay nodes \\ \hline
\tt $\quad$ HUNK\_HEADER  & Defines the segments in this overlay node \\ \hline
{\tt $\quad$ HUNK\_CODE} or {\tt HUNK\_DATA} & First segment of the overlay node \\ \hline
\tt $\quad$ \ldots & Other hunks of this overlay node \\ \hline
\tt $\quad$ HUNK\_END    & Terminates the last segment \\ \hline
\tt $\quad$ HUNK\_BREAK  & Terminates the first overlay node, see~\ref{sec:hunk_break} \\ \hline
\tt \} while(!end of file); & This pattern repeats until end of file \\ \hline
\end{rkrmtable}

\subsection{The Hierarchical Overlay Manager} \label{sec:alinkmgr}

The overlay manager that comes with the standard Amiga linkers
\emph{ALink}, \emph{BLink} and \emph{SLink} structures overlay nodes
into a tree such as the following:

\begin{center}
\begin{forest}
  [root
    [a [b] [c [d] [e]] [f] [g]] [h] [k [l] [m]]
  ]
\end{forest}
\end{center}

Only those nodes that form a path from the root to one of the nodes of
the tree can be in memory at a time. Thus, for the above example, the
root node and nodes $a$, $c$ and $e$ can be in memory simultaneously,
or the root node, and nodes $k$ and $m$ can be loaded at the same
time, but not the nodes $a$, $g$ and $h$ because they do not form a
path from the root to one of the nodes.
\smallskip{}

Thus, in the above example, if nodes $a$ and $f$ are in memory, and
node $l$ is required, the nodes $a$ and $f$ will be removed from
memory, and nodes $k$ and $l$ are loaded. Even though $k$ is not
explicitly requested, it needs to be loaded as it is the parent of
$l$.
\medskip{}

Every node in the overlay tree is identified by two numbers: The depth
\mkey{Level (overlay)} of the node, which identifies the level within
the tree where a node is located. The root node is at level~$0$, the
nodes~$a$, $h$ and~$k$ forms level~$1$ in the above example,
nodes~$b$, $c$, $f$, $g$ and~$l$ and~$m$ form level~$2$, and nodes~$d$
and~$e$ are level~$3$.
\smallskip{}


The second number is the ordinate number of a node.\mkey{Ordinate
  (overlay)} The ordinate enumerates nodes from left to right within a
level, and it starts from~$1$ in the standard overlay manager. In the
above example, $a$ is at ordinate~$1$, $h$ at ordinate~$2$, and $k$ at
ordinate~$3$. At level~$2$, node~$b$ has ordinate~$1$, node~$c$
ordinate~$2$ and so on.


\subsection{HUNK\_OVERLAY} \label{sec:hunk_overlay}

This hunk terminates the loading process and indicates the end of the
main (first) segments. The {\tt HUNK\_OVERLAY} contains meta-data ---
the overlay table --- for the overlay manager. This table contains
information where symbols within the overlaid segments are
located. Section~\ref{sec:overlay} provides more information on
overlays. The format of the data within this hunk depends on the
overlay manager which shall be included in the first segment of the
executable itself as AmigaDOS does not contain a resident overlay
manager.\mkey{HUNK\_OVERLAY}
\smallskip{}

The standard AmigaDOS linkers, {\tt ALink} and {\tt BLink} both
include an overlay manager. Each entry in its overlay table describes
a symbol that is located in one of the overlay nodes. The format of
{\tt HUNK\_OVERLAY} reads as follows:
\begin{rkrmtabular}{MANX Hunk Overlay Syntax} \label{table:hunk_overlay}%
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_OVERLAY [0x3f5] & Overlay table definition\\ \hline
32 & \tt $l$ & Size of the overlay table, it is $l+1$ long-words large. \\ \hline
\multicolumn{3}{|l|}{Format for the standard overlay manager, $l+1$ long-words.} \\ \hline
32 & \tt $o_d$ & Number of levels in the overlay tree, including the root node \\ \hline
   & \tt for($i$ = 1;$i$ < $o_d$;i++) \{ & For all nodes, excluding the root node \\ \hline
32 & \tt $\quad$ $0$ & Currently loaded ordinate, shall be zero \\ \hline
   & \tt \} & That is, $o_d-1$ zeros \\ \hline
   & \tt $l -= o_d$ & Count removed long-words \\ \hline
   & \tt $s  = 0$   & Start with symbol $0$ \\ \hline
   & \tt while($l \ge 0$) \{ & Repeat over the overlay table \\ \hline

32 & \tt $\quad$ $o_p[s]$ & Absolute file offset of the {\tt
  HUNK\_HEADER} of the overlay node containing the symbol. \\ \hline
64 & \tt $\quad$ & Two reserved long-words. \\ \hline

32 & \tt $\quad$ $o_l[s]$ & Level of the overlay node containing the symbol,
the root level containing the overlay manager is level~$0$. \\ \hline

32 & \tt $\quad$ $o_n[s]$ & Ordinate of the overlay node, enumerating
overlay nodes of the same depth. \\ \hline

32 & \tt $\quad$ $o_h[s]$ & Hunk index of the first hunk within
the overlay node. \\ \hline

32 & \tt $\quad$ $o_s[s]$ & Hunk index of the hunk containing the symbol
described by this entry in the overlay node. \\ \hline

32 & \tt $\quad$ $o_o[s]$ & Symbol offset within hunk $o_s$ \\ \hline
   & \tt $\quad$ $l$ -=8 & Remove 8 long words. \\ \hline
   & \tt $\quad$ $s++$   & Advance to next symbol. \\ \hline
   & \tt \} & End of loop over table \\ \hline
\end{longtable}
\end{rkrmtabular}

Note that the overlay table is $l+1$ and not $l$ long-words large,
i.e. a table only defining a single symbol would be indicated by a
value of $l=7$. While the payload data of {\tt HUNK\_OVERLAY} is
always $l+1$ long-words large, with $l$ indicated in the first
long-word of the hunk, the format of the subsequent data is specific
to the overlay manager used.
\medskip{}

Irrespective of the overlay manager used, the AmigaDOS loader injects
overlay-specific data into the first segment loaded from disk, that
is, into the root-node. The data placed there is also required to
release all resources associated to overlays and is expected there by
{\tt UnLoadSeg()}\key{UnLoadSeg()} and {\tt
  InternalUnLoadSeg()}\key{InternalUnLoadSeg()}.
\smallskip{}

The first bytes of the root node shall therefore form the following
structure:
\begin{verbatim}
struct OverlayHeader {
    UWORD         oh_Jump[2];   /* Forms a branch to the startup code */
    LONG          oh_Magic;     /* Shall be 0x0000abcd                */
    BPTR          oh_FileHandle;/* Filled by the loader with the fh   */
    struct OVTab *oh_OVTab;     /* Overlay table from HUNK_OVERLAY    */
    BPTR          oh_Segments;  /* Array of segment BPTRs             */
    BPTR          oh_GV;        /* standard Global Vector             */
};
\end{verbatim}
As said earlier, this structure is expected to be present at the start
of the first hunk of the root node. The members {\tt oh\_FileHandle}
to {\tt oh\_GV} are filled in by the AmigaDOS loader, i.e. {\tt
  LoadSeg()} and related functions, but {\tt oh\_Jump} and {\tt
  oh\_Magic} shall be part of the segment itself.
\smallskip{}

{\tt oh\_Jump} form valid {\tt 68K} opcodes, and shall contain a jump
or branch branch around this structure. This is because loaded
binaries are executed from the first byte of the first segment
loaded. Otherwise, the CPU would run into the data of the structure
which likely forms invalid or illegal opcodes. The AmigaDOS Loader
itself does not interpret the values here, just expects them to be
present.
\smallskip{}

{\tt oh\_Magic} shall contain the ``magic'' long-word {\tt
  0xabcd}. This value is neither filled or interpreted by the loader,
but nevertheless shall be present. It is, however, checked by {\tt
  UnLoadSeg()}\key{UnLoadSeg()} and used there as an identifier for
the {\tt OverlayHeader} structure. If this identifier is not present,
{\tt UnLoadSeg()} will not be able to release resources associated to
overlays.
\smallskip{}

{\tt oh\_FileHandle} will be filled by the AmigaDOS loader with a
\emph{BPTR} to the \emph{FileHandle} from which the root node has been
loaded, or with the first argument of {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()}. This handle is used by
the overload manager to load all subsequent overlay nodes. Also, {\tt
  UnLoadSeg()}\key{UnLoadSeg()} and related functions call {\tt
  Close()}\key{Close()} on the handle stored here as the file needs to
stay open for the life time of the loaded program.
\smallskip{}

{\tt oh\_OVTab} is filled by the AmigaDOS loader to a pointer to the
payload data of {\tt HUNK\_OVERLAY}. The standard overlay manager
stores here for every externally referenced symbol in an overlay node
a structure that records for each tree level the ordinate of the
currently loaded overlay node, and for all externally referenced
symbols the position of the symbol within the overlay tree:
\mkey{OVTab}
\begin{verbatim}
struct OVTab {
    ULONG ot_TreeDepth;   /* Depth of the tree, including the root    */
    ULONG ot_LoadedOrd[]; /* The loaded ordinate, indexed by level-1  */
}
struct SymTab {
    ULONG ot_FilePosition;/* File position of HUNK_HEADER of the node */
    ULONG ot_Reserved[2]; /* Not in use                               */
    ULONG ot_Level;       /* Level of the overlay node                */
    ULONG ot_Ordinate;    /* Ordinate of the overlay node             */
    ULONG ot_FirstHunk;   /* First segment of the overlay node        */
    ULONG ot_SymbolHunk;  /* Segment containing the referenced symbol */
    ULONG ot_SymbolOffset;/* Offset of the segment within the segment */
} []                      /* Repeats for each symbol */
\end{verbatim}
That is, the overlay table starts with the tree depth $o_d$ and an
array of $o_d-1$ elements where each element stores the ordinate of
the currently loaded overlay node. If an entry in this array is~$0$,
no overlay node at this tree level is loaded, otherwise it is the
$1$-based ordinate of the node.
\smallskip{}

The ordinate table is followed by the symbol table. The purpose of
this structure is that it allows the overlay manager on a reference to
such an external symbol to find and load the overlay node containing
the symbol, and then resolve references to it. How exactly it does so
is explained in more detail in section~\ref{sec:stdoverlay}. The
elements of this structure are already briefly introduced in
table~\ref{table:hunk_overlay}.
\smallskip{}

{\tt oh\_Segments} is filled by the AmigaDOS loader to a \emph{BPTR}
to the segment table of the loaded binary. The size of this table is
taken from $t_{\mbox{size}}$ in the {\tt HUNK\_HEADER}\key{HUNK\_HEADER} of the root
node, see table~\ref{table:hunk_header}. Each element in this array
contains a \emph{BPTR} to a segment of the loaded binary, and it is
indexed by the segment number, counting from~$0$ for the first segment
of the root node.
\smallskip{}

When parsing a {\tt HUNK\_HEADER}, the array entries $t_{\mbox{num}}$
to $t_{\mbox{max}}$ will be populated with the \emph{BPTR}s to the
segments allocated of the node described by this hunk, and when
unloading an overlay node, the corresponding segments will be
unlinked, released and then cleared out.
\medskip{}

{\tt oh\_GV} is, finally, filled with the \emph{Global
  Vector}\key{Global Vector} of the \emph{dos.library} containing all
regular functions in the library, as required by BCPL code. Overlay
managers implemented in C or assembler will not make use of it and
instead call vectors of the \emph{dos.library} through the
\emph{dos.library} base address loaded in register {\tt a6}.

\subsection{The MANX Overlay Manager}

The Aztec C compiler from MANX offers an alternative overlay manager that is
related to the Resource Manager from MacOs. It does not organize overlay
notes in a hierarchy, but only in a single level; however, all nodes of
this single level can be loaded and unloaded independently from each other,
either on demand through the function {\tt segload()} provided by the MANX
compiler library, or whenever a function of an overlaid node is called. The
corresponding {\tt freeseg()} function unloads a node again. A node consists
of one or more hunks that are loaded and unloaded jointly. Unfortunately,
this overlay manager depends on self-modifying code and ignores the
instruction cache present in later members of the Motorola 68K family, and
is therefore no longer safe to use.
\smallskip{}

The MANX overlay manager organizes its nodes through the data in the {\tt
  HUNK\_OVERLAY} hunk, which, however, is in a different format than the one
documented in section~\ref{sec:hunk_overlay}, and trampolines that
direct the code flow for non-resident functions to the overlay manager.
The contents of the {\tt HUNK\_OVERLAY} hunk contains offsets within the
file, to the trampoline functions and to the symbol table that provides
information in which hunks the overlaid functions reside. The trampolines
are not part of {\tt HUNK\_OVERLAY} but reside at the beginning of the {\tt
  HUNK\_DATA} hunk, relative to the
{\tt \textunderscore\textunderscore{}H1\textunderscore{}org} symbol.
\smallskip{}

Even though the structure of the {\tt HUNK\_OVERLAY} differs from the one in
section~\ref{sec:hunk_overlay}, the AmigaDOS {\tt LoadSeg()} function does
not care about the contents of this hunk as long as its first {\tt LONG}
word indicates its size. It provides the data within to the program as-is
through {\tt oh\_OVTab} of the {\tt OverlayHeader} which shall be present at
the beginning of the first segment of the binary; this structure, of course,
does not change from its definition in section~\ref{sec:hunk_overlay} except
that data within the overlay hunk is organized differently:

\begin{verbatim}
struct ManxOverlayHeader {
    UWORD          oh_Jump[2];   /* Forms a branch to the startup code */
    LONG           oh_Magic;     /* Shall be 0x0000abcd                */
    BPTR           oh_FileHandle;/* Filled by the loader with the fh   */
    struct MANXOv *oh_OVTab;     /* Overlay table from HUNK_OVERLAY    */
    BPTR           oh_Segments;  /* Array of segment BPTRs             */
    BPTR           oh_GV;        /* standard Global Vector             */
};
\end{verbatim}

The overlay structure for the MANX compiler reads on disk as follows:
\begin{rkrmtabular}{Hunk Overlay Syntax} \label{table:hunk_overlay_manx}%
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_OVERLAY [0x3f5] & Overlay table definition for MANX\\ \hline
32 & \tt $l$ & Size of the overlay table, it is $l+1$ long-words large. \\ \hline
\multicolumn{3}{|l|}{Format for the MANX overlay manager, $l+1$ long-words.} \\ \hline
32 & \tt $o_d$ & Number of nodes in the overlay, excluding the root node \\ \hline
   & \tt for($i$ = 1;$i$ < $o_d$;i++) \{ & For all nodes, excluding the root node \\ \hline
32 & \tt $\quad$ $o_p[i]$ & Absolute file offset of the {\tt HUNK\_HEADER} of the overlay node \\ \hline
16 & \tt $\quad$ $o_t[i]$ & Offset of the first trampoline relative to the
data hunk of the root node \\ \hline
16 & \tt $\quad$ $o_s[i]$ & Offset to the symbol table relative to $o_p[0]$ \\ \hline
   & \tt \} & \\ \hline
   & \tt $l -= o_d \times 2$ & Count removed long-words \\ \hline
   & \tt $s  = 0$   & Start with symbol $0$ \\ \hline
   & \tt while($l \ge 0$) \{ & Repeat over the symbol table \\ \hline
16 & \tt $\quad$ $o_h[s]$ & Hunk within which the symbols reside, or 0 for end of symbols for this hunk \\ \hline
16 & \tt $\quad$ $o_c[s]$ & Symbol count for hunk $o_h[s]$ \\ \hline
   & \tt $\quad$ $l$ -=1 & Remove one long words. \\ \hline
   & \tt $\quad$ $s++$   & Advance to next entry. \\ \hline
   & \tt \} & End of loop over table \\ \hline
\end{longtable}
\end{rkrmtabular}

In memory, it is approximately described by the following pseuo-structure,
noting that some elements are variably sized and are thus hard to represent
in the C syntax:

\begin{verbatim}
struct MANXOv {
    ULONG ot_NodeCount;         /* Number of overlay nodes            */
    struct OvNode {             /* One per overlay node               */
        ULONG ot_FilePosition;  /* Position of HUNK_HEADER            */
        UWORD ot_TrampolineOff; /* Offset of the first trampoline     */
        UWORD ot_SymbolOffset;  /* Relative to &ot_NodeCount+1        */
    }     ot_Nodes[];          
}
struct SymTab {
    UWORD ot_Hunk;        /* Hunk containting symbols or 0 for end    */
    UWORD ot_Count;       /* Number of trampolines to patch           */
} []                      /* Repeats multiple times */
\end{verbatim}

The element $o_d$ representing ${\tt ot\_NodeCount}$ defines the number
overlay nodes that can all be loaded or unloaded individually. The element
$o_p[i]$ providing {\tt ot\_FilePosition} is the offset relative to the
start of the binary file at which the {\tt HUNK\_HEADER} of the
overlay node~$i$ is found. The offset~$o_t[i]$ giving {\tt
  ot\_TrampolineOff} is the offset of the first trampoline to a symbol
within overlay node~$i$; the offset is relative to the second hunk of the
root node, or more precisely, relative to {\tt
  \textunderscore\textunderscore{}H1\textunderscore{}org}.
\smallskip{}

Finally, $o_s[i]$, or in memory {\tt ot\_SymbolOffset}, is used by the MANX
overlay manager to find the first symbol descriptor within the second part
of the {\tt HUNK\_OVERLAY}, i.e. a {\tt SymTab} structure. The offset is
relative to the third long word within this hunk, or as $l$ is not part of
the internal memory representation, relative to {\tt \&ot\_NodeCount+1}.  The
target of this offset is a sequence of $o_h[s]$,$o_c[s]$ pairs. The first
member of this pair, $o_h[s]$, or {\tt ot\_Hunk} in memory, is the hunk
number containing the overlaid symbol; this clearly cannot be~$0$ as this
would be within root node. The second member of the pair, $o_c[s]$ or
{\tt ot\_Count} is the number of symbols within this hunk. The symbols for
the loaded node terminate with an $o_h[s]$ entry being~0.
\smallskip{}

The {\tt HUNK\_OVERLAY} hunk does not contain the symbol offsets
itself. Rather, symbol offsets are part of the trampoline which is included
in the second hunk of the root node. The offset to the first trampoline of
an overlay node relative to the start the second hunk is provided
by~$o_t[i]$, that is, by {\tt ot\_TrampolineOff}.
\smallskip{}

Each trampoline looks as follows on disk:
\begin{rkrmtabular}{MANX Overlay Trampoline} \label{table:trampoline_manx}%
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
16 & \tt 0x6100 & 68K Opcode of {\tt bsr.w} \\ \hline
16 & \tt $t_j$  & Branch offset to overlay manager \\ \hline
8  & \tt $t_n$  & Overlay node number \\ \hline
24 & \tt $t_o$  & Offset of the overlay symbol within the loaded hunk \\ \hline
\end{longtable}
\end{rkrmtabular}

In memory, this is equivalent to the following structure:
\begin{verbatim}
struct MANXTrampoline {
    UWORD mt_BSR;               /* filled with 0x6100          */
    WORD  mt_OvMngrOffset;      /* Offset to overlay manager   */
    UBYTE mt_OverlayNode;       /* Overlay node, counts from 0 */
    UBYTE mt_SymbolOffset[3];   /* Big-endian 24-bit offset    */
};
\end{verbatim}

The start of the trampoline is a word-sized relative subroutine jump to the
overlay manager itself. As the trampoline is typically in the second hunk of
the root node, but the code of the overlay manager is in its first hunk,
this branch goes to a long absolute jump to the overlay manager. The element
$t_j$, or {\tt mt\_OvMngrOffset} is the branch distance to this jump. When
building an overlaid binary, the MANX linker resolves all references to
overlaid symbols to a trampoline as indicated above, and when the code of
the loaded binary calls through them, the overlay manager fetches from the
return stack of the 68K processor the address of the trampoline.
\smallskip{}

From $t_n$, or {\tt mt\_OverlayNode} in memory, it finds the entry in the
first part of the {\tt HUNK\_OVERLAY}, namely a triple $o_p[i]$, $o_t[i]$,
$o_s[i]$ of file offset, trampoline offset and symbol offset, that is, a
{\tt OvNode} structure. This overlay node index is zero-indexed, i.e. the
first overlay node is node~0, corresponding to the first element of the
{\tt ot\_Nodes} array. The $t_o$ offset, or {\tt mt\_SymbolOffset} in memory,
is finally the offset of the symbol within its hunk.
\smallskip{}

When an overlay node is loaded, the overlay manager uses the symbol table
consisting of {\tt SymTab} structures and relocates from them the trampolines to
the symbols; that is, the opcode of the relative branch in the first word of
the trampoline is replaced by an absolute jump\footnote{Here the MANX
overlay manager fails to clear the instruction cache, causing failure on
later members of the 68K family.}, opcode {\tt 0x4ef9}. The subsequent
long is filled by the address of the symbol, computed from the start of the hunk
$o_h[s]$ in {\tt HUNK\_OVERLAY} plus the offset $t_o$ stored in the
trampoline. The branch offset $t_j$ is moved to the last 16 bits of the
trampoline to enable the overlay manager to restore it back when the overlay
node is unloaded.
\smallskip{}

Such a patched symbol then looks as follows:
\begin{verbatim}
struct MANXPatchedTrampoline {
    UWORD mt_JMP;               /* filled with 0x4ef9          */
    APTR  mt_OVSymbol;          /* absolute symbol address     */
    WORD  mt_OvMngrOffset;      /* Offset to overlay manager   */
};
\end{verbatim}

When unloading an overlay node, the original trampolines have to be
restored such that a call to an overlay symbol triggers again loading the
hunks containing the symbol from disk. For that, {\tt mt\_JMP} is again
replaced by a {\tt bsr.w} instruction, {\tt mt\_OvMngrOffset} is moved to the
next word, and the hunk offset is re-injected by counting the hunks within
the singly linked list of loaded segments. Finally, {\tt mt\_SymbolOffset}
is re-computed by subtracting the base address of the segment from the absolute
symbol address.

\subsection{HUNK\_BREAK} \label{sec:hunk_break}

This hunk terminates the loading process and indicates the end of an
overlay node. The hunk itself does not contain any
data. \mkey{HUNK\_BREAK}

\begin{rkrmtabular}{Hunk Break Syntax} \label{table:hunk_break}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
  & \tt HUNK\_BREAK [0x3f6] & Terminate a segment\\ \hline
\end{tabular}
\end{rkrmtabular}

\subsection{Loading an Overload Node} \label{sec:loadsegoverload}

The {\tt LoadSeg()}\key{LoadSeg()} function is not only able to load
the root segments of an overlaid binary, it can also be used for
loading an overlaid node and all segments within it. For that, the
file pointer shall first be placed with {\tt Seek()}\key{Seek()} to
the file offset of the {\tt HUNK\_HEADER} of the overlaid node. This
file offset may, for the standard hierarchical overlay manager, be
taken from the {\tt ot\_FilePosition} of the overlay table.

\begin{verbatim}
seglist = LoadSeg( name ,table, fh)
D0                 D1    D2     D3

BPTR LoadSeg(STRPTR ,BPTR, BPTR)
\end{verbatim}
For overlaid node loading, the first argument {\tt name} shall be
{\tt NULL}, which is used as an indicator to this function to
interpret two additional (usually hidden) arguments.
\smallskip{}

{\tt table} is a \emph{BPTR} to the segment table, and may be taken
from {\tt oh\_Segments}. It contains \emph{BPTRs} to all allocated
segments, see section~\ref{sec:hunk_overlay}.
\smallskip{}

{\tt fh} is a \emph{BPTR} to the \emph{FileHandle} from which the
overlay node is to be loaded. This handle may be taken from
{\tt oh\_FileHandle}, see section~\ref{sec:hunk_overlay}.
\smallskip{}

While this function allocates and loads the segments in the overlaid
node, it does not attempt to release already allocated segments
populating the same entries in the segment table; it is instead up to
the overlay manager to clean up the segment table upfront,
see~\ref{sec:unloadnode}. The information which segments will be
populated by an overlay node may be taken from the {\tt ot\_FirstHunk}
member of the overlay table. Due to the tree structure imposed by the
hierarhical overlay manager, it has to release all segments from {\tt
  ot\_FirstHunk} onwards up to the end of the table, unlink the
segments contained therein, and then load another overlay node through
{\tt LoadSeg()}.
\smallskip{}

Note that this function populates the same offset in the
\emph{dos.library} as the regular {\tt LoadSeg()}\key{LoadSeg()}
function; the function distinguishes loading regular binaries through
a file name from loading overlay nodes by the first argument.
\smallskip{}

As the regular {\tt LoadSeg()} call, this function returns the
\emph{BPTR} to the first segment loaded on success, links all loaded
segments together, populates the segment table, and then sets {\tt
  IoErr()}\key{IoErr()} to~$0$. On error, it returns {\tt ZERO} and
installs an error code in {\tt IoErr()}.

\subsection{Loading an Overlay Node through Call-Back Functions}

The {\tt InternalLoadSeg()}\key{InternalLoadSeg()} function can also load
an overlay node.

\begin{verbatim}
seglist = InternalLoadSeg(fh,table,funcs)
D0                        D0  A0   A1   

BPTR InternalLoadSeg(BPTR,BPTR,struct LoadSegFuncs *)
\end{verbatim}

The {\tt fh} argument is an opaque file handle that is suitable for
the {\tt ReadFunc()} provided by the {\tt funcs} structure. The
corresponding file pointer shall first be placed to the file offset of
the {\tt HUNK\_HEADER} of the overlaid node, e.g. by a functionality
similar to {\tt Seek()}\key{Seek()} for regular
\emph{FileHandles}. This file offset may, for the standard
hierarchical overlay manager, be taken from the {\tt ot\_FilePosition}
within the overlay table.
\smallskip{}

The {\tt table} shall be the \emph{BPTR} to the segment table; this
may be taken from {\tt oh\_Segments}. This argument determines whether
a regular binary load is requested, or an overlay node is to be
loaded. In the latter case, this argument is non-{\tt ZERO}.
\smallskip{}

Like {\tt LoadSeg()}\key{LoadSeg()}, this function does not release
segments in populated entries in the segment list, it is up to the
overlay manager to unload these segments. The information which
entries of the segment table will be populated by an overlay node may
be taken from the {\tt ot\_FirstHunk} member of the overlay table, see
also~\ref{sec:loadsegoverload}.
\smallskip{}

The {\tt funcs} argument points to a {\tt LoadSegFuncs} structure as
defined in section~\ref{sec:internalloadseg} and contains functions for
reading data and allocating and releasing memory.
\smallskip{}

This function does not set {\tt IoErr()} consistently, unless the
functions in the {\tt LoadSegFuncs} structure do. The function returns
the segment of the first segment of the overlay node on success, or
{\tt ZERO} on error.

\subsection{Unloading Overlay Nodes} \label{sec:unloadnode}

Unloading overlay nodes (and \emph{not} the root node) of an overlaid
binary requires some manipulation of the segment table as the
\emph{dos.library} does not provide a function for such
operation. This algorithm is part of the overlay manager, but its
implementation within the standard hierarchical overlay manager
documented here for completeness. Other custom overlay managers
perform potentially different algorithms.
\smallskip{}

First, it finds the previous segment upfront the segment to be
unloaded, and cleans there the {\tt NextSegment} pointer to unlink all
following segments.  Then these following segments are released
through {\tt FreeVec()} or, in case a custom allocator was provided for
{\tt InternalLoadSeg()}, whatever memory release function is appropriate.
\smallskip{}

The following sample code releases the overlay node starting at
segment $i > 0$ from a segment table of an overlay header:
\begin{verbatim}
void UnloadOverlayNode(struct OverlayHeader *oh,ULONG i)
{
  BPTR *segtbl  = (BPTR *)BADDR(oh->oh_Segments);
  BPTR *segment = (BPTR *)BADDR(segtbl[i - 1]); 
  BPTR  next;

  /* Release the linkage from the last loaded to
  ** the first segment to release */
  *segment = NULL;

  do {
    /* Get the segment to release */
    if (segment = (BPTR *)BADDR(segtbl[i++])) {
      next      = *segment;
      FreeVec(segment);
    } else break;
    /* Repeat until the last segment */
  } while(next);
}
\end{verbatim}
Note that a previous segment always exists because the root node
populates at least entry~$0$ of the segment table. The above loop
makes use of the fact that the first long-word of a segment is a
\emph{BPTR} to the next segment, and this linkage is {\tt ZERO} for
the final node.
\smallskip{}

If a custom memory allocator has been used for loading overlay nodes
through {\tt InternalLoadSeg()}\key{InternalLoadSeg()}, the {\tt
  FreeVec()} in the above function is replaced by the corresponding
memory release function.

\subsection{Unloading Overlay Binaries}

To unload the root node, and thus unload the entire program including
all overlay nodes, {\tt UnLoadSeg()}\key{UnLoadSeg()} on the first
segment of the root node is sufficient if neither custom I/O nor a
custom memory allocator has been used to load the binary, independent
on which overlay manager has been used. {\tt UnLoadSeg()} will detect
the overlay manager from the magic value in {\tt oh\_Magic} and will
then not only release the segments, but also close the overlay file
handle and release the segment table.
\smallskip{}

If {\tt InternalLoadSeg()}\key{InternalLoadSeg()} has been used for
loading the root node through custom I/O functions or with a custom
memory allocator, {\tt InternalUnLoadSeg()}\key{InternalUnLoadSeg()}
shall be used instead to release the root node. Unfortunately, it
\emph{always} uses {\tt Close()}\key{Close()} on {\tt oh\_FileHandle},
even if {\tt oh\_FileHandle} does not correspond to a
\emph{FileHandle} as returned by {\tt Open()}\key{Open()},
e.g. because {\tt ReadFunc()} upon loading the overlay program pointed
to a custom I/O function. The best strategy in this case is probably
to close {\tt oh\_FileHandle} manually upfront with whatever method is
appropriate, then zero it out manually and then finally call into {\tt
  InternalUnLoadSeg()} to perform all the necessary cleanup steps.
This strategy works because {\tt Close()} on a {\tt ZERO}
file handle performs no operation and is legit.

\subsection{Internal Working of the Overlay Manager}

Several versions of the hierarchical overlay manager exist. The
version described here stems from the SAS/C {\tt SLink} utility and is
designed for the \emph{registerized parameters} configuration within
which some function arguments are passed in CPU registers. Earlier
versions require stack-based parameter passing.
\smallskip{}

When binding objects together to an overlay binary together, the
linker checks whether a reference to a symbol crosses a boundary of
overlay nodes. References that go to a parent node or the node itself
can be resolved by the linker by creating a relocation entry in a {\tt
  HUNK\_RELOC32} hunk as it can assume that the corresponding segment
is already loaded.
\smallskip{}

References to symbols within child nodes receive each a unique integer
identifier, and an entry in the overlay table in {\tt HUNK\_OVERLAY}
at the index given by the identifier. The actual call to a function in
a child node is then replaced to call into a trampoline function that
looks as follows:
\begin{verbatim}
@symX:
    jsr @ovlyMgr
    dc.w symbX
\end{verbatim}
where {\tt @ovlyMgr} is the entry point of the overlay manager and
{\tt symbX} is the identifier of the referenced symbol. The overlay
manager reads the return PC which points to the identifier, and from the
identifier finds the entry in the symbol table. 
\smallskip{}

The symbol table contains both the ordinate and the level of the
symbol with which the overlay manager is able to check whether the
node containing the symbol is currently loaded. If this is not the
case, it needs to unload the currently loaded node at this level and
all its children, and then progresses to loading the required node
from the file offset in the symbol table, and then progresses to
updating the overlay table.
\smallskip{}

If the overlay node containing the symbol is already loaded, or just
has been loaded, the symbol address is computed from the offset in the
symbol table and the address of the segment containing the symbol from
the segment table, and injected into the return address that contained
a pointer to the symbol identifier. Thus, when returning from the
overlay manager, the code will continue to execute from the target
symbol. Other versions of the overlay manager use a trampoline function that
loads register {\tt d0} with the symbol identifier and thus require
stack-based function calls.
\smallskip{}

Regardless of the version of the overlay
manager, only symbols corresponding to function can be resolved as the
overlay manager must be called to resolve a symbol. In particular,
data cannot be referenced across overlay nodes --- instead, an
accessor function may be used that returns the object to be accessed.
\medskip{}

The following code provides an overlay manager for register-based
calls:
\begin{verbatim}
        xdef    @ovlyMgr
;*************************************************
;** Offsets in the overlay-table                **
;*************************************************
        rsreset
ot_FilePosition:        rs.l 1          ;File position
ot_reserved:            rs.l 2          ;for whatever
ot_OverlayLevel:        rs.l 1          ;Overlay-Level
ot_Ordinate:            rs.l 1          ;Overlay-Ordinate
ot_InitialHunk:         rs.l 1          ;Initial hunk for loading
ot_SymbolHunk:          rs.l 1          ;Hunk containing symbol
ot_SymbolOffset:        rs.l 1          ;Offset of symbol
ot_len:                 rs.b 0

;*************************************************
;** Other stuff                                 **
;*************************************************
MajikLibWord    =       23456           

       section NTRYHUNK,CODE
;*************************************************
;** Manager starts here                         **
;*************************************************
Start:
        bra.w NextModule                ;Jump to the next segment...

;* This next word serves to identify the overlay
;* supervisor to 'unloader', i.e. UnLoadSeg()

        dc.l       $ABCD                ;Magic longword for UnLoadSeg

;* The next four LWs are filled by the loader (LoadSeg())
ol_FileHandle:  dc.l 0                  ;Overlay file handle (points to me)
ol_OverlayTab:  dc.l 0                  ;Overlay table as found in the overlay hunk
ol_HunkTable:   dc.l 0                  ;BPTR to Overlay hunk table
ol_GlobVec:     dc.l 0                  ;BPTR to global vector (what for ?)

                dc.l MajikLibWord       ;Majik library word as identifier
                dc.b 7,"Overlay"        ;Majik identifier

;* the following data is specific to this manger

ol_SysBase:     dc.l 0                  ;additional pointer
ol_DOSBase:     dc.l 0                  ;to libraries

                dc.b "THOR Overlay Manager 1.0",0      ;another ID

@ovlyMgr:                               ;Entry-points
        saveregs d0-d3/a0-a4/a6         ;Saveback register

        moveq #0,d0
        move.l 10*4(a7),a0
        move.w (a0),d0                  ;get the overlay reference ID

        move.l ol_OverlayTab(pc),a3     ;get pointer to overlay table
        move.l a3,a4                    ;to a4
        add.l (a3),d0                   ;add length
        lsl.l #2,d0                     ;get offset
        add.l d0,a3                     ;address of overlay entry
        move.l ot_OverlayLevel(a3),d0   ;get overlay
        lsl.l #2,d0
        adda.l d0,a4
        move.l ot_Ordinate(a3),d0       ;get required ordinate level
        cmp.l (a4),d0                   ;compare with current ordinate level
        beq.s .gotsegment
                                        ;not correct level
                                        ;clear all other entries behind this
        move.l d0,(a4)+                 ;fill with new overlay entries

        moveq #0,d1
        do                              ;macros in action! ;-)
         tst.l (a4)                     ;terminate, if end of table found
         break.s eq
         move.l d1,(a4)+                ;clear this
        loop.s

        move.l ot_InitialHunk(a3),d0    ;first hunk number to load
        add.l ol_HunkTable(pc),d0       ;plus BPTR of hunk table
        lsl.l #2,d0                     ;address of entry in hunk table
        move.l d0,a4
        move.l -4(a4),d0                ;get previous hunk
        beq.s .noprevious
        lsl.l #2,d0
        move.l d0,a2
        move.l d1,(a2)                  ;unlink fields before loading

                                        ;now free all hunks
        move.l ol_SysBase(pc),a6

        do
         move.l (a4)+,d0                ;next hunk ?
         break.s eq
         lsl.l #2,d0
         move.l d0,a1                   ;->a1
         move.l -(a1),d0                ;get length
         jsr FreeMem(a6)                ;free this hunk
        loop.s                          ;and now the next
.retry:
        move.l ol_DOSBase(pc),a6
        move.l ol_FileHandle(pc),d1     ;get our stream
        move.l ot_FilePosition(a3),d2   ;get file position
        moveq #-1,d3                    ;relative to beginning of file
        jsr Seek(a6)                    ;seek to this position
        tst.l d0                        ;found something ?
        bmi.s .loaderror                ;what to do on failure ?

                                        ;now call the loader
        move.l ol_HunkTable(pc),d2      ;hunk table
        moveq #0,d1                     ;no file (is overlay)
        move.l ol_FileHandle(pc),d3     ;filehandle
        jsr LoadSeg(a6)                 ;load this stuff
        tst.l d0                        ;found
        beq.s .loaderror
        move.l d0,(a2)                  ;add new chain

                                        ;found this stuff
.gotsegment:
        move.l ot_SymbolHunk(a3),d0     ;get hunk # containing symbol
        add.l ol_HunkTable(pc),d0
        lsl.l #2,d0                     ;get APTR to hunk
        move.l d0,a4
        move.l (a4),d0                  ;BPTR to hunk
        lsl.l #2,d0
        add.l ot_SymbolOffset(a3),d0    ;Offset

        move.l d0,10*4(a7)              ;Set RETURN-Address

        loadregs
        rts

;*************************************************
;** Go here if we find an error                	**
;*************************************************
.loaderror:
        saveregs d7/a5
        move.l ol_SysBase(pc),a6
        move.l #$0700000C,d7
        move.l $114(a6),a5
        jsr Alert(a6)                   ;Post alert
        loadregs
        bra.s .retry                    ;Retry or die

.noprevious:
        move.l ol_SysBase(pc),a6
        move.l #$8700000C,d7            ;dead end !
        move.l $114(a6),a5
        jsr Alert(a6)                   ;Post alert
        bra.s .noprevious


;*************************************************
;** NextModule                                  **
;** Open stuff absolutely necessary and         **
;** continue with main program code             **
;*************************************************
NextModule:
                                        ;why safe registers ?
        move.l a0,a2
        move.l d0,d2                    ;keep arguments
        lea ol_SysBase(pc),a3
        move.l ExecBase,a6
        move.l a6,(a3)                  ;fill in Sysbase
        lea DOSName(pc),a1              ;get name of DOS
        moveq #33,d0                    ;at least 1.2 MUST be used
        jsr OpenLibrary(a6)
        move.l d0,4(a3)                 ;Save back DOS base for loader
        beq.s .nodosexit                ;exit if no DOS here

        move.l d0,a6                    
        move.l Start-4(pc),a0           ;Get BPTR of next hunk
        adda.l a0,a0
        adda.l a0,a0
        exg.l a0,a2                     ;move to a2
        move.l d2,d0                    ;restore argument
        jsr 4(a2)                       ;jump in
        move.l d0,d2                    ;Save return code

        move.l ol_SysBase(pc),a6
        move.l ol_DOSBase(pc),a1
        jsr CloseLibrary(a6)            ;Close the lib

        move.l d2,d0                    ;Returncode in d0
        rts
.nodosexit:
        move.l #$07038007,d7            ;DOS didn't open
        move.l $114(a6),a5
        jsr Alert(a6)
        moveq #30,d0                    ;Something went really wrong !
        rts

DOSName:        dc.b "dos.library",0
\end{verbatim}

\section{Structures within Hunks}

While the AmigaDOS loader, i.e. {\tt LoadSeg()}\key{LoadSeg()} and
related functions, do not care about the contents of the segments it
loaded, some other components of AmigaDOS do actually analyze their
contents.

\subsection{The Version Cookie}

The {\tt Version} command scans a ROM-resident modules or all segments
of a binary for the character sequence {\tt \$VER:} and if such a
sequence is found, the string following is scanned. The syntax of the
string consists of the following elements:

\begin{itemize}
\item[-] The version cookie {\tt \$VER:}
\item[-] one or multiple blank spaces
\item[-] a program name, which is output by the {\tt Version} command
\item[-] a decimal number, representing the \emph{version} of the program
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the \emph{revision} of the program
\item[-] one or multiple blank spaces
\item[-] an opening bracket (``{\tt (}'')
\item[-] a decimal number, representing the day of the month of the revision
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the month of the revision
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the year of the revision
\item[-] a closing bracket (``{\tt )}'')
\item[-] an optional comment that is only output if the {\tt FULL} option of the {\tt Version} is given.
\end{itemize}

If the number representing the year is below $1900$, the {\tt Version}
command assumes a two-digit year and either adds $200$ if the year is
below $78$, or $1900$ otherwise. The command then re-formats the date
according to the currently active locale and prints it to the console,
along with the program name and, optionally, the comment string.
\smallskip{}

An example for the version cookie is
\begin{verbatim}
const char version[] = "$VER: RKRM-Dos 45.3 (12.9.2023) (c) THOR";
\end{verbatim}

Note that the date follows the convention date of the month, month and
year, here September 12, 2023. The version in this example is 45, the
version is 3. The string behind the date is a comment and usually not
printed by the {\tt Version} command.

\subsection{The Stack Cookie} \label{sec:stackcookie}

The workbench, the shell, and also {\tt
  GetDeviceProc()}\key{GetDeviceProc()} when loading \emph{handlers}
scan the loaded binary for the string sequence {\tt \$STACK:}. If this
string sequence is found, AmigaDOS attempts to read a following
decimal number, and interprets this as stack size in bytes.
\smallskip{}

The stack of the program is then, potentially increased to the
provided size. Note that AmigaDOS also scans alternative sources for a
stack size: The {\tt Stack} setting in the icon information window of the
workbench, the {\tt Stack} command of the shell, or the {\tt
  STACKSIZE} entry in the mount list. The stack size indicated by the
above stack cookie does not override these settings, it can only
\emph{increase} the stack size. This allows program authors to ensure
that the stack of their program has a necessary minimal size, though
still allows users to increase it if necessary.
\smallskip{}

An example for the stack cookie is
\begin{verbatim}
const char stack[] = "$STACK: 8192";
\end{verbatim}
This ensures that the stack size of the program is at least 8192 bytes.
\medskip{}

The \emph{dos.library} provides with the
{\tt ScanStackToken()}\mkey{ScanStackToken()} an optimized function to quickly
scan segments for the stack cookie and potentially adjust a default
stacksize upwards to the value found in the stack cookie.

\begin{verbatim}
stack = ScanStackToken(segment, defaultstack)
D0                     D1       D2

LONG ScanStackToken(BPTR segment, LONG defaultstack)
\end{verbatim}

This function scans the segment list starting at {\tt segment} for a stack
cookie, potentially adjusting the {\tt defaultstack} size in bytes passed
in. If a stack cookie is found, and the minimal stack size it finds is
larger than the default stack, the stack size found in the stack cookie is
returned in {\tt stack}. If no stack cookie is found, or the value in the
stack cookie is smaller than the {\tt defaultstack} size, the default size
is returned.
\smallskip{}

The {\tt segment} is a \emph{BPTR} to a singly linked list of segments,
e.g. as returned by {\tt LoadSeg()}\key{LoadSeg()} function.

\subsection{Runtime binding of BCPL programs} \label{sec:bcplbinding}

BPCL programs depend on a \emph{Global Vector}\mkey{Global Vector}
that includes function entries and data available to all its
modules. AmigaDOS includes a runtime binder functionality that creates
the \emph{Global Vector} from data found in the segments of the loaded
binary and the \emph{dos.library} \emph{Global Vector}.
\smallskip{}

Even though this mechanism is deprecated and AmigaDOS has long been
ported to C and assembler, some components still depend on this legacy
mechanism, namely all \emph{handlers} and \emph{file systems} mounted
with the {\tt GLOBVEC = 0} or {\tt GLOBVEC = -2} entry in the mount
list. While newer \emph{handlers} should not depend on this mechanism
anymore, the {\tt Port-Handler} mount entry is created in the
Kickstart ROM as BCPL handler, beyond control of the user. The same
goes for the {\tt Shell}, which is also initiated as BCPL process.
\smallskip{}

If the above components --- the {\tt Port-Handler} or the \emph{Shell}\key{Shell}
--- are attempted to be customized, implementors need to be aware that
these processes are not started from the first byte of the first
segment, but from the \emph{Global Vector} entry {\tt \#1}, which
contains the address of the {\tt START} function from which the
process is run. All other entries of the vector are of no concern, and
should not be used anymore.
\medskip{}

The \emph{Runtime Binder}\mkey{Runtime Binder} of AmigaOs, initiated
only for BCPL handlers and BCPL processes such as the
\emph{Shell}\key{Shell}, now scans the segments of such programs for
information on how to populate the \emph{Global Vector}.
\smallskip{}

The \emph{first long-word} of the segment, usually the entry point of
the process, contains the long-word offset from the start of the
process to the start of the \emph{Global Vector} initialization
data. This initialization data is \emph{scanned backwards} from the
given offset towards lower addresses, starting with the long-word
before the offset.
\smallskip{}

The first long-word of the initialization data is the required size of
the \emph{Global Vector} the program requires. This value is only used
to check the following initializers for validity. The standard system
global vector currently requires 150 entries, which is a safe choice.
\smallskip{}

All following entries consist of pairs of long-words, scanned again
towards smaller addresses, where each pair defines one entry in the
global vector. The first (higher address) long-word is the offset of
the function which will populate the \emph{Global Vector}, the second
(lower) address is the index of the \emph{Global Vector} entry. An
offset of $0$ terminates the list.
\medskip{}

The following assembler stub may be used as initial segment of an
(otherwise C-based) handler that instructs the \emph{Runtime Binder}
to populate the {\tt START} vector, and then calls into the {\tt
  @main} function. BCPL unfortunately also uses a custom call syntax,
register {\tt a6} is the address of the BCPL return code which cleans
up the BCPL stack frame and returns to the caller.

\begin{verbatim}
                SECTION text,code

                XREF    _main           ; handler or shell main

G_GLOBMAX       EQU     150             ; size of GV
G_START         EQU     1               ; BCPL START functions
G_CLISTART      EQU     133             ; shell startup

CodeHeader:     DC.L    (CodeEnd-CodeHeader)/4 

*               C Startup function, called for GlobVec=-1 or -3
*               see text below why this works
CStart:         sub.l   a0,a0           ; no startup message
                bsr.w   _main           ; need to GetMsg() in main
                rts

                CNOP    0,4

*               BCPL startup function, called for GlobVec=0 or -2
BCPLStart:      movem.l a0-a6,-(a7)     ; save for BCPL use
                lsl.l   #2,d1           ; get startup packet
                move.l  d1,a0           ; move to a0
                bsr.w   _main           ; get the ball rolling
                movem.l (a7)+,a0-a6     ; restore everyone
                jmp     (a6)            ; BCPL-style return

BCPLTable:      CNOP    0,4

                DC.L    0               ; End of global list
                DC.L    G_CLISTART,BCPLStart-CodeHeader ;for the shell
                DC.L    G_START,BCPLStart-CodeHeader
                DC.L    G_GLOBMAX       ; max global used (default)
CodeEnd:
\end{verbatim}

Note that there are other differences for BCPL handlers the {\tt
  main()} function of the handler needs to take care of, see also
section~\ref{sec:bcplhandlers}. BCPL handlers do not receive their
startup message in the process \emph{MsgPort}, but rather receive it
as first BCPL argument in register {\tt d1}. It is here converted to
a C-style pointer and provided as first argument to the main function,
assuming the SAS/C registerized parameters ABI.
\smallskip{}

The {\tt CStart} label is not called at all if the handler is mounted
with {\tt GLOBVEC=0} or {\tt GLOBVEC=-2}, and thus would be, in this
example, not required. It is included here to demonstrate another
technique, namely \emph{dual use} handlers that can be mounted both as
C and as BCPL handlers.
\smallskip{}

The above startup code also allows {\tt GLOBVEC=-1} in the mount
list. In this case, the code \emph{is} started from the first byte,
which is, actually, the long-word offset to the BCPL initializer.  In
this particular case, it also assembles to a harmless {\tt ORI}
instruction, provided the offset to the end of the code is short
enough, i.e. below 64K. It is therefore harmless. As the calling
syntax is different, the main function is now called with a {\tt NULL}
argument, and then needs to wait for the startup package itself, see
again section~\ref{sec:bcplhandlers}.
\smallskip{}

For the \emph{Shell}, in particular, a second entry in the
\emph{Global Vector} shall be populated, namely the entry {\tt
  G\_CLISTART} at offset {\tt \#133}. It may point to the same entry
code, more on this in section~\ref{sec:shell}. As this entry is not
used for handler startup, it does not hurt to include it in the BCPL
initializer in either case, and thus the above code may be used as
universal ``BCPL kludge'' for both the shell and legacy handlers that
depend on BCPL startup.

\section{Object File Format} \label{sec:objfile}

Object files are intermediate output files of a compiler or assembler,
generated from one translation unit, i.e. typically one source code
file. Such files can still contain references to symbols that could not be
resolved within the translation unit because the corresponding symbol is
defined in another unit. The linker then combines multiple object codes,
resolving all unreferenced symbol, and generates an executable binary file
as output.
\smallskip{}

The overall structure of an object file is depicted in table~\ref{table:objfile}:
\begin{rkrmtabular}{Object File Format} \label{table:objfile}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
?  & \tt HUNK\_UNIT & Defines the start of a translation unit, see~\ref{sec:hunk_unit} \\ \hline
   & \tt do \{ & Multiple segments follow \\ \hline
?  & \tt $\quad$ HUNK\_NAME & Name of the hunk, defines hunks to merge, see~\ref{sec:hunk_name} \\ \hline
2  & \tt $\quad$ $m_t$ & Read the memory type of the next hunk \\ \hline
30 & \tt $\quad$ $h_t$ & Read the next hunk type \\ \hline
   & \tt $\quad$ if ($h_t$ == HUNK\_CODE) parse\_CODE & Code and constant data, see~\ref{sec:hunk_code} \\ \hline
   & \tt $\quad$ else if ($h_t$ == HUNK\_DATA) parse\_DATA & Data, see~\ref{sec:hunk_data} \\ \hline
   & \tt $\quad$ else if ($h_t$ == HUNK\_BSS) parse\_BSS & Zero-initialized data, see~\ref{sec:hunk_bss} \\ \hline
   & \tt $\quad$ else if ($m_t$ != 0) ERROR\_BAD\_HUNK & Upper bits shall be 0 for all other hunks \\ \hline
   & \tt $\quad$ else do \{ & Loop over auxiliary information \\ \hline
   & \tt $\quad\quad$ if ($h_t$ == HUNK\_RELOC32) parse\_RELOC32 & 32-bit relocation, see~\ref{sec:hunk_reloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC32SHORT) parse\_RELOC32SHORT & 32-bit relocation, see~\ref{sec:hunk_reloc32short} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELRELOC32) parse\_RELRELOC32 & 32-bit PC-relative relocation, see~\ref{sec:hunk_relreloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC16) parse\_RELOC16 & 16-bit PC-relative relocation, see~\ref{sec:hunk_reloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC8) parse\_RELOC8 & 8-bit PC-relative relocation, see~\ref{sec:hunk_reloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC32) parse\_RELOC32 & 32-bit base-relative relocation, see~\ref{sec:hunk_dreloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC16) parse\_RELOC16 & 16-bit base-relative relocation, see~\ref{sec:hunk_dreloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC8) parse\_RELOC8 & 8-bit base-relative relocation, see~\ref{sec:hunk_dreloc8} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_EXT) parse\_EXT & External symbol definition, see~\ref{sec:hunk_ext} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_SYMBOL) parse\_SYMBOL & Symbol definition, see~\ref{sec:hunk_symbol} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DEBUG) parse\_DEBUG & Debug information, see~\ref{sec:hunk_debug} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_END) break & abort this segment \\ \hline
   & \tt $\quad\quad$ else ERROR\_INVALID\_HUNK & an error \\ \hline
32 & \tt $\quad\quad$ $h_t$ & Read next hunk type \\ \hline
   & \tt $\quad$ \} while(true) & Repeated until {\tt HUNK\_END} \\ \hline
   & \tt \} while(!EOF) & Repeated with the next hunk until the file ends \\ \hline 
\end{longtable}
\end{rkrmtabular}

Since there is no {\tt HUNK\_HEADER}\key{HUNK\_HEADER} in object files, the
memory attributes for the hunk are instead stored in the topmost two bits of
the hunk type itself. Unlike in {\tt HUNK\_HEADER}, there is no documented
way how to indicate a memory type beyond {\tt MEMF\_CHIP} and
{\tt MEMF\_FAST}. As the interpretation of object files is up to the linker,
a suggested implementation strategy is to set the topmost two bits and store
the memory type in the following long-word, similar to how
{\tt HUNK\_HEADER} expects it.

\subsection{HUNK\_UNIT} \label{sec:hunk_unit}

This hunk identifies a translation unit and provides it a unique name. This
hunk shall be the first hunk of an object file. A translation unit typically
refers to one source code file that has been processed by the compiler or
assembler. Typically, the name of the unit is ignored by
linkers. \mkey{HUNK\_UNIT}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Unit Syntax} \label{table:hunk_unit}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_UNIT [0x3e7] & A hunk identifying a translation unit\\ \hline
32 & \tt l & Size of the name in long-words \\ \hline
32 $\times$ l & \tt $h_n$ & Unit name \\ \hline
\end{tabular}
\end{rkrmtabular}

The size of the name is not given in characters, but in 32-bit
units. The name is possibly zero-padded to the next 32-bit boundary to
fill an integer number of long-words. If the name fills an entire
number of long-words already, it is \emph{not} zero-terminated.
\smallskip{}

Even though not enforced by the format, linkers can limit the size of the
unit.

\subsection{HUNK\_RELOC16} \label{sec:hunk_reloc16}

This hunk defines relocation information of one hunk into another hunk, and
its format is identical to {\tt HUNK\_RELRELOC32}\key{HUNK\_RELRELOC32}, see
section~\ref{sec:hunk_relreloc32} and
table~\ref{table:hunk_relreloc32}.\mkey{HUNK\_RELOC16}. Relocation offsets
are therefore 32 bits long, though the elements to relocate at offset $r_o$
within the segment are only 16 bits in size, and refer to PC-relative
addressing modes, including PC-relative 16-bit wide branches.

\begin{rkrmtabular}{Hunk Reloc16 Syntax} \label{table:hunk_reloc16}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC16 [0x3ed] & 16-bit PC-relative relocation information\\ \hline
   & \tt \ldots & See table~\ref{table:hunk_relreloc32} \\ \hline
\end{tabular}
\end{rkrmtabular}

This restricts possible displacements to 16 bits, and thus the segment
containing the 16-bit value to be relocated and the segment the hunk is
relative to shall be linked together to form a single segment in the final
output. In the notation of section~\ref{table:hunk_relreloc32}, the segments
$i$ and $j$ shall thus be merged. To make this happen, their names as
provided by {\tt HUNK\_NAME}\key{HUNK\_NAME} shall be identical; alternatively
the linker shall be configured to the small data or small code model that
forcefully merges hunks of the same type.
\smallskip{}

However, it may still happen that the joined segment generated by merging
two or more segments together is too long to allow 16-bit displacements. In
such a case, the relocation can obviously not performed. Then
linkers either abort with a failure, or generate an \emph{automatic link
vector}\mkey{Automatic Link Vector (ALV)}. The PC-relative branch or jump to
an out-of-range target symbol is then replaced by the linker with a branch
or jump to an intermediate ``automatic'' vector that performs a
32-bit absolute jump to the intended target.
\smallskip{}

While such \emph{automatic link vectors}\key{Automatic Link Vector (ALV)} or
short \emph{ALV}s solve the problem of changing the program flow
by 16-bit displacements over distances exceeding 16-bit, \emph{ALV}s do not
work correctly for data that is addressed by 16-bit PC relative
modes. Instead of referencing the intended data, the executing code would
then see the \emph{ALV} as data.
\smallskip{}

Thus, authors of compilers or assemblers should disallow data references
across translation unit boundaries with 16-bit PC-relative addressing modes
as those can trigger linkers to incorrectly generate \emph{ALV}s. Linkers
should also generate a warning when creating \emph{ALV}s.

\subsection{HUNK\_RELOC8} \label{sec:hunk_reloc8}

This hunk defines relocation information of one hunk into another hunk, and
its format is identical to {\tt HUNK\_RELRELOC32}\key{HUNK\_RELRELOC32}, see
section~\ref{sec:hunk_relreloc32} and
table~\ref{table:hunk_relreloc32}.\mkey{HUNK\_RELOC8}. Relocation offsets are
therefore 32 bits long, though the elements to relocate at offset $r_o$
within the current segment are only 8 bits in size, and thus refer to short
branches.
\smallskip{}

The same restrictions as for {\tt HUNK\_RELOC16} applies, i.e. the
hunk within which the relocation offset is to be adjusted and the
target hunk shall be merged to a single hunk as the AmigaDOS loader
cannot resolve 8-bit relocations. This can be either arranged by
giving the two hunks the same name, or by configuring the linker to
the small code or small data model, depending on the type of the
hunk. This will instruct the linker to merge hunks of the same type.
\smallskip{}

\begin{rkrmtabular}{Hunk Reloc8 Syntax} \label{table:hunk_reloc8}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC8 [0x3ee] & 8-bit PC-relative relocation information\\ \hline
   & \tt \ldots & See table~\ref{table:hunk_relreloc32} \\ \hline
\end{tabular}
\end{rkrmtabular}

As for {\tt HUNK\_RELOC16}, the linker can generate
\emph{ALV}s\key{Automatic Link Vector (ALV)} in case the target offset is
not reachable with an 8-bit offset. However, as the possible range for
displacement is quite short, it is quite likely that the generated
\emph{ALV} itself is not reachable, and thus relocation during the linking
phase is not possible at all. Thus, short branches between translation units
should be avoided.
\smallskip{}

Otherwise, the same precautions as for {\tt HUNK\_RELOC16} should be taken,
i.e. short displacements to data over translation unit boundaries should be
avoided as proper linkage cannot be ensured.

\subsection{HUNK\_DRELOC32} \label{sec:hunk_dreloc32}

This hunk defines relocation of 32-bit data elements within a hunk that is
addressed relative to a base register. The name of this hunk shall be {\tt
  \_\_MERGED}, indicating that the hunk contains data and zero-initialized
elements in the \emph{small data model}\mkey{Small data model}.
\smallskip{}

The format of this hunk is identical to {\tt
  HUNK\_RELOC32}\key{HUNK\_RELOC32}, see section~\ref{sec:hunk_reloc32} and
table~\ref{table:hunk_reloc32}, where each 32-bit wide relocation offset
$r_o$ points to a long-word within the preceding data or BSS hunk. The
long-word at this offset is then adjusted by the position of the first byte
of this hunk relative to the start of the target {\tt \_\_MERGED} hunk into
which this hunk is merged; in some cases, linkers can include an additional
adjustment, see the next paragraph for details.

\begin{rkrmtabular}{Hunk DReloc32 Syntax} \label{table:hunk_dreloc32}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_DRELOC32 [0x3f7] & 32-bit base-relative relocation information\\ \hline
   & \tt \ldots & See table~\ref{table:hunk_reloc32} \\ \hline
\end{tabular}
\end{rkrmtabular}

The hunks named {\tt \_\_MERGED} are typically generated by compilers or
assemblers when implementing the \emph{small data model}\key{Small Data
  Model} within which all non-static objects are addressed relative to a
base register. Typically, register {\tt a4} is used for this purpose, and it
is loaded by the compiler startup code to point either to the start of the
{\tt \_\_MERGED} hunk, or 32K into the hunk such that both negative and
positive offsets relative to {\tt a4} can be used. In the latter case,
linkers need to subtract an additional 32K displacement from the $r_o$
offsets when performing relocation. The name \emph{small data
model} stems for the limitation to 64K of data as the 68000 uses only 16-bit
for base-relative addressing.

\subsection{HUNK\_DRELOC16} \label{sec:hunk_dreloc16}

This hunk defines relocation of 16-bit data elements within a hunk that is
addressed relative to a base register, i.e. {\tt \_\_MERGED} hunks in the
\emph{small data} memory model.

The format of this hunk is identical to {\tt
  HUNK\_RELOC32}\key{HUNK\_RELOC32}, see
section~\ref{sec:hunk_reloc32} and table~\ref{table:hunk_reloc32},
where each 32-bit wide relocation offset $r_o$ points to an unsigned 16-bit word
within the preceding data or BSS segment. The word at this offset is then
adjusted by the position of the first byte of this hunk relative to the
start of the {\tt \_\_MERGED} hunk into which this hunk is merged. 

\begin{rkrmtabular}{Hunk DReloc16 Syntax} \label{table:hunk_dreloc16}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_DRELOC16 [0x3f8] & 16-bit base-relative relocation information\\ \hline
   & \tt \ldots & See table~\ref{table:hunk_reloc32} \\ \hline
\end{tabular}
\end{rkrmtabular}

Similar to the comments made in section~\ref{sec:hunk_dreloc32}, this hunk
is typically used to resolve symbols that are reached relative through a
base register, e.g {\tt a4}. As base-relative addressing is restricted to
16-bit displacements for the 68000, linkers typically adjust the base
register to point 32K into the {\_\_MERGED} hunk if this hunk exceeds 32K in
size. In such a case, they need to include an additional negative offset of
-32K in $r_0$ when performing relocation.

\subsection{HUNK\_DRELOC8} \label{sec:hunk_dreloc8}

This hunk defines relocation of 8-bit data elements within a hunk that is
addressed relative to a base register, i.e. {\tt \_\_MERGED} hunks in the
\emph{small data} memory model.

The format of this hunk is identical to {\tt
  HUNK\_RELOC32}\key{HUNK\_RELOC32}, see
section~\ref{sec:hunk_reloc32} and table~\ref{table:hunk_reloc32},
where each 32-bit wide relocation offset $r_o$ points to a byte
within the preceding data or BSS hunk. The byte at this offset is then
adjusted by the position of the first byte of this hunk relative to the
start of the {\tt \_\_MERGED} hunk into which this hunk is merged.

\begin{rkrmtabular}{Hunk DReloc8 Syntax} \label{table:hunk_dreloc8}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_DRELOC8 [0x3f9] & 8-bit base-relative relocation information\\ \hline
   & \tt \ldots & See table~\ref{table:hunk_reloc32} \\ \hline
\end{tabular}
\end{rkrmtabular}

\subsection{HUNK\_EXT} \label{sec:hunk_ext}

This hunk defines symbol names and corresponding symbol offsets or
values within the currently loaded segment. It is quite similar to {\tt
  HUNK\_SYMBOL}\key{HUNK\_SYMBOL} except that it not only includes symbol
definitions, but also symbol references. The linker uses this hunk to
resolve symbols with external linkage.\mkey{HUNK\_EXT}
\smallskip{}

The syntax of this hunk reads as follows:
\begin{rkrmtabular}{Hunk EXT Syntax} \label{table:hunk_ext}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_EXT [0x3ef] & A hunk assigning symbols to positions within a segment\\ \hline
   & \tt do \{ & Repeat $\ldots$ \\ \hline
8  & \tt $\quad$ $s_t$ & Symbol type \\ \hline
24 & \tt $\quad$ $s_l$ & Symbol length in long-words \\ \hline
   & \tt $\quad$ if ($s_l$ == 0) break & Terminate the hunk \\ \hline
32 $\times$ $s_l$ & \tt $\quad$ $s_n$ & Symbol name, potentially zero-padded \\ \hline
   & \tt $\quad$ if ($s_t$ < 0x80) \{ & Symbol definition? \\ \hline
32 & \tt $\quad\quad$ $s_v$ & Symbol value \\ \hline
   & \tt $\quad$ \} else \{ & Symbol reference \\ \hline
   & \tt $\quad\quad$ if ($s_t$ == 0x82 || $s_t$ == 0x89) & A common block? \\ \hline
32 & \tt $\quad\quad\quad$ $s_c$ & Size of the common block in bytes \\ \hline
   & \tt $\quad\quad$ \} & End of common block \\ \hline
32 & \tt $\quad\quad$ $s_n$ & Number of references of this symbol \\ \hline
   & \tt $\quad\quad$ while($--s_n \ge 0$) \{ & Repeat over the references \\ \hline
32 & \tt $\quad\quad\quad$ $s_o[s_n]$ & Offset into the hunk of the reference \\ \hline
   & \tt $\quad\quad$ \} & End of loop over symbols \\ \hline
   & \tt \} while(true) & until zero-sized symbol \\ \hline
\end{longtable}
\end{rkrmtabular}

The length of the symbol name is encoded in long-words, not in
characters. If it does not fill an integer number of long-words, it is
zero-padded; the name is not zero-terminated if it does fill an
integer number of long-words, though.
\medskip{}

The symbol type $s_t$ defines the nature of the symbol. The symbol
types are defined in {\tt dos/doshunks.h} and shared with the {\tt
  HUNK\_SYMBOL} hunk, see section~\ref{sec:hunk_symbol}.\key{HUNK\_SYMBOL}
\smallskip{}

Entries of a symbol type with {\tt $s_t$ < 0x80} are symbol definitions, the
symbol value is defined by $s_v$. See table~\ref{table:extsymboltypes} for
possible types of symbol definitions.
\smallskip{}

The next table includes symbol types that identify symbol references,
i.e. they are referenced within a segment of an object file, though
not defined there. These types can clearly not be contained within a
executable binary, but they may appear within an object file and are
then resolved by corresponding symbol definitions from the above table
by the linker:
\begin{rkrmtabular}{Symbol types in HUNK\_EXT} \label{table:extsymboltypes}
\begin{longtable}{|lc|p{9cm}|} \hline
\tt EXT\_REF32 & [0x81] & Reference to a 32-bit symbol that is resolved
by a corresponding {\tt EXT\_ABS} to an absolute value or by a {\tt
  EXT\_DEF} definition to a relocation information to this or another
segment. \\ \hline

\tt EXT\_COMMON & [0x82] & Reference to a 32-bit symbol that may be
resolved by a {\tt EXT\_ABS} or {\tt EXT\_DEF} definition, but if no
such definition is found, a BSS hunk of the maximal size of all
references to the symbol is created by the linker. Thus, this type
generates a zero-initialized object if no definition is found. \\ \hline

\tt EXT\_REF16 & [0x83] & Reference to a 16-bit PC relative offset within
the same segment. \\ \hline

\tt EXT\_REF8 & [0x84] & Reference to a 8-bit PC relative offset within
the same segment. \\ \hline

\tt EXT\_DREF32 & [0x85] & 32-bit reference relative to a base register
(typically {\tt a4}), resolved by the linker through an entry in a {\tt
  HUNK\_DRELOC32} hunk\key{HUNK\_DRELOC32}.\\ \hline

\tt EXT\_DREF16 & [0x86] & 16-bit reference relative to a base register,
resolved by the linker through an entry in a {\tt HUNK\_DRELOC16}
hunk\key{HUNK\_DRELOC16}.\\ \hline

\tt EXT\_DREF8 & [0x87] & 8-bit reference relative to a base register,
resolved by the linker through an entry in a {\tt HUNK\_DRELOC8} hunk
\key{HUNK\_DRELOC8}.\\ \hline

\tt EXT\_RELREF32 & [0x88] & 32-bit PC-relative reference for 32-bit
address, this will be resolved by an {\tt EXT\_DEF} definition into an
entry into a {\tt HUNK\_RELRELOC32} hunk by the linker.\\ \hline

\tt EXT\_RELCOMMON & [0x89] & 32-bit PC relative common reference for a
32-bit address. Similar to a {\tt EXT\_COMMON} definition, this will
be resolved into an {\tt HUNK\_RELRELOC32} entry where potentially
space for the symbol will be allocated in a BSS segment if no
corresponding definition is found.\\ \hline

\tt EXT\_ABSREF16 & [0x8a] & 16-bit absolute reference, resolved by
the linker to a 16-bit value by an {\tt EXT\_ABS} definition. \\ \hline

\tt EXT\_ABSREF8 & [0x8b] & 8-bit absolute reference, resolved by the
linker to an 8-bit value through an {\tt EXT\_ABS}
definition. \\ \hline
\end{longtable}
\end{rkrmtabular}

For references, $s_n$ identifies the number of times the symbol is
referenced, while $s_o$ defines the offsets into the current segment where the
symbol is used and into which the symbol value will be resolved during
linking. This value comes from an $s_v$ entry in a {\tt HUNK\_EXT} hunk
from another translation unit.
\smallskip{}

Common symbols are symbols that are defined in multiple translation
units. The size of the symbol required by the translation $s_c$. If no
corresponding symbol definition is found, the linker then allocates space of
a size that is determined by the maximum of all $s_c$ values found for the
same symbol in all translation units. The symbol will then be created within
a BSS segment by the linker without an explicit symbol definition. This
mechanism is mostly used by FORTRAN and is therefore rarely used. SAS/C can
also be configured to emit common symbols as well.

\section{Link Library File Format}

Link Library files are collections of small compiled or assembled program
sections that provide multiple commonly used symbols or functions. Unliky
AmigaOs libraries, which are loaded dynamically at run time, link libraries
resolve undefined symbols at link time; functions or symbols within them
become a permanent part of the generated executable.
\smallskip{}

The \emph{amiga.lib} is a typical example for a link library. It contains
functions such as {\tt CreateExtIO()}. While newer versions of the
\emph{exec.library} contains with {\tt CreateIORequest()} a similar
function, some manual work was required for creating an {\tt IORequest}
structure in exec versions prior v37. To ease development, it was made
available in a (static) library whose functions are merged with the compiled
code.
\smallskip{}

Link libraries come in two forms: Old-style non-indexed libraries, and
indexed libraries that are faster to process. Old-style or non-indexed link
libraries are simply a concatenation of object files in the form presented
in section~\ref{sec:objfile} and table~\ref{table:objfile}. Then, of course,
one translation unit as introduced by {\tt HUNK\_UNIT} \ref{HUNK_UNIT} is
not necessarily terminated by an {\tt EOF} as specified in
table~\ref{table:objfile}, but possibly by the subsequent program unit,
starting with another {\tt HUNK\_UNIT}.
\smallskip{}

Non-indexed link libraries do not require any tools beyond a compiler or
assembler for building them. The AmigaDOS {\tt JOIN} command is sufficient
to build them. The drawback of such libraries is that they are slow to
process as the linker needs to scan the entire library to find a specific
symbol.
\medskip{}

Indexed libraries are faster to parse as they contain a compressed index of
all symbols defined in the library. It consists at its topmost level of two
hunks: one containing the program units, and a symbol table with an index
that are repeated until the end of the file.
\smallskip{}

The overall format of indexed libraries is depicted in
table~\ref{table:indexedlib}.
\begin{rkrmtabular}{Indexed Library} \label{table:indexedlib}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt do \{ & Multiple repetitions of the following \\ \hline
?  & \tt $\quad$ HUNK\_LIB [0x3fa] & Object code modules, see section~\ref{sec:hunk_lib} \\ \hline
?  & \tt $\quad$ HUNK\_INDEX [0x3fb] & Indices into {\tt HUNK\_LIB}, see section~\ref{sec:hunk_index} \\ \hline
   & \tt \} while(!EOF) & Until the end of the file \\ \hline
\end{tabular}
\end{rkrmtabular}

\subsection{HUNK\_LIB} \label{sec:hunk_lib}

The {\tt HUNK\_LIB} hunk contains the actual playload in the form of
multiple code, data or BSS hunks along with their relocation, symbol and
debug information. It looks almost like the contents of a {\tt HUNK\_UNIT}
hunk, with a couple of changes noted below.
\smallskip{}

Table~\ref{table:hunk_lib} depicts the syntax of this hunk.
\begin{rkrmtabular}{Hunk LIB Format} \label{table:hunk_lib}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
?  & \tt HUNK\_LIB [0x3fa] & Identifies the start of an indexed library \\ \hline
32 & \tt $l$ & Length of this hunk in long-words not including the header and this length field \\ \hline
   & \tt do \{ & Multiple segments follow \\ \hline
2  & \tt $\quad$ $m_t$ & Read the memory type of the next hunk \\ \hline
30 & \tt $\quad$ $h_t$ & Read the next hunk type \\ \hline
   & \tt $\quad$ if ($h_t$ == HUNK\_CODE) parse\_CODE & Code and constant data, see~\ref{sec:hunk_code} \\ \hline
   & \tt $\quad$ else if ($h_t$ == HUNK\_DATA) parse\_DATA & Data, see~\ref{sec:hunk_data} \\ \hline
   & \tt $\quad$ else if ($h_t$ == HUNK\_BSS) parse\_BSS & Zero-initialized data, see~\ref{sec:hunk_bss} \\ \hline
   & \tt $\quad$ else if ($m_t$ != 0) ERROR\_BAD\_HUNK & Upper bits shall be 0 for all other hunks \\ \hline
   & \tt $\quad$ else do \{ & Loop over auxiliary information \\ \hline
   & \tt $\quad\quad$ if ($h_t$ == HUNK\_RELOC32) parse\_RELOC32 & 32-bit relocation, see~\ref{sec:hunk_reloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC32SHORT) parse\_RELOC32SHORT & 32-bit relocation, see~\ref{sec:hunk_reloc32short} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELRELOC32) parse\_RELRELOC32 & 32-bit PC-relative relocation, see~\ref{sec:hunk_relreloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC16) parse\_RELOC16 & 16-bit PC-relative relocation, see~\ref{sec:hunk_reloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_RELOC8) parse\_RELOC8 & 8-bit PC-relative relocation, see~\ref{sec:hunk_reloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC32) parse\_RELOC32 & 32-bit base-relative relocation, see~\ref{sec:hunk_dreloc32} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC16) parse\_RELOC16 & 16-bit base-relative relocation, see~\ref{sec:hunk_dreloc16} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DRELOC8) parse\_RELOC8 & 8-bit base-relative relocation, see~\ref{sec:hunk_dreloc8} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_EXT) parse\_EXT & External symbol definition, see~\ref{sec:hunk_ext} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_SYMBOL) parse\_SYMBOL & Symbol definition, see~\ref{sec:hunk_symbol} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_DEBUG) parse\_DEBUG & Debug information, see~\ref{sec:hunk_debug} \\ \hline
   & \tt $\quad\quad$ else if ($h_t$ == HUNK\_END) break & abort this segment \\ \hline
   & \tt $\quad\quad$ else ERROR\_INVALID\_HUNK & an error \\ \hline
32 & \tt $\quad\quad$ $h_t$ & Read next hunk type \\ \hline
   & \tt $\quad$ \} while(true) & Repeated until {\tt HUNK\_END} \\ \hline
   & \tt \} while(!EOF) & Repeated with the next hunk until the file ends \\ \hline 
\end{longtable}
\end{rkrmtabular}

Additional restrictions arise for the {\tt HUNK\_EXT}\key{HUNK\_EXT}
hunk; as symbol definitions are included in the {\tt HUNK\_INDEX}\key{HUNK\_INDEX} hunk,
they shall be removed from this hunk; the corresponding symbol typtes to be removed are listed in
table~\ref{table:symboltypes}. Unlike symbol definitions, symbol references
as given by table~\ref{table:extsymboltypes} shall be retained as only the
reference, but not the type of the reference is included in {\tt HUNK\_INDEX}.
\smallskip{}

The translation unit name and the hunk names shall also stripped,
i.e. neither {\tt HUNK\_UNIT} nor {\tt HUNK\_NAME} shall be included in
{\tt HUNK\_LIB}. The corresponding names are also defined in
{\tt HUNK\_INDEX} by means of the string table included there.
\smallskip{}

Due to restrictions of {\tt HUNK\_INDEX}, the size of a {\tt HUNK\_LIB}
shall not exceed $2^{16}$ long-words and shall be split over multiple
{\tt HUNK\_LIB}, {\tt HUNK\_INDEX} pairs otherwise.

\subsection{HUNK\_INDEX}

The {\tt HUNK\_INDEX} hunk contains a string table and indices into the
preceding {\tt HUNK\_LIB}.

Table~\ref{table:hunk_index} depicts the syntax of this hunk.
\begin{rkrmtabular}{Hunk Index Format} \label{table:hunk_index}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
32 & \tt HUNK\_INDEX [0x3fb] & Defines symbols and references into the library \\ \hline
32 & \tt $l$   & Length of this hunk in long-words \\ \hline
16 & \tt $s_l$ & Length of the string table in {\bf bytes} \\ \hline 
   & \tt do \{ & Repeat over the strings \\ \hline
?  & \tt $\quad$ $s_y[i]$ & A {\tt NUL}-terminated (C-style) string \\ \hline
   & \tt $\quad$ $s_l$ -= strlen($s_y[i]$)+1 & Remove from the length of the symbol table \\ \hline
   & \tt \} while($s_l > 0$) & Repeat until all $s_l$ bytes are parsed \\ \hline
   & \tt do \{ & Loop over translation units \\ \hline
16 & \tt $\quad$ $u_o$ & Byte offset of the unit name into the string table \\ \hline
16 & \tt $\quad$ $h_o$ & Long-word offset of the first hunk of the unit within {\tt HUNK\_LIB} \\ \hline 
16 & \tt $\quad$ $h_c$ & Number of hunks within the unit \\ \hline
   & \tt $\quad$ for($j$=0;$j$<$h_c$;$j$++) \{ & Loop over all hunks \\ \hline
16 & \tt $\quad\quad$ $h_n$ & Byte offset of the hunk name into the string table \\ \hline 
2  & \tt $\quad\quad$ $m_t$ & Memory type of the hunk \\ \hline
14 & \tt $\quad\quad$ $h_t$ & (Shortened) hunk type \\ \hline
16 & \tt $\quad\quad$ $x_c$ & Number of references in the hunk \\ \hline
   & \tt $\quad\quad$ for($k$=0;$k$<$x_c$;$k$++) \{ & Loop over references \\ \hline
16 & \tt $\quad\quad\quad$ $x_n$ & Byte offset of the reference name into the string table \\ \hline
   & \tt $\quad\quad$ \} & \\ \hline
16 & \tt $\quad\quad$ $d_c$ & Number of definitions in the hunk \\ \hline
   & \tt $\quad\quad$ for($k$=0;$k$<$d_c$;$k$++) \{ & Loop over definitions \\ \hline 
16 & \tt $\quad\quad\quad$ $d_n$ & Byte offset of the defined name into the string table \\ \hline   
16 & \tt $\quad\quad\quad$ $d_o$ & Byte offset into the hunk or absolute value \\ \hline
 8 & \tt $\quad\quad\quad$ $a_u$ & Bits 23-16 of {\tt EXT\_ABS} definition \\ \hline 
 1 & \tt $\quad\quad\quad$ 0     & This bit shall be $0$ to identify a definition \\ \hline
 1 & \tt $\quad\quad\quad$ $a_s$ & Sign bit and bits 30 to 24 of an {\tt EXT\_ABS} definition \\ \hline
 6 & \tt $\quad\quad\quad$ $d_t$ & Type of the definition from table~\ref{table:symboltypes} \\ \hline 
   & \tt $\quad\quad$ \} & \\ \hline
   & \tt $\quad$ \} & \\ \hline
   & \tt \} while(!end) & Repeated until the end of hunk is found \\ \hline
\end{longtable}
\end{rkrmtabular}

The initial part, the string table, contains all strings that can be used by
the rest of the hunk. Strings within this table are indexed as byte offset
from the start of the string, i.e. the first string has offset~$0$. To
enable unnamed hunks, the first entry in a string table shall be the empty
string, that is, an isolated $0$-byte.
\smallskip{}

The rest of {\tt HUNK\_INDEX} contains the offsets into the hunks along with
symbols referenced and defined within them. The memory type of the hunk is
again expressed in two bits. The current specification does not define the
meaning of both bits set. The hunk type itself is abbreviated, i.e. only the
lower 14 bits of the hunk type are stored.
\smallskip{}

The first part of the subsequent data defines references, that is, symbols
that are used but not defined within the hunk. The $x_n$ values define the
names of these symbols as offsets from the start of the string table. These
names correspond to symbol types defined in
table~\ref{table:extsymboltypes}. The precise reference type of the symbols is
then found in an {\tt HUNK\_EXT} hunk as part of the preceding
{\tt HUNK\_LIB} hunk.
\smallskip{}

Unlike symbol references, symbol definitions are stored directly in the {\tt
  HUNK\_INDEX} hunk. While $d_n$ identifies the name of the symbol as offset
into the string table, the $d_o$ value is either the offset of the defined
symbol within the hunk, or the least significant 16 bits of an {\tt
  EXT\_ABS} definition. As some absolute values can exceed 16 bits, $a_o$
stores bits 23 to 16 of the symbol value, and bit $a_s$ is copied into bits
31 to 24 of the symbol to enable negative values. The type of the symbol
definition is $d_t$, which shall be a value from
table~\ref{table:symboltypes}.
\smallskip{}

As seen from this definition, symbols can only be defined within the first
64K of a hunk. This is typically not a problem as link libraries typically
contain short service functions. For absolute values, larger values are
required, e.g. for the base address of the custom chips, and thus split
into $a_s$, $a_o$ and $d_o$.

\chapter{Handlers, Devices and File Systems} \label{sec:handlers}

Handlers are AmigaDOS processes that provide all the services to implement
many functions of the \emph{dos.library}. Operations on files, such as
opening files, reading data or seeking in files are implemented in the
corresponding handler and not the \emph{dos.library} itself. \emph{File
systems} are special handlers that organize data streams on volumes such as
hard disks in files, and also provide locks to reserve access rights to
files. Most file systems also support directories and thus a hierarchical
organization of files.
\smallskip{}

Handlers are recognized by an entry in the \emph{device list} whose
{\tt dol\_Task} element provides a pointer to a message port through which the
\emph{dos.library} communicates with the handler,
section~\ref{sec:devicelist} provides further details on this structure.
\smallskip{}

To ease communication, the {\tt FileHandle} structure representing a file
also includes with its {\tt fh\_Type} element a pointer to such a port that
is typically a copy of {\tt dol\_Task} when a file is opened, see
section~\ref{sec:filehandle} for this structure. It is created by the
\emph{dos.library} when opening files.
\smallskip{}

Similarly, the {\tt fh\_Type} element of the {\tt FileLock} structure
includes the port through which communication with the file system
concerning the lock is routed. Unlike {\tt FileHandle}s, the {\tt FileLock}
structure is created by the \emph{file system} itself which initializes its
{\tt fh\_Type}. This is again in many cases identical to the {\tt dol\_Task}
message port within the \emph{device list}.
\medskip{}

\section{The DosPacket Structure} \label{sec:dospacket}

While it is in many cases more practical to interact with handlers through
the functions of the \emph{dos.library}, it is also possible to communicate
with the handler directly through this port. This communication is based on
\emph{packets}, represented by a {\tt DosPacket} structure documented in
{\tt dos/dosextens.h}:
\begin{verbatim}
struct DosPacket {
   struct Message *dp_Link;
   struct MsgPort *dp_Port;
   LONG dp_Type; 
   LONG dp_Res1;
   LONG dp_Res2; 
   LONG dp_Arg1;
   LONG dp_Arg2;
   LONG dp_Arg3;
   LONG dp_Arg4;
   LONG dp_Arg5;
   LONG dp_Arg6;
   LONG dp_Arg7;
};
\end{verbatim}
\emph{Packets} ride on top of exec messages, see {\tt exec/ports.h}, but
they do not extend the {\tt Message} structure as it would be usually the
case. Instead, {\tt mn\_Node.ln\_Name} of the exec message is (mis-)used to
point to the {\tt DosPacket}. The reply port of the message in {\tt
  mn\_ReplyPort} is \emph{not} used; instead, the message carrying the
packet is send back to {\tt dp\_Port}.
\smallskip{}

Members of the {\tt DosPacket} structure shall be initialized as follows:
\smallskip{}

{\tt dp\_Link} shall point to the message which is used for transmitting the
{\tt DosPacket}. The message node name in {\tt mn\_Node.ln\_Name} shall be
initialized to point to the {\tt DosPacket} itself.
\smallskip{}

{\tt dp\_Port} shall point to the {\tt MsgPort} structure to which the
packet shall be send back after the handler has completed the requested
activity. This is typically, but not necessary {\tt pr\_MsgPort} of the
process sending the packet. See section~\ref{sec:process} for the definition
of the {\tt Process} structure.
\smallskip{}

{\tt dp\_Type} identifies the action requested from the handler. It shall be
filled by the process requesting an activity from a handler and is
interpreted by the handler. Section~\ref{sec:dospackets} lists the currently
documented packet types.
\smallskip{}

{\tt dp\_Res1} is the primary result code of the activity performed by the
handler. For many, but not for all packet types, this is a boolean result
code that is~0 for failure and non-zero for success. Many functions of the
\emph{dos.library} return {\tt dp\_Res1} as their return code.
\smallskip{}

{\tt dp\_Res2} is the secondary result code installed by the handler and is
typically is 0 for success, or an error code on failure. Many functions of
the \emph{dos.library} install this error code into {\tt
  IoErr()}. Section~\ref{sec:ioerr} lists the error codes defined by the
\emph{dos.library}.
\smallskip{}

{\tt dp\_Arg1} to {\tt dp\_Arg7} provide additional arguments to the
handler. They shall be filled by the process submitting a packet to a
handler. Most packet types do not require all 7 possible arguments; in such
a case, only the necessary arguments may be initialized.

\subsection{Send a Packet to a Handler and Wait for Reply}

The {\tt DoPkt()}\mkey{DoPkt()} function creates from its arguments a {\tt
  DosPacket} structure along with an exec {\tt Message} carrying it on the
fly, transmits the packet to a target port and waits for the packet to
return.

\begin{verbatim}
result1 = DoPkt(port,action,arg1,arg2,arg3,arg4,arg5)
D0               D1    D2    D3   D4   D5   D6   D7

LONG DoPkt(struct MsgPort *,LONG,LONG,LONG,LONG,LONG,LONG)
\end{verbatim}

This function performs low-level packet IO to a target message port
belonging to a handler. The {\tt port} is the {\tt MsgPort} of the handler
to contact. Depending on the context, this port should be taken from various
sources. If low-level file I/O is to be performed, the best source for the
port is the {\tt fh\_Type} pointer in the {\tt FileHandle} structure. If the
communication is related to a \emph{Lock}, the {\tt fl\_Task} member of the
{\tt FileLock} is the right source. For activities unrelated to locks or
files, the {\tt dol\_Task} member of the \emph{device list} is another
source.
\smallskip{}

{\tt action} identifies the activity to be performed by the handler or file
system. Section~\ref{sec:packettypes} lists the packet types and how they
relate to the functions of the \emph{dos.library}.
\smallskip{}

{\tt arg1} through {\tt arg5} are arguments to the packet and filled into
their {\tt dp\_Arg1} through {\tt dp\_Arg5} elements. If more arguments are
required, the packet needs to be created and transmitted manually.
\medskip{}

This function returns the primary result code of the handler from {\tt
  dp\_Res1} in {\tt result1}, and {\tt dp\_Res2} in {\tt IoErr()}.
\smallskip{}

If the caller is a process and the {\tt pr\_PktWait} pointer in the {\tt
  Process} structure is set, {\tt DoPkt()} calls through it to wait for the
packet (or rather the message carrying it) to return, see
section~\ref{sec:process}. Otherwise, {\tt DoPkt()} waits on {\tt
  pr\_MsgPort} with {\tt WaitPort()} and removes the message through {\tt
  GetMsg()}. If the caller is a task, the function even builds an exec {\tt
  MsgPort} on the fly and waits on this temporary port --- thus unlike many
other functions of the \emph{dos.library}, this function is even callable
from tasks.
\smallskip{}

If the return {\tt MsgPort} contains a message different from the one
carrying the issued packet, this function aborts with a deadend alert of
type {\tt AN\_QPktFail}, defined in {\tt exec/alerts.h}. Note that this is
quite different from exec-style communications with exec devices through
{\tt DoIO()}; this function is able to extract the send {\tt IORequest} from
the port without creating a conflict if another message is still pending in
the port. This problem of packet communication manifests itself typically
when attempting to perform I/O operations through the \emph{dos.library}
while the workbench startup message is still queued in the process message
port.
\medskip{}

Because packets typically require less than 5 arguments, additional
prototypes are supplied that do not take all arguments. They all access the
same entry within the \emph{dos.library}, the only difference is that the
function prototypes do not enforce initialization of the data registers
carrying the unneeded arguments. These functions are named {\tt DoPkt0()} to
{\tt DoPkt5()} and carry 2 to 7 arguments: The target {\tt port}, the type
of the packet {\tt action} and 0 to 5 additional arguments which are filled
into {\tt dp\_Arg1} upwards.

\subsection{Send a Packet to a Handler Asynchronously}

The {\tt SendPkt()}\mkey{SendPkt()} function transmits a packet to a target
message port of a handler without waiting for it to return. Instead, a reply
port is provided to which the packet will be returned once the handler acted
upon it.

\begin{verbatim}
SendPkt(packet, port, replyport)
	 D1     D2	D3

void SendPkt(struct DosPacket *,struct MsgPort *,struct MsgPort *)
\end{verbatim}

This function transmits {\tt packet} to the handler {\tt port}, requesting
to return it to {\tt replyport}. The function returns immediately without
waiting for the packet to return.
\smallskip{}

The {\tt packet} shall be partially initialized; in particular, {\tt
  dp\_Link} shall point to an exec {\tt Message} whose {\tt
  mn\_Node.ln\_Name} field points back to {\tt packet}. This function
\emph{does not} supply or initialize a suitable message, this is up to the
caller.
\smallskip{}

{\tt dp\_Type} shall be filled with the type of the packet, i.e. an
identifier specifying the type of activity requested from the handler, see
section~\ref{sec:packettypes}. Depending on this type, {\tt dp\_Arg1}
through {\tt dp\_Arg7} shall be initialized with additional arguments.
\medskip{}

{\tt DosPackets} can be constructed in multiple ways; the {\tt
  AllocDosObject()}\key{AllocDosObject()} function may be called to
construct a {\tt StandardPacket}\mkey{StandardPacket}. This is a structure
that contains both the {\tt Message} and the {\tt DosPacket}. It is defined
in {\tt dos/dosextens.h}:
\begin{verbatim}
struct StandardPacket {
   struct Message   sp_Msg;
   struct DosPacket sp_Pkt;
};
\end{verbatim}
{\tt AllocDosObject()} ensures that the linkage between {\tt Message} and
{\tt DosPackete} are properly initialized.
\smallskip{}

Another option is to use {\tt AllocMem()} to allocate sufficient storage to
hold a {\tt StandardPacket} and initialize the structure appropriately:
\begin{verbatim}
struct StandardPacket *sp;

sp->sp_Msg.mn_Node.ln_Name = (UBYTE *)&(sp->sp_Pkt);
sp->sp_Pkt.dp_Link         = &(sp->sp_Msg);
\end{verbatim}

\subsection{Waiting for a Packet to Return}

The {\tt WaitPkt()}\mkey{WaitPkt()} function waits on the message port of
the calling process for a packet to return.

\begin{verbatim}
packet = WaitPkt()
D0

struct DosPacket *WaitPkt(void);
\end{verbatim}

This function performs all activities to receive a message returning from a
handler; it is also implicitly called by {\tt DoPkt()}\key{DoPkt()} after
sending the messages to the handler.
\smallskip{}

If the {\tt pr\_PktWait} pointer in the {\tt Process} structure is set, {\tt
  WaitPkt()} calls through this function to wait for the arrival of a
message. Otherwise, the {\tt WaitPkt()} calls {\tt WaitPort()} to wait for a
arrival of a message on {\tt pr\_MsgPort} of the calling process, and then
calls {\tt GetMsg()} to remove it from the port. The function then returns
{\tt mn\_Node.ln\_Name} of the received message, i.e. the packet
corresponding to the message.
\smallskip{}

This function does not test whether the received message does, actually,
belong to a packet. The caller shall ensure that only {\tt Messages}
corresponding to {\tt DosPackets} can arrive at the process message port.

\subsection{Aborting a Packet}

The purpose of the {\tt AbortPkt()}\mkey{AbortPkt()} funcktion is to attempt
to abort a packet already send to a handler. However, as of the current Os
release, it does nothing and is not functional.

\begin{verbatim}
AbortPkt(port, pkt)
	  D1    D2

void AbortPkt(struct MsgPort *, struct DosPacket *)
\end{verbatim}

What this function should do is to scan {\tt port}, presumably the {\tt
  MsgPort} of the handler to which {\tt pkt} was send, and dequeue it there
if the handler is not yet working on it. Then, it would be placed back into
the port of its initiator. As of V747, this function does nothing.

\subsection{Reply a Packet to its Caller}

The {\tt ReplyPkt()}\mkey{ReplyPkt()} function returns a packet to its
initiator, filling the primary and secondary result codes. This function is
intended to be used by handlers.

\begin{verbatim}
ReplyPkt(packet, result1, result2)
	   D1      D2       D3

void ReplyPkt(struct DosPacket *, LONG, LONG)
\end{verbatim}

This function fills {\tt dp\_Res1} and {\tt dp\_Res2} of the {\tt packet}
with {\tt result1} and {\tt result2}, and sends the packet to {\tt
  dp\_Port}, the initiating port. Note that {\tt mn\_ReplyPort} of the
message pointed to by {\tt dp\_Link} is ignored, i.e. packets do \emph{not}
follow the exec protocol for replying messages.
\smallskip{}

The {\tt result1} argument is the primary result code and identical to the
return code of many \emph{dos.library} functions. {\tt dp\_Res2} is the
secondary result code and typically accessible through {\tt IoErr()}\mkey{IoErr()}
if the packet is replied to a \emph{dos.library} function.

\section{Implementing a Handler}

A \emph{handler} or a \emph{file system} is an Amiga process that retrieves
commands in the form of {\tt DosPacket}s. The main loop of a handler is
conceptionally similar to a program implementing a graphical user interface,
except that the latter retrieves messages via the \emph{intuition} IDCMP
system and works them off, whereas the handlers receive commands from the
port in the {\tt pr\_MsgPort} of its process, or any other port it may
provide to its clients.

\subsection{Handler Startup} \label{sec:handlerstartup}

When a user of the \emph{dos.library} attempts to access an absolute path,
i.e. a path including a device name, the \emph{dos.library} walks the
\emph{device list} (see section~\ref{sec:devicelist}) to find the handler
responsible for it by comparing the device name in the path with the {\tt
  dol\_Name} element of the \emph{device list}. Once a suitable entry has
been found, the \emph{dos.library} checks whether a handler is already
running by checking the {\tt dol\_Task} field of the {\tt DosList}. If
so, a packet corresponding to the called \emph{dos.library} function is send
to the port pointed to by {\tt dol\_Task}. The relation between library
functions and packet types is further explained in subsequent sections.
\smallskip{}

If {\tt dol\_Task} is {\tt NULL}, the \emph{dos.library} checks next whether
{\tt dol\_SegList} is {\tt ZERO}. If it is, the handler code is not yet
present and will be loaded from the file name indicated in {\tt
  dol\_Handler} through {\tt LoadSeg()}\key{LoadSeg()}, and its return code
is used to initialize {\tt dol\_SegList}. Once the handler is present, a new
process is created from the segment, and a startup packet is delivered to
{\tt pr\_MsgPort} of the created handler process. The \emph{dos.library}
will not continue processing the initiating call until the handler replies
to this packet.
\smallskip{}

How the startup packet is delivered depends on the {\tt dol\_GlobVec}
element of the \emph{device list} entry, see Table~\ref{table:gvvalues}. For
C or assembler handlers with a {\tt dol\_GlobVec} value of $-1$ or $-2$, the
startup packet is delivered to the {\tt pr\_MsgPort} of the handler
process. For all other values of {\tt dol\_GlobVec}, the startup packet
becomes the first argument of the {\tt START} entry at offset 4 of the
global vector of the process.
\smallskip{}

If the ``fake'' BCPL startup code from section~\ref{sec:bcplbinding} is
used, this packet is delivered in register {\tt a0} of the main
function. The following code demonstrates this:

\begin{verbatim}
LONG __asm __saveds main(register __a0 struct DosPacket *pkt)
{
    SysBase = *((struct ExecBase **)(4L));
    struct Process *proc = (struct Process *)FindTask(NULL);
    struct Message *msg;
    const UBYTE *path;
    ULONG startup;
    struct DosList *dlist;
    LONG error = 0;
    
    /* if NULL, this was a C startup, retrieve
    ** the packet manually 
    */    
    if (pkt == NULL) {
      /* Wait and retrieve the startup message
      */
      WaitPort(&proc->pr_MsgPort);
      msg = GetMsg(&proc->pr_MsgPort);
      pkt = (struct DosPacket *)msg->mn_Node.ln_Name;
    }

    path    = (const UBYTE *)BADDR(pkt->dp_Arg1);
    startup = pkt->dp_Arg2;    
    dlist   = (struct DosList *)BADDR(pkt->dp_Arg3);
    ... /* Handler initialization */

    if (error) {
      ReplyPkt(pkt,DOSFALSE,error);
      ... /* shutdown, terminate */
      return;
    } else {
      BOOL run = TRUE;
      ReplyPkt(pkt,DOSTRUE,0);
      /* main program loop */
      do {
       LONG res1 = DOSFALSE;
       LONG res2 = ERROR_ACTION_NOT_KNOWN;
       WaitPort(&proc->pr_MsgPort);
       msg = GetMsg(&proc->pr_MsgPort);
       pkt = (struct DosPacket *)(msg->mn_Node.ln_Name);
       switch(pkt->dp_Type) {
         case ACTION_....
         ....
       }
       ReplyPkt(pkt,res1,res2);
      } while(run);
    }
}
\end{verbatim}
The startup packet is populated as follows:

\begin{rkrmtable}{Handler Startup Packet} \label{table:handlerstartup}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type & \tt ACTION\_STARTUP (0) \\ \hline \hline
\tt dp\_Arg1 & BPTR to BSTR of path \\ \hline
\tt dp\_Arg2 & Copy of {\tt dol\_Startup} \\ \hline
\tt dp\_Arg3 & BPTR to {\tt DosList} \\ \hline \hline
\tt dp\_Res1 & \tt DOSTRUE \\ \hline
\tt dp\_Res2 & 0\\ \hline
\end{rkrmtable}

{\tt dp\_Type} is set to {\tt ACTION\_STARTUP}, which is defined to be~0. As
the startup packet is always received first, there is no need to test for
this particular type. However, as its type is identical to {\tt
  ACTION\_NIL}\key{ACTION\_NIL}, the startup packet may also be processed
within the main handler loop.
\smallskip{}

{\tt dp\_Arg1} is set to a BPTR to a BSTR representing the
path name under which the client of the \emph{dos.library} attempted to
access the handler. Note that this is not a {\tt NUL}-terminated C string,
but a BSTR whose first element is the size of the string.
\smallskip{}

This argument is for example taken from the first argument to {\tt
  Open()}\key{Open()}, just that it has been converted to a \emph{BSTR} by
the \emph{dos.library}. For the {\tt Console-Handler} for example, this is
the window specification that instructs the handler on the position, size
and title of the console.
\smallskip{}

{\tt dp\_Arg2} is a copy of the {\tt dol\_Startup} element of the {\tt
  DosList} structure, see section~\ref{sec:devicelist}. It is used to
configure the properties of the handler. The type that is placed here is
depends on the mount list. While its use is handler, it is typically, but
not necessarily, a BPTR to a {\tt FileSysStartupMsg}\key{FileSysStartupMsg}
structure. Other possibilities for {\tt dol\_Startup} are a BPTR to a BSTR or
an integer. What exactly the handler will receive depends on the {\tt
  Mountlist} and is discussed in more detail in
section~\ref{sec:mountdoslist} and section~\ref{sec:filesysstartup}.
\smallskip{}

{\tt dp\_Arg3} is a \emph{BPTR} to the {\tt DosList} structure that
triggered starting this handler.
\medskip{}

Multiple strategies exist how handlers make use of this information. A
\emph{file system} process would typically handle multiple files at once
through the same process. To ensure that the \emph{dos.library} sends
requests for the file system to the process just started, the \emph{file
system} shall place a pointer to the {\tt MsgPort} incoming packets are
supposed to be send to in {\tt dol\_Task} of the {\tt DosList} structure
received in {\tt dp\_Art3}. This is typically, but not necessarily, the
{\tt pr\_MsgPort} of the handler process.
\smallskip{}

Whenever a client program opens a file on this \emph{file system} or
attempts to lock an object, the handler process will be contacted by sending
a packet to the port listed in {\tt dol\_Task}.
\medskip{}

A \emph{handler} such as the {\tt CON} handler requires a separate process
for each window it manages. In such a case, {\tt dol\_Task}
remains {\tt NULL}. Thus, handlers can decide whether they require a new
process for each file opened from the handler.
\smallskip{}

While the \emph{dos.library} will also send a packet to open the file for
which the handler was launched, the path of this second packet or any
subsequent packet to open a file on the same process is not relevant to the
{\tt Console-Handler} anymore as the window will be opened during startup,
and not during opening a file. Even though the handler is started once for
the initial open and does not fill in its port in {\tt dol\_Task}, multiple
requests to open a file may arrive at the handler, e.g. when opening the
``{\tt *}'' file indicating the current console.
\medskip{}

Once the \emph{handler} or \emph{file system} initiated itself from the
startup packet, the packet shall be replied. If startup failed, the primary
result code shall be {\tt DOSFALSE} and the secondary result code shall be
an error code suitable for reporting through {\tt IoErr()}\key{IoErr()}, see
section~\ref{sec:ioerr} for a list of common error codes. Then, the handler
shall release all resources acquired so far and terminate.

\subsection{Handler Main Processing Loop}

If startup succeeded, the primary result code for the packet shall be
{\tt DOSTRUE}, and the secondary result code shall be~0. Handler operations
then proceed by waiting for incoming packets, and processing them one by another.
\medskip{}

The \emph{dos.library} keeps the \emph{device list} locked while the handler
is starting up. This means in particular that an attempt to gain access to
the \emph{device list} with {\tt LockDosList()}\key{LockDosList()}, see
section~\ref{sec:lockdoslist}, can deadlock. Even if such a call is not made
explicitly, \emph{dos.library} functions can require implicitly such a lock,
and thus attempting to access files or lock objects within handlers should
be avoided, not only during startup.
\smallskip{}

If {\tt dol\_GlobVec} is $-2$ or $-3$, the \emph{dos.library} will only
acquire a shared lock, and thus will allow the handler to retrieve a shared
lock on the \emph{device list} as well.
\medskip{}

Once started up, handlers or file systems should wait for incoming
packets. Depending on how a handler is contacted, the \emph{dos.library}
uses multiple sources to identify a suitable port:
\smallskip{}

If the handler is contacted through the special path ``{\tt *}'' or a
path starting with ``{\tt CONSOLE:}'', the port in {\tt pr\_ConsoleTask} is
used to send packets to.
\smallskip{}

If the handler is contacted through a path starting with ``{\tt PROGDIR:}''
and the {\tt pr\_HomeDir} element of the calling process is non-{\tt NULL},
the {\tt fl\_Task} element of the lock stored there is used to contact the
handler.
\smallskip{}

If the handler is contacted through an absolute path, the \emph{dos.library}
scans the \emph{device list} to locate a {\tt DosList} structure whose {\tt
  dol\_Name} element matches the device name in the path. The {\tt
  dol\_Task} field, if non-{\tt NULL}, is then used as destination of a
packet. If it is {\tt NULL}, a new process of the handler is created. From
this follows that a handler or file system can customize the port through
which it expects packets. File systems will typically place the {\tt
  pr\_MsgPort} of their process there.
\smallskip{}

If a handler is contacted through a relative path, and {\tt pr\_CurrentDir}
of the calling process is non-{\tt ZERO}, the {\tt fl\_Task} element of the
current directory of the process attempting to resolve a path is used as
target port. If {\tt pr\_CurrentDir} is {\tt ZERO}, the {\tt
  pr\_FileSystemTask} is used as target port.
\smallskip{}

If the handler is contacted through a \emph{File Handle}, for example to
read or write bytes from a file, the {\tt fh\_Type} element of the handle is
used as destination port. A file system may place a custom port in this
element on opening files through {\tt ACTION\_FINDINPUT}, {\tt
  ACTION\_FINDOUTPUT} or {\tt ACTION\_FINDUPDATE} in the {\tt fh\_Type}
element of the handle to receive all packets associated to this particular
file on an alternative port. The \emph{dos.library} places by default
there the port it found through the path, see above.
\smallskip{}

If the handler is contacted through a lock, the {\tt fl\_Task} element of
the {\tt FileLock} structure is used to send out packets. A file system thus
may customize a port through which all packets related to a particular lock
are transmitted by placing this port in {\tt fl\_Task} when creating a lock.
\smallskip{}

The special path ``{\tt NIL:}'' does not correspond to any handler but
sets the {\tt fh\_Type} element to {\tt ZERO}. Any attempt to write out data
through such a handle ignores all bytes written, and any attempt to read
bytes will return zero bytes. This is a special case in which the
\emph{dos.library} does not go through a handler at all.
\medskip{}

The main loop of a handler then checks its own process port, or all ports it
provided through the above mechanisms for incoming packets and tests their
{\tt dp\_Type} field, identifying the requested action to be
performed. Subsequent sections will provide information on all packets
documented within AmigaDOS, though third-party handlers may implement
additional packet types.
\smallskip{}

A handler or file system receiving a packet it does not implement shall set
its {\tt dp\_Res2} element to {\tt ERROR\_ACTION\_NOT\_KNOWN}. {\tt
  dp\_Res1} shall be set for non-implemented packets according to the packet
type as shown in the following table:

\begin{rkrmtable}{Primary Result Code for Unimplemented Packets} \label{table:unimp}
{\bf \tt \bf dp\_Type} & {\bf \tt \bf dp\_Res1} \\ \hline \hline
\tt ACTION\_READ  & -1 \\ \hline
\tt ACTION\_WRITE & -1 \\ \hline
\tt ACTION\_SEEK  & -1 \\ \hline
\tt ACTION\_SET\_FILE\_SIZE & -1 \\ \hline
\tt ACTION\_STACK & -1 \\ \hline
\tt ACTION\_QUEUE & -1 \\ \hline
\tt ACTION\_FORCE & -1 \\ \hline \hline
all others & ~0 \\ \hline
\end{rkrmtable}

This ensures that clients of the handler or file system will receive a
result that is an indication of an error.

\subsection{Handler Shutdown} \label{sec:terminatehandler}

A \emph{handler} that does not initialize the {\tt dol\_Task} element of its
{\tt DosList} structure should keep a counter that is incremented for each
object it creates, and decremented for each object deleted or disposed. For
example, if the handler supports opening files, then the initialization of
each file handle should increment the counter, and each file handle
closed through {\tt ACTION\_END} should decrement the counter. Once the use
counter reaches zero, the handler process should die by releasing all of its
resources and falling off its main function. This ensures that the system is
not congested by creating more and more processes of the same handler that,
effectively, cannot be contacted anymore because its process part is not
referenced in any object passed out of the \emph{dos.library}.
\smallskip{}

A typical example of a handler is the {\tt Con-Handler} of the system that
opens its window from its startup message but any file opened to it
will interact with the same window. The window will be closed when each of
these files had been closed\footnote{This is a simplification, ignoring {\tt
  AUTO} and {\tt WAIT} parameters, see section~\ref{sec:console} for details}.
\medskip{}

\emph{File systems} such as the FFS, however, typically do initialize {\tt
  dol\_Task} and thus can be reached even if all files or locks on the
volume they manage have been released. Thus, in addition to such resource
tracking, file systems should check for incoming packets of the type {\tt
  ACTION\_DIE} and then attempt to shutdown, see
section~\ref{sec:packetactiondie}. This is, of course, only possible if all
open files have been closed and all locked objects have been unlocked.
\smallskip{}

The {\tt MsgPort} or ports of such a handler may still contain packets that
have not yet been worked on after {\tt ACTION\_DIE} has been received. In
order to avoid a deadlock, the packets pending in the input queue still need
to be replied, for example using the default return codes from
table~\ref{table:unimp}.

\section{Packets for File Interactions} \label{sec:fileactions}

The packet types listed in this section are used to implement file-specific
functions, such as those listed in chapter~\ref{sec:file}. The arguments of
the packets typically follow the calling conventions of the
\emph{dos.library} functions closely, though are typically represented in
their BCPL equivalents, i.e. \emph{BPTR}s instead of regular pointers or
\emph{BSTR}s instead of {\tt NUL}-terminated C strings.

\subsection{Opening a File for Shared Access} \label{sec:actionfindinput}

The packet {\tt ACTION\_FINDINPUT}\mkey{ACTION\_FINDINPUT} initializes a
{\tt FileHandle}\key{FileHandle} structure for shared access to a file.

\begin{rkrmtable}{\tt ACTION\_FINDINPUT} \label{table:actionfindinput}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FINDINPUT (1005) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the file name \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet is used by the {\tt Open()}\key{Open()} function of the
\emph{dos.library} where the packet type is taken copied from the second
argument, i.e. the packet type is identical to the {\tt accessMode} argument
of {\tt Open()}, and thus {\tt ACTION\_FINDINPUT} is identical to
{\tt MODE\_OLDFILE}.
\smallskip{}

{\tt dp\_Arg1} is initialized to {\tt BPTR} to a {\tt
  FileHandle}\key{FileHandle} structure whose {\tt fh\_Arg1} handle should
be initialized to a value the handler or file system may use later on to
identify the file it operates on. This is particularly important to
\emph{file systems} that handle multiple files by a single process. In a
typical implementation, this opaque value may be the (internal) lock to the
opened file.
\smallskip{}

A handler or file system may also replace the {\tt fh\_Type} element of the
{\tt FileHandle} structure request that packets concerning this
particular file shall be delivered to an alternative port. This element
otherwise defaults to the process port of the handler.
\medskip{}

{\tt dp\_Arg2} is initialized to the {\tt BPTR} to a {\tt
  FileLock}\key{FileLock} structure describing the directory within which
the file to be opened is located. Typically, this corresponds to the current
directory of the caller of {\tt Open()}\key{Open()}. If this lock is {\tt
  ZERO}, then the \emph{file system} shall assume that the provided path is
relative to the root directory of the currently inserted volume. Flat file
systems or handlers may ignore this argument.
\smallskip{}

{\tt dp\_Arg3} is initialized to a {\tt BPTR} to a {\tt BSTR} providing the
path of the file relative to the directory provided by {\tt dp\_Arg1}.
\medskip{}

All other arguments of the packet shall be ignored. The handler should
locate the file indicated by {\tt dp\_Arg3} relative to {\tt dp\_Arg2}, and
fill in a boolean success code in {\tt dp\_Res1}. It shall be set to {\tt
  DOSTRUE} for success or {\tt DOSFALSE} for error. {\tt dp\_Res2} shall be
set to an error code from {\tt dos/dos.h} or~0 for success.
\medskip{}

The purpose of this packet is to prepare a \emph{FileHandle} for shared
access, either for reading or for writing. If the file cannot be located,
this packet \emph{shall not} create it but rather fail with {\tt
  ERROR\_OBJECT\_NOT\_FOUND}\key{ERROR\_OBJECT\_NOT\_FOUND}. This packet is
used by the {\tt Open()}\key{Open()} function if its second argument is set
to {\tt MODE\_OLDFILE}\key{MODE\_OLDFILE}.
\smallskip{}

Handlers such that the {\tt Port-Handler} or the {\tt Console-Handler} may
already open its resources as part of the startup-packet handling and thus
may not perform a lot of activities here. Note that both handlers do not
initialize {\tt dol\_Task} of the {\tt DosList}\key{DosList} structure and
thus each opened file will launch a new process. The FFS, however, runs on a
single process and thus distinguishes its files through {fh\_Arg1} in the
{\tt FileHandle} structure.
\smallskip{}

Note that both the Lock provided by {\tt dp\_Arg2} and the path {\tt
  dp\_Arg3} are required for locating a file on a hierarchical file
system. The path from {\tt dp\_Arg3} is logically ``appended'' to the path
implied by {\tt dp\_Arg2}, i.e. the file system starts interpreting the
former by scanning the directory hierarchy at the position given by {\tt
  dp\_Arg2}, or the root directory if {\tt dp\_Arg2} is~{\tt ZERO}.
\smallskip{}

A special case arises if {\tt dp\_Arg3} is the empty string; in such a case,
{\tt dp\_Arg2} shall be already a Lock to the file to open. This is implied
by the above algorithm to locate a file that ends walking the directory tree
whenever {\tt dp\_Arg3} ends.
\smallskip{}

The type of this packet, {\tt ACTION\_FINDINPUT}, is intentionally identical
to {\tt MODE\_OLDFILE} as the {\tt Open()} function currently initializes the
packet type from its second argument.

\subsection{Opening a File for Exclusive Access}

The packet {\tt ACTION\_FINDOUTPUT}\mkey{ACTION\_FINDOUTPUT} initializes a
{\tt FileHandle}\key{FileHandle} structure for exclusive access to a file
and potentially creates the file if it does not yet exist.

\begin{rkrmtable}{\tt ACTION\_FINDOUTPUT} \label{table:actionfindoutput}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FINDOUTPUT (1006) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of file name \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet is used by the {\tt Open()}\key{Open()} function of the
\emph{dos.library} where the packet type is taken copied from the second
argument, i.e. the packet type is identical to the {\tt accessMode} argument
of {\tt Open()}, and thus {\tt ACTION\_FINDOUTPUT} is identical to
{\tt MODE\_NEWFILE}.
\smallskip{}

The arguments of the packet are initialized as for {\tt
  ACTION\_FINDINPUT}\key{ACTION\_FINDINPUT}, see
section~\ref{sec:actionfindinput}.

\subsection{Opening or Creating a File for Shared Access}

The packet {\tt ACTION\_FINDUPDATE}\mkey{ACTION\_FINDUPDATE} initializes a
{\tt FileHandle}\key{FileHandle} structure for shared access to a file,
potentially creating the file if it does not yet exist.

\begin{rkrmtable}{\tt ACTION\_FINDUPDATE} \label{table:actionfindupdate}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FINDUPDATE (1004) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of file name \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet is used by the {\tt Open()}\key{Open()} function of the
\emph{dos.library} where the packet type is taken copied from the second
argument, i.e. the packet type is identical to the {\tt accessMode} argument
of {\tt Open()}, and thus {\tt ACTION\_FINDUPDATE} is identical to
{\tt MODE\_READWRITE}.
\smallskip{}

The arguments of the packet are initialized as for
{\tt ACTION\_FINDINPUT}\key{ACTION\_FINDINPUT}, see
section~\ref{sec:actionfindinput}.

\subsection{Opening a File from a Lock}

The packet {\tt ACTION\_FH\_FROM\_LOCK}\mkey{ACTION\_FH\_FROM\_LOCK} initializes a {\tt
  FileHandle}\key{FileHandle} structure from a lock on an existing
file. Whether this access is shared or exclusive depends on the type of the
lock. Upon success, the lock is absorbed into the \emph{FileHandle}.

\begin{rkrmtable}{\tt ACTION\_FH\_FROM\_LOCK} \label{table:actionfhfromlock}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FH\_FROM\_LOCK (1026) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet type implements the {\tt OpenFromLock()}\key{OpenFromLock()}
function of the \emph{dos.library}, see section~\ref{sec:openfromlock}. It
opens a file from a lock. On a hierarchical file system, this is equivalent
to an {\tt ACTION\_FINDINPUT} packet with {\tt dp\_Arg3} set to an empty
string.
\smallskip{}

To uniquely identify the file handle and resources associated to it later
on, the handler may place an identifier or a handle or pointer to internal
resources in the {\tt fh\_Arg1} element of the \emph{FileHandle} provided by
{\tt dp\_Arg1}. Before replying the packet, {\tt dp\_Res1} shall be set by
the handler to {\tt DOSTRUE} on success, or {\tt DOSFALSE} on error. On
success, {\tt dp\_Res2} shall be set to~$0$, and to an error code from {\tt
  dos/dos.h} otherwise.

\subsection{Closing a File}

The packet {\tt ACTION\_END}\mkey{ACTION\_END} releases all \emph{file
system} internal resources of a file handle.

\begin{rkrmtable}{\tt ACTION\_END} \label{table:actionend}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_END (1007) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

{\tt dp\_Arg1} is initialized to the {\tt fh\_Arg1} element of the
{\tt FileHandle} structure corresponding to the file that is supposed to be
closed. This value may be used by the \emph{File System} or \emph{Handler}
to uniquely identify the resources associated to the file, for example any
implicit lock on the file system object.
\smallskip{}

Before repyling to the packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE}
on success or {\tt DOSFALSE} on failure. On success, {\tt dp\_Res2} shall be
set to~0, or to an error code otherwise.
\smallskip{}

The \emph{dos.library} uses this packet to implement the {\tt
  Close()}\key{Close()} function. If it receives an error code, the library
will not release the memory of the {\tt FileHandle} structure, and as such,
it remains available to the caller of {\tt Close()} to perform other
activities on the file.

\subsection{Reading from a File}

The packet {\tt ACTION\_READ}\mkey{ACTION\_KEY} reads data from a \emph{file
system} or \emph{handler} and advances the file pointer accordingly.

\begin{rkrmtable}{\tt ACTION\_READ} \label{table:actionread}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_READ (82) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & Pointer to the buffer \\ \hline
\tt dp\_Arg3  & Number of bytes to read \\ \hline \hline
\tt dp\_Res1  & Bytes read or $-1$ \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt Read()}\key{Read()} function of the
\emph{dos.library}. The elements of the packet are initialized as follows:
\smallskip{}

{\tt dp\_Arg1} is a copy from {\tt fh\_Arg1} of the \emph{FileHandle}
structure and may be used by the \emph{file system} or \emph{handler} to
identify the file. Note that it is \emph{not} the \emph{FileHandle} itself;
instead, the \emph{handler} may create and insert such an identifier into
the \emph{FileHandle} when opening a file.
\smallskip{}

{\tt dp\_Arg2} is a pointer (not a BPTR) to the buffer to be filled.
\smallskip{}

{\tt dp\_Arg3} is the number of bytes to read.
\smallskip{}

Before replying this packet, the \emph{handler} shall fill {\tt dp\_Res1}
with the number of bytes that could be transferred into the buffer, or~$-1$
for an error condition. This number may also be~0 if no data could be
transferred, either because the end of file has been reached, or because
currently no data is available on an interactive file, such as the console
or the serial port. In case of an error, i.e. for the primary result
code~$-1$, {\tt dp\_Res2} shall be filled with an error code, otherwise it
shall be set to~$0$.
\smallskip{}

Note that there are no separate packet types corresponding to the buffered
IO functions from section~\ref{sec:bufferedio}. Instead, the
\emph{dos.library} functions at the caller side manage the buffer, monitor
its fill state and potentially call into {\tt Read()} which then generates
this packet.

\subsection{Writing to a File}

The packet {\tt ACTION\_WRITE}\mkey{ACTION\_WRITE} writes data to a
\emph{file system} or \emph{handler} and advances the file pointer
accordingly.

\begin{rkrmtable}{\tt ACTION\_WRITE} \label{table:actionread}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_WRITE (87) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & Pointer to the buffer \\ \hline
\tt dp\_Arg3  & Number of bytes to write \\ \hline \hline
\tt dp\_Res1  & Bytes written or $-1$ \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt Write()}\key{Write()} function of the
\emph{dos.library}. The elements of the packet are initialized as follows:
\smallskip{}

{\tt dp\_Arg1} is a copy from {\tt fh\_Arg1} of the \emph{FileHandle}
structure and may be used by the \emph{file system} or \emph{handler} to
identify the file.
\smallskip{}

{\tt dp\_Arg2} is a pointer (not a BPTR) to the buffer contaiing the data to
be transferred.
\smallskip{}

{\tt dp\_Arg3} is the number of bytes to write.
\smallskip{}

Before replying this packet, the \emph{handler} shall fill {\tt dp\_Res1}
with the number of bytes that could be transferred from the buffer, or~$-1$
for an error condition. In case of an error, i.e. for the primary result
code~$-1$, {\tt dp\_Res2} shall be filled with an error code, otherwise it
shall be set to~$0$.
\smallskip{}

Note that there are no separate packet types corresponding to the buffered
IO functions from section~\ref{sec:bufferedio}. Instead, the
\emph{dos.library} functions at the caller side manage the buffer, monitor
its fill state and potentially call into {\tt Write()} which then generates
this packet.

\subsection{Adjusting the File Pointer}

The packet {\tt ACTION\_SEEK}\mkey{ACTION\_SEEK} sets the file pointer
relative to a base location.

\begin{rkrmtable}{\tt ACTION\_SEEK} \label{table:actionseek}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SEEK (1008) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & File pointer offset \\ \hline
\tt dp\_Arg3  & Seek mode from Table~\ref{table:seekmode} \\ \hline \hline
\tt dp\_Res1  & Previous file position \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements, to a major degree, the {\tt Seek()}\key{Seek()}
function of the \emph{dos.library}. The elements of the packet are
initialized as follows:
\smallskip{}

{\tt dp\_Arg1} is a copy from {\tt fh\_Arg1} of the \emph{FileHandle}
structure and may be used by the \emph{file system} or \emph{handler} to
identify the file.
\smallskip{}

{\tt dp\_Arg2} defines the new location of the file pointer relative to a
position identified by {\tt dp\_Arg3}.
\smallskip{}

{\tt dp\_Arg3} defines the position to which {\tt dp\_Arg2} is relative. It
is one of the modes in table~\ref{table:seekmode} and is therefore identical
to the third argument of {\tt Seek()}\key{Seek()}.
\smallskip{}

Before replying this packet, the \emph{handler} shall fill {\tt dp\_Res1}
with the previous value of the file pointer, i.e. before making the
requested adjustment, or to~$-1$ in case an error occurred. In the latter
case, {\tt dp\_Res2} shall be filled with an error code, otherwise it shall
be set to~$0$.
\smallskip{}

While this packet type mostly implement the {\tt Seek()} function, the
latter is also aware of the (caller-side) buffer of the \emph{FileHandle}
and performs a flush of this buffer. The packet cannot, of course, perform a
flush.

\subsection{Setting the File Size}

The packet {\tt ACTION\_SET\_FILE\_SIZE}\mkey{ACTION\_SET\_FILE\_SIZE}
adjusts the size of a file, either truncating or extends it beyond its
current end of file.

\begin{rkrmtable}{\tt ACTION\_SET\_FILE\_SIZE} \label{table:actionsetfilesize}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SET\_FILE\_SIZE (1022) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & File size adjustment \\ \hline
\tt dp\_Arg3  & Mode from Table~\ref{table:seekmode} \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetFileSize()}\key{SetFileSize()}
function of the \emph{dos.library}. The elements of the packet are
initialized as follows:
\smallskip{}

{\tt dp\_Arg1} is a copy from {\tt fh\_Arg1} of the \emph{FileHandle}
structure and may be used by the \emph{file system} or \emph{handler} to
identify the file.
\smallskip{}

{\tt dp\_Arg2} defines the new size of the file or equivalently the new
position of the end of file, relative to a position identified by
{\tt dp\_Arg3}.
\smallskip{}

{\tt dp\_Arg3} defines the position to which {\tt dp\_Arg2} is relative. It
is one of the modes in table~\ref{table:seekmode} and is therefore identical
to the third argument of {\tt SetFileSize()}\key{SetFileSize()}. The new
end-of-file position of the file can therefore be set relative to the start
of the file, i.e. {\tt dp\_Arg2} is the new size of the file, relative to
the current file pointer, or relative to the current end-of-file.
\smallskip{}

Before replying this packet, the \emph{handler} shall fill {\tt dp\_Res1}
with a boolean success indicator, {\tt DOSTRUE} in case it could extend or
truncate the file as requested, or {\tt DOSFALSE} in case of error. In case
of success, {\tt dp\_Res2} shall be set to~0, otherwise it shall be set to
an error code.
\smallskip{}

Additional information on this packet is found in
section~\ref{sec:setfilesize} which describes the \emph{dos.library}
function that is based on it.

\subsection{Locking a Record of a File}

The packet {\tt ACTION\_LOCK\_RECORD}\mkey{ACTION\_LOCK\_RECORD} locks a
record of a file. Such a record lock neither provides reading nor writing to
the locked region, it just prevents locking the same region with an
exclusive lock, see section~\ref{sec:recordlocking} for details how the
protocol is supposed to use.

\begin{rkrmtable}{\tt ACTION\_LOCK\_RECORD} \label{table:actionlockrecord}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_LOCK\_RECORD (2008) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & Start offset of record \\ \hline
\tt dp\_Arg3  & Length of record \\ \hline
\tt dp\_Arg4  & Type of lock from table~\ref{table:reclockmode} \\ \hline
\tt dp\_Arg5  & Timeout (if applicable) in ticks \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt LockRecord()}\key{LockRecord()} function of
the \emph{dos.library} and attempts to lock a record of a file, given as
start offset from the beginning of the file and a byte size. The file is
identified by {\tt dp\_Arg1} which is a copy from {\tt fh\_Arg1} of the {\tt
  FileHandle} structure\footnote{The information on {\tt dp\_Arg1}
in~\cite{Bantam} is incorrect.}. There is no packet corresponding to {\tt
  LockRecords()}. Instead, the latter locks records sequentially.
\smallskip{}

The record to lock is identified by {\tt dp\_Arg2} and {\tt dp\_Arg3} which
correspond to the {\tt offset} and {\tt length} arguments of the
{\tt LockRecord()} function.
\smallskip{}

The mode by which the record is supposed to be locked is given by {\tt
  dp\_Arg4}, it identifies whether the access is shared or exclusive, and
whether a timeout is applied or not. The mode is a value from
table~\ref{table:reclockmode}, and more information on the modes is found in
section~\ref{sec:lockrecord}.
\smallskip{}

If the mode from {\tt dp\_Arg4} includes a timeout the \emph{file system}
should wait for the record to become available, it is provided by {\tt
  dp\_Arg5}. Otherwise, this argument is ignored, see
table~\ref{table:reclockmode}.
\smallskip{}

If locking the record is possible, or possible within the timeout, then {\tt
  dp\_Res1} shall be set to {\tt DOSTRUE} when replying this packet. In such
a case, {\tt dp\_Res2} shall be set to~0. On failure to obtain the record
lock, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an
error code.

\subsection{Release a Record of a File}

The packet {\tt ACTION\_FREE\_RECORD}\mkey{ACTION\_FREE\_RECORD} releases a
record lock on a portion of a file.

\begin{rkrmtable}{\tt ACTION\_FREE\_RECORD} \label{table:actionfreerecord}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FREE\_RECORD (2009) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline
\tt dp\_Arg2  & Start offset of record \\ \hline
\tt dp\_Arg3  & Length of record \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt UnLockRecord()}\key{UnLockRecord()} function
of the \emph{dos.library} and releases a lock on a subset of a file,
identified by start position and length. There is no packet corresponding to
{\tt UnLockRecords()}; instead, the \emph{dos.library} sequentially calls
{\tt UnLockRecord()} for each record.
\smallskip{}

The file itself is identified by {\tt dp\_Arg1} which is a copy from the
{\tt fh\_Arg1} element of the {\tt FileHandle} structure. The record to
release is given by the start offset within the file provided by {\tt
  dp\_Arg2} and the byte size of the record in {\tt dp\_Arg3}.
\smallskip{}

On success, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and {\tt dp\_Res2}
to~0. On error, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt
  dp\_Res2} to an error code.

\section{Packets for Interacting with Locks}

The packets listed in this section implement the \emph{dos.library}
functions listed in section~\label{sec:locks}; they create, release or
duplicate locks or create directories.

\subsection{Obtaining a Lock}

The {\tt ACTION\_LOCATE\_OBJECT}\mkey{ACTION\_LOCATE\_OBJECT} packet locates
an object --- a file or a directory --- on a \emph{file system} and creates
from it a \emph{Lock} identifying the object uniquely. The object can later
be used as active directory, to open a file from it or to retrieve metadata
such as comments or protection bits associated to the identified object.

\begin{rkrmtable}{\tt ACTION\_LOCATE\_OBJECT} \label{table:actionlocateobject}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_LOCATE\_OBJECT (8) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg2  & Mode of the Lock \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the object name \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet creates a lock from a path and a directory to which this path is
relative, also represented as a lock. As such, it implements the
{\tt Lock()}\key{Lock} function of the \emph{dos.library}.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to a \emph{FileLock} structure that represents the
object to which the path given in {\tt dp\_Arg3} is relative. This is
usually a directory, and the {\tt Lock()} function fills it from the current
directory of the calling process. This argument can be {\tt ZERO} in which
case the \emph{file system} shall assume that {\tt dp\_Arg3} is relative to
the root of the currently inserted volume handled by the file system.
\smallskip{}

{\tt dp\_Arg2} is the type of the lock to be created as defined in
table~\ref{table:lockmodes}. The value {\tt SHARED\_LOCK} requests a
non-exclusive lock on an object; multiple of such locks can be held on the
same object. The value {\tt EXCLUSIVE\_LOCK} requests an exclusive an
object; only a single exclusive lock can be held on an object at once, and
no other locks, including shared locks, are permissible. Attempting to
exclusively lock an object that is already locked shall fail, and attempting
to lock an object that is already exclusively locked shall as
well. Unfortunately, some programs call {\tt Lock()}\key{Lock()} with an
invalid argument for the mode, and thus \emph{file systems} should be
prepared to handle invalid values for {\tt dp\_Arg2}. Such values should be
considered equivalent to {\tt SHARED\_LOCK}.
\smallskip{}

{\tt dp\_Arg3} is a BPTR to a BSTR of an absolute or relative path of the
object to be locked. Relative paths are relative to the lock in {\tt
  dp\_Arg1}, and if this argument is {\tt ZERO}, relative to the root ---
the topmost directory --- of the volume currently managed by this file
system. If this string is empty, the identified object to be locked is
identical to the one identified by {\tt dp\_Arg1}.
\smallskip{}

On success, {\tt dp\_Res1} shall be a BPTR to a {\tt FileLock}
structure. These objects are created and maintained by the \emph{file
system}. This structure shall be initialized as indicated in
section~\ref{sec:filelock}:
\smallskip{}

{\tt fl\_Task} shall point to a {\tt MsgPort} through which the maintaining
\emph{file system} can be contacted, which is typically, but not necessarily
the process message port {\tt pr\_Port} of the \emph{file system} itself.
\smallskip{}

{\tt fl\_Volume} shall be a BPTR to the {\tt DosList} structure representing
the volume on which the locked object is located, see
section~\ref{sec:devicelist}.
\smallskip{}

{\tt fl\_Access} shall be filled by {\tt dp\_Arg2}, identifying the type of
the lock.
\smallskip{}

{\tt fl\_Link} may be used to queue up locks on a volume that is currently
not inserted. When a volume with locked objects is removed from the drive,
the \emph{file system} may store all these locks in a singly linked list
starting at {\tt dol\_LockList} and chained by {\tt fl\_Link}. If the same
volume is then re-inserted into another drive, another instance of the same
file system is able to pick up these locks and manage them instead. Thus,
for example, a lock on an object in drive {\tt df0:} will remain valid even
if the volume is removed and re-inserted into {\tt df1:}.
\smallskip{}

{\tt fl\_Key}, finally, may be used for the purpose of the \emph{file
system} for uniquely identifying the locked object. It is an opaque value as
far as the \emph{dos.library} is concerned.
\medskip{}

On success, the BPTR to the created {\tt FileLock} shall be stored in {\tt
  dp\_Res1} and {\tt dp\_Res2} shall be set to~0. On error, {\tt dp\_Res1}
shall be set to {\tt ZERO} and {\tt dp\_Res2} to an error code from {\tt
  dos/dos.h} identifying the source of the problem, see also
section~\ref{sec:ioerr}.

\subsection{Duplicating a Lock}

Despite its misguiding name, the packet
{\tt ACTION\_COPY\_DIR}\mkey{ACTION\_COPY\_DIR} makes a copy of a (shared)
lock.

\begin{rkrmtable}{\tt ACTION\_COPY\_DIR} \label{table:actioncopydir}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_COPY\_DIR (19) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt DupLock()}\key{DupLock()} function of the
\emph{dos.library} and attempts to replicate the lock passed in {\tt
  dp\_Arg1}. If this argument is {\tt ZERO}, the packet is supposed to
create a lock on the root directory of the currently mounted volume.
\smallskip{}

On success, {\tt dp\_Res1} is filled with the BPTR to a copy of the
{\tt FileLock} passed in, and {\tt dp\_Res2} is set to~0. On error,
{\tt dp\_Res1} is set to {\tt ZERO} and {\tt dp\_Res2} to an error code.
While~\cite{Bantam} indicates that {\t dp\_Res1} may be {\tt ZERO} on an
attempt to replicate the {\tt ZERO} lock, this is not advisable as most
users of this packet may misinterpret this result as failure case.
\smallskip{}

This packet is identical to {\tt ACTION\_LOCATE\_OBJECT} with {\tt dp\_Arg2}
set to {\tt SHARED\_LOCK} and {\tt dp\_Arg3} set to an empty string.

\subsection{Finding the Parent of a Lock}

The packet {\tt ACTION\_PARENT}\mkey{ACTION\_PARENT} obtains a shared lock on
the directory containing a locked object.

\begin{rkrmtable}{\tt ACTION\_PARENT} \label{table:actionparent}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_PARENT (29) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ParentDir()}\key{ParentDir()} function of the
\emph{dos.library} and attempts to create a lock on the directory containing
the object identified by {\tt dp\_Arg1}. If no parent exists because {\tt
  dp\_Arg1} is a lock on the root directory or the {\tt ZERO} lock, the
\emph{file system} shall set {\tt dp\_Res1} to {\tt ZERO} and {\tt dp\_Res2}
to~0, indicating that this is not a failure case.
\smallskip{}

Otherwise, this function returns on success a BPTR to the {\tt FileLock}
representing the parent directory in {\tt dp\_Arg1} and sets {\tt dp\_Arg2}
to~0. On error, {\tt dp\_Res1} is set to {\tt ZERO} and {\tt dp\_Arg2} to an
error code.

\subsection{Duplicating a Lock from a File Handle}

The packet {\tt ACTION\_COPY\_DIR\_FH}\mkey{ACTION\_COPY\_DIR\_FH} creates a
shared lock from an object opened by a \emph{file handle}; that is, it
copies the implicit lock of the handle.

\begin{rkrmtable}{\tt ACTION\_COPY\_DIR\_FH} \label{table:actioncopydirfh}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_COPY\_DIR\_FH (1030) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt DupLockFromFH()}\key{DupLockFromFH()}
function of the \emph{dos.library}, and thus creates a copy of the lock that
is implicit to an open file handle. This works only if the file is open in a
non-exclusive mode, i.e. either {\tt MODE\_READWRITE} or
{\tt MODE\_OLDFILE}.
\smallskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of the {\tt
  FileHandle} structure and thus serves to identify the opened file.
\smallskip{}

On success, {\tt dp\_Res1} is filled by the BPTR to the {\tt FileLock}
created, namely a lock to the object opened by the file handle. In such a
case, {\tt dp\_Res2} is set to~0. On error, {\tt dp\_Res1} is set to
{\tt ZERO} and {\tt dp\_Res2} to an error code.

\subsection{Finding the Parent Directory of a File Handle}

The packet {\tt ACTION\_PARENT\_FH}\mkey{ACTION\_PARENT\_FH} creates a lock
on the directory containing a file identified by a file handle.

\begin{rkrmtable}{\tt ACTION\_PARENT\_FH} \label{table:actionparentfh}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_PARENT\_FH (1031) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the \emph{FileHandle} \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ParentOfFH()}\key{ParentOfFH()} function of
the \emph{dos.library} and as such creates a lock on the directory that
contains a given \emph{file handle}. {\tt dp\_Arg1} is a copy of the {\tt
  fh\_Arg1} element of the {\tt FileHandle} structure and thus identifies
the handle.
\smallskip{}

On success, {\tt dp\_Res1} is filled with a BPTR to the {\tt FileLock}
created, and {\tt dp\_Res2} is set to~0. On error, {\tt dp\_Res1} is set to
{\tt ZERO} and {\tt dp\_Res2} to an error code.

\subsection{Creating a new Directory}

The packet {\tt ACTION\_CREATE\_DIR}\mkey{ACTION\_CREATE\_DIR} creates a new
directory and represents it by an exclusive lock on the directory created.

\begin{rkrmtable}{\tt ACTION\_CREATE\_DIR} \label{table:actionparent}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_CREATE\_DIR (22) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to BSTR of the directory name \\ \hline \hline
\tt dp\_Res1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt CreateDir()}\key{CreateDir()} function of
the \emph{dos.library} and creates a new directory of the name {\tt
  dp\_Arg2} within the directory identified by the lock {\tt dp\_Arg1}.
\smallskip{}

On success, it creates a new exclusive lock which is returned in {\tt
  dp\_Res1}, and {\tt dp\_Res2} is set to~0. On error, {\tt dp\_Res1} is set
to {\tt ZERO} and {\tt dp\_Res2} is set to an error code.

\subsection{Comparing two Locks}

The packet {\tt ACTION\_SAME\_LOCK}\mkey{ACTION\_SAME\_LOCK} compares two
locks on the same file system and checks whether the two locks are on the
same object.

\begin{rkrmtable}{\tt ACTION\_SAME\_LOCK} \label{table:actionsamelock}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SAME\_LOCK (40) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} \\ \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet is the core of the {\tt SameLock()} function of the
\emph{dos.library}, which, however, first checks whether the two locks to
compare are on the same file system. Only if so, the file system
corresponding the two locks is contacted with the above packet to compare
the two locks. For this, {\tt dp\_Arg1} and {\tt dp\_Arg2} are BPTRs to the
two {\tt FileLocks} to compare.
\smallskip{}

Upon reply, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} if the two locks
are on the same object, and in that case, {\tt dp\_Res2} shall be set
to~0. If the two locks are on two different objects, then {\tt dp\_Res1}
shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} shall also be set to~0. On
error, {\tt dp\_Res1} is set to~0 and {\tt dp\_Res2} to an error
code\footnote{The documentation in~\cite{Bantam} on {\tt dp\_Res1} is
incorrect.}.

\subsection{Changing the Mode of a Lock or a File Handle}

The packet {\tt ACTION\_CHANGE\_MODE}\mkey{ACTION\_CHANGE\_MODE} changes the
access mode of a lock or a file handle, thus potentially granting exclusive
access --- if possible --- or lowering the rights to shared access.

\begin{rkrmtable}{\tt ACTION\_CHANGE\_MODE} \label{table:actionchangemode}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_CHANGE\_MODE (1028) \\ \hline
\tt dp\_Arg1  & Object type from table~\ref{table:changemode} \\ \hline
\tt dp\_Arg2  & BPTR to \emph{FileLock} or \emph{FileHandle} \\ \hline
\tt dp\_Arg3  & Target mode \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ChangeMode()}\key{ChangeMode()} function of
the \emph{dos.library} and thus changes the access mode of files or locks to
exclusive or shared access mode.
\smallskip{}

{\tt dp\_Arg1} identifies the object whose mode is to be changed. This is a
value from table~\ref{table:changemode}, i.e. either {\tt CHANGE\_LOCK} to
adjust the type of the lock, or {\tt CHANGE\_FH} to change the access mode
of a file handle.
\smallskip{}

{\tt dp\_Arg2} is the BPTR to the object whose mode is to be changed. If
{\tt dp\_Arg1} is {\tt CHANGE\_LOCK}, this is a BPTR to a {\tt FileLock}
structure, if {\tt dp\_Arg1} is {\tt CHANGE\_FH}, it is a BPTR to a {\tt
  FileHandle} structure. Note that this is unusual as files are typically
identified by their {\tt fh\_Arg1} element and not by the handle itself. This
packet is an exception.
\smallskip{}

{\tt dp\_Arg3} is the target mode. This is either {\tt SHARED\_LOCK} for
shared access to the file or the lock, or {\tt EXCLUSIVE\_LOCK} for
exclusive access to the file or the lock\footnote{The information
in~\cite{Bantam} is incorrect on this subject matter.}. However, as
information on this packet is sparse and application programs can call the
corresponding {\tt ChangeMode()} function with incorrect target modes,
\emph{file handlers} should also accept {\tt ACTION\_FINDINPUT} and {\tt
  ACTION\_FINDUPDATE} for shared access and {\tt ACTION\_FINDOUTPUT} for
exclusive access.
\smallskip{}

Note that it is not always possible to change the mode of a lock or a file
to exclusive access, namely if it is accessed by a second file handle or
locked a second time. This packet shall then fail.
\smallskip{}

Upon reply, {\tt dp\_Res1} shall include a boolean success indicator, {\tt
  DOSTRUE} for success or {\tt DOSFALSE} for failure. In the former case,
{\tt dp\_Res2} shall be~0, in the latter case, it shall contain an error
code.

\subsection{Releasing a Lock}

The packet {\tt ACTION\_FREE\_LOCK}\mkey{ACTION\_FREE\_LOCK} releases a
lock on a file system.

\begin{rkrmtable}{\tt ACTION\_FREE\_LOCK} \label{table:actionfreelock}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FREE\_LOCK (15) \\ \hline
\tt dp\_Arg1  & BPTR to \emph{FileLock} \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the \emph{dos.library} function {\tt
  UnLock()}\key{UnLock()} and releases a {\tt FileLock}. A BPTR to the lock
to release is provided in {\tt dp\_Arg1}. If this argument is {\tt ZERO},
the \emph{file system} shall ignore the request and return success.
\smallskip{}

When replying this packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} on
success and {\tt DOSFALSE} on error. On success, {\tt dp\_Res2} shall be set
to~0, otherwise it shall be set to an error code. There are actually few
reasons why this packet could fail, probably because the passed in BPTR is
invalid and does not point to a valid {\tt FileLock}. The {\tt UnLock()}
function does not return this result code, but adjusts {\tt IoErr()}
according to {\tt dp\_Res2}.

\section{Packets for Examining Objects} \label{sec:actionfib}

The packets in this section implement the functions of section~\ref{sec:fib}
on packet level, i.e. they retrieve information from the file system on the
metadata of objects and allow to scan all objects of a
directory. Unfortunately, the packets in this section are the hardest to
implement in a robust way as the directory contents can change while a
directory scan is active, e.g. because files or directories are created or
deleted.

\subsection{Examining a Locked Object} \label{sec:actionexamineobject}

The {\tt ACTION\_EXAMINE\_OBJECT}\mkey{ACTION\_EXAMINE\_OBJECT} packet
retrieves metadata such as file name, comment and protection bits from a
lock on an object on a file system and fills a {\tt FileInfoBlock} with this
data.

\begin{rkrmtable}{\tt ACTION\_EXAMINE\_OBJECT} \label{table:actionexamineobject}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_EXAMINE\_OBJECT (23) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to a {\tt FileInfoBlock} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt Examine()}\key{Examine()} function of the
\emph{dos.library} and retrieves metainformation on the object represented
by the lock in {\tt dp\_Arg1}. This information is provided in a {\tt
  FileInfoBlock} structure that is documented in section~\ref{sec:fib}.
\smallskip{}

However, as the AmigaDOS handler design is due to historic reasons based on
BCPL, small differences exist between how this packet operates and how the
{\tt Examine()} function provides its results to the caller. In specific,
the {\tt fib\_FileName} and {\tt fib\_Comment} elements shall be filled with
a BSTRs, i.e. the first character is the length of the file name or the
comment. The conversion to a {\tt NUL}-terminated C string is performed by
the \emph{dos.library}.
\smallskip{}

The elements {\tt fib\_DirEntryType} and {\tt fib\_EntryType} shall be
filled with the same value as some programs check one and others the other
element. In particular, the value filled in shall be taken from
table~\ref{table:direntrytypes}. The value~0 shall be avoided as some
programs check for directories by testing against a positive value whereas
some others check for a non-negative value, i.e. accept~0 as a directory.
\smallskip{}

The fields {\tt fib\_OwnerUID} and {\tt fib\_OwnerGID} shall be set to~0,
unless the file system has an idea on user and group IDs --- unfortunately
AmigaDOS cannot make use of these values anyhow, and it is not documented
how these fields shall be interpreted; they are probably an opaque value.
{\tt fib\_Reserved} shall be left alone, in particular file systems
\emph{shall not} use it to store internal state information. Such
information may \emph{only} go into {\tt fib\_DiskKey}, which is an element
application programs, i.e. callers of the \emph{dos.library}, shall not
interpret.
\smallskip{}

This packet is also used to start a scan over the contents of a
directory. In such a case, the examined object is the directory itself,
i.e. the lock in {\tt dp\_Arg1} is on a directory. As such, the file system
should prepare for a scan over this directory and potentially initialize an
internal state machine.
\smallskip{}

This function returns a boolean success code in {\tt dp\_Res1}, it shall be
either set to {\tt DOSTRUE} in case information on the locked object could
be retrieved and had been successfully deposited into the {\tt
  FileInfoBlock} given by {\tt dp\_Arg2}, or shall be set to {\tt DOSFALSE}
in case of error. In the success case, {\tt dp\_Res2} shall be set to~0, or
to an error code otherwise.

\subsection{Scanning Directory Contents}

The {\tt ACTION\_EXAMINE\_NEXT}\mkey{ACTION\_EXAMINE\_NEXT} continues a scan
over the directory contents and delivers meta-information on the subsequent
entry in a directory. Such a scan is started by an {\tt
  ACTION\_EXAMINE\_OBJECT}\key{ACTION\_EXAMINE} on the directory to be
scanned; the first {\tt ACTION\_EXAMINE\_NEXT} then provides information on
the first entry in this directory and each subsequent packet to the
corresponding next entry.

\begin{rkrmtable}{\tt ACTION\_EXAMINE\_NEXT} \label{table:actionexaminenext}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_EXAMINE\_NEXT (24) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to a {\tt FileInfoBlock} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This function continues a directory scan by providing information on the
next subsequent object in the directory identified by the lock in {\tt
  dp\_Arg1}. Meta-information on the object itself is copied into the {\tt
  FileInfoBlock} structure pointed to by the BPTR in {\tt dp\_Arg2}. Similar
to {\tt ACTION\_EXAMINE\_OBJECT}\key{ACTION\_EXAMINE\_OBJECT} discussed
in~\ref{sec:actionexamineobject}, the file name and comment shall be
provided as BSTRs and not as {\tt NUL}-terminated C strings. Conversion to
the latter format is performed within the \emph{dos.library}.
\smallskip{}

Unlike Unixoid file systems, AmigaDOS does not keep entries in directories
that correspond to the directory itself or its parent directory, i.e.
AmigaDOS file systems do not carry ``{\tt .}'' or ``{\tt ..}'' directory
entries. When parsing paths, the current directory is identified by the
empty string, and the parent directory by the isolated slash (``{\tt /}'').
\smallskip{}

Unfortunately, this packet is one of the hardest to implement in a file
system as the directory may change while the scan is active. In particular,
file systems shall handle the situation gracefully in which the object from
the previous iteration identified by {\tt fib\_DiskKey} has been deleted,
moved or replaced by another object, or in which {\tt dp\_Arg1} is a
different lock than the lock that was used to start the scan by {\tt
  ACTION\_EXAMINE\_OJBECT}\key{ACTION\_EXAMINE\_OJBECT}. The file system may
only assume that the lock in {\tt dp\_Arg1} is a lock on the same directory
on which the scan has been started. Similarly, {\tt dp\_Arg2} may have
changed from the last iteration, and the file system shall only depend on
{\tt fib\_DiskKey} and {\tt fib\_DirEntryType} being identical compared to
the last iteration, all other entries can be potentially trashed or
inconsistent. Thus, the file system shall only use these two elements to
store state information. Also, file systems shall not depend on application
programs scanning directories up to the last entry; application programs can
abort a directory scan at an arbitrary point, yet file system shall release
all resources required for storing state information of the scan after at
least the lock on the scanned directory is released.
\smallskip{}

A possible implementation strategy is to store full state information in the
lock given by {\tt dp\_Arg1}, though keep sufficient information in {\tt
  fib\_DiskKey} to rebuild the full information in case the lock is released and
replaced during the scan. In the simplest possible case, {\tt fib\_DiskKey}
could be a counter that enumerates the elements in the directory, whereas
the lock contains the full state information to access the element
directly. In case the lock is replaced, {\tt ACTION\_EXAMINE\_NEXT}
\key{ACTION\_EXAMINE\_NEXT} would find the state information in the lock
missing, and would then scan forward to the element enumerated by {\tt
  fib\_DiskKey}. While this is less efficient than using the (now missing)
state information in the lock, it will at least provide information on a valid
object in the directory. Also, if an object is removed or moved out of the
scanned directory, the file system would update the state information kept
within the lock to the directory, though loosing the lock would at least
continue the scan within the directory, even though not necessary from the
same object. Storing a block number (for disk-based file systems) or a
pointer to an object (for RAM-based file systems) is, however, a bad
strategy as the corresponding disk block or RAM location may have found
other uses at the time the next object is examined. Unfortunately, such
implementation defects are rather common and have been found in multiple
file systems of AmigaDOS in the past.
\smallskip{}

This packet shall provide a boolean success code in {\tt dp\_Res1}. In case
the next object in a directory could be successfully examined and
information on it could be stored in {\tt FileInformationBlock},
{\tt dp\_Res1} shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} to~0. In
case of an error, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt
  dp\_Res2} to an error code. In case the end of the directory has been
reached and no further entries remain to be examined, this error code shall
be {\tt ERROR\_NO\_MORE\_ENTRIES}.

\subsection{Examining Multiple Entries at once}

The {\tt ACTION\_EXAMINE\_ALL}\mkey{ACTION\_EXAMINE\_ALL} packet scans a
directory supplying multiple entries at once, potentially filtering entries
through a pattern or through a hook.

\begin{rkrmtable}{\tt ACTION\_EXAMINE\_ALL} \label{table:actionexamineall}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_EXAMINE\_ALL (1033) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & APTR to a buffer to fill \\ \hline
\tt dp\_Arg3  & Size of the buffer \\ \hline
\tt dp\_Arg4  & Type defining the requested entries \\ \hline
\tt dp\_Arg5  & Pointer to struct ExAllControl \\ \hline \hline
\tt dp\_Res1  & Continuation flag \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ExAll()}\key{ExAll()} function of the
\emph{dos.library} and thus takes parameters similar to the above
function. Note that unlike many other packets, {\tt dp\_Arg2} and {\tt
  dp\_Arg5} are regular pointers and not BPTRs\footnote{The information on
{\tt dp\_Arg5} in~\cite{Bantam} is incorrect, it is really a pointer and not
a BPTR}. If the \emph{file system} does not implement this packet,
i.e. returns {\tt ERROR\_ACTION\_NOT\_KNOWN}, then the \emph{dos.library}
emulates it using {\tt ACTION\_EXAMINE\_OBJECT}\key{ACTION\_EXAMINE\_OBJECT}
and {\tt ACTION\_EXAMINE\_NEXT}\key{ACTION\_EXAMINE\_NEXT}.
\smallskip{}

{\tt dp\_Arg1} is a lock on the directory to be examined.
\smallskip{}

{\tt dp\_Arg2} is a pointer to the buffer to be filled with information on
the objects found in the directory, it is \emph{not} a BPTR. This buffer is
filled with a singly linked list of {\tt ExAllData} structures, see
section~\ref{sec:exall} for the definition of this structure. Only the
elements requested by {\tt dp\_Arg4} are filled, remaining entries are
undefined.
\smallskip{}

{\tt dp\_Arg3} is the size of the buffer provided in {\tt dp\_Arg2} in
bytes.
\smallskip{}

{\tt dp\_Arg4} defines which elements of the {\tt ExAllData} are filled. The
encoding of this argument is given by table~\ref{table:exalltypes} in
section~\ref{sec:exall}.
\smallskip{}

{\tt dp\_Arg5} is a pointer to a {\tt ExAllControl} structure, also defined
in section~\ref{sec:exall}. A detailed description of this structure is also
provided in section~\ref{sec:exall}. Note that this is really a regular
pointer, not a BPTR.
\smallskip{}

The \emph{file system} shall provide in the {\tt eac\_Entries} element of
this structure the number of {\tt ExAllData} structures it could fit into
the target buffer provided by {\tt dp\_Arg2}.
\smallskip{}

It may store internal state information of the directory scanner in {\tt
  eac\_LastKey}. This state information could, for example, correspond to
the {\tt fib\_DiskKey} in the {\tt FileInfoBlock} identifying an element in
a directory. It is zero-initialized before the first packet, and thus the
\emph{file system} may assume that a value of~0 for the key identifies the
start of the scan.
\smallskip{}

If non-{\tt NULL}, {\tt eac\_MatchString} is a parsed pattern as
generated by the {\tt ParsePatternNoCase()}\key{ParsePatternNoCase()}
function, see section~\ref{sec:parsepatternnocase}. If this pattern is
present, only directory entries whose name matches the pattern shall be
filled into the target buffer.
\smallskip{}

{\tt eac\_MatchFunc} provides even finer control of which elements are
filled into the target buffer; it supplies a {\tt Hook} structure whose {\tt
  h\_Entry} function is called for each candidate directory entry. If the
hook returns non-zero, the {\tt ExAllData} copied to the buffer shall be
considered accepted and shall remain in the buffer; if it returns zero, this
candidate entry is rejected and will be removed from the final
output. Calling conventions of this hook are also described in
section~\ref{sec:exall}.
\medskip{}

The same precautions as for {\tt
  ACTION\_EXAMINE\_NEXT}\key{ACTION\_EXAMINE\_NEXT} hold for this packet,
too. In particular, the \emph{file system} shall be prepared for the
directory to get modified between scans, by either adding, removing,
renaming or moving objects out or into the directory. Using a disk block or
a pointer to a structure representing a specific object as {\tt
  eac\_LastKey} is therefore discouraged. Similarly, {\tt dp\_Arg1} will be
a lock to the same directory, though may not necessarily be the identical
lock as used in the previous iteration over the same directory, only the
directory that is locked may assumed to be the same. In other words, {\tt
  eac\_DiskKey} shall hold sufficient state information to reconstruct the
point from which the scan is to be continued. What is, however, is ensured
is that the pointer to the {\tt ExAllControl} structure stored in {\tt
  dp\_Arg5} did not change and the \emph{file system} may depend on the
pointer having the same value as on a the previous iteration over a
directory. Also, \emph{file systems} may depend on the client sending a
packet of type {\tt ACTION\_EXAMINE\_ALL\_END}\key{ACTION\_EXAMINE\_ALL\_END}
to abort a scan before reaching the end of the directory.
\smallskip{}

This packet shall be replied with {\tt dp\_Res1} set to {\tt DOSTRUE} if not
all entries could be fit into the buffer, i.e. if {\tt dp\_Arg3} bytes were
not sufficient to hold all matching directory entries and at least another
iteration over the directory is necessary to supply (some of) the missing
entries. In such a case, {\tt dp\_Res2} shall also be set to~0. Such an
incomplete scan is either continued with another {\tt ACTION\_EXAMINE\_ALL}\key{ACTION\_EXAMINE\_ALL}
packet, or aborted by an {\tt ACTION\_EXAMINE\_ALL\_END}\key{ACTION\_EXAMINE\_ALL\_END} packet.
\smallskip{}

In case the end of the directory has reached and all directory entries could
be supplied, {\tt dp\_Res1} shall be set to~0, and {\tt dp\_Res2} to {\tt
  ERROR\_NO\_MORE\_ENTRIES}. In case the directory scan had been aborted due
to an error, {\tt dp\_Res1} shall be set to~0 and {\tt dp\_Res2} to an error
code.

\subsection{Aborting a Directory Scan}

The packet {\tt ACTION\_EXAMINE\_ALL\_END}\mkey{ACTION\_EXAMINE\_ALL\_END}
aborts a directory scan started with
{\tt ACTION\_EXAMINE\_ALL}\key{ACTION\_EXAMINE\_ALL} that returned with {\tt
  dp\_Res1} non-zero and thus indicated that the end of the directory has
not yet been reached.

\begin{rkrmtable}{\tt ACTION\_EXAMINE\_ALL\_END} \label{table:actionexamineallend}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_EXAMINE\_ALL\_END (1035) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & APTR to a buffer to fill \\ \hline
\tt dp\_Arg3  & Size of the buffer \\ \hline
\tt dp\_Arg4  & Type defining the requested entries \\ \hline
\tt dp\_Arg5  & Pointer to struct ExAllControl \\ \hline \hline
\tt dp\_Res1  & Boolean success flag \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ExAllEnd()}\key{ExAllEnd()} function of the
\emph{dos.library} and aborts a partial directory scan started with {\tt
  ExAll()}\key{ExAll()} but for which neither the end of the directory has
been reached nor an error code has been received. This packet may be used by
an implementing \emph{file system} to release any temporary resources
allocated for the purpose of the scan.
\smallskip{}

{\tt dp\_Arg1} is the lock on the directory on which a partial directory
scan has been started. It is not necessarily the original lock passed into
{\tt ACTION\_EXAMINE\_ALL}, but a lock on the same directory.
\smallskip{}

{\tt dp\_Arg2} and {\tt dp\_Arg3} are a pointer to a buffer and its
size. This buffer, however, will not be touched and no data will be
deposited there; as this buffer is not necessarily the same as the one for
which the scan has been started, this information is likely not very useful,
but it is provided here anyhow.
\smallskip{}

{\tt dp\_Arg4} is a type information which would define the information that
would go into the buffer provided by {\tt dp\_Arg2}; however, as this packet does not
request to add any data to the buffer, it is probably not very
helpful and \emph{file systems} should probably ignore it as no useful
decisions can be derived from what the requested information actually was.
\smallskip{}

{\tt dp\_Arg5} is a pointer to a {\tt ExAllControl} structure, and the
pointer provided here is identical to the pointer provided to {\tt
  ACTION\_EXAMINE\_ALL}\key{ACTION\_EXAMINE\_ALL}. Thus, \emph{file systems}
may use this pointer value and specifically the {\tt eac\_DiskKey} element
therein to release any resources related to this scan.
\smallskip{}

Before replying this packet, the \emph{file system} shall set {\tt dp\_Res1}
to a boolean success code whether it could abort the scan. If {\tt dp\_Res1}
is set to {\tt DOSTRUE} indicating that the scan was aborted successfully,
then {\tt dp\_Res2} shall also be set to~0.
\smallskip{}

If the \emph{file system} does not implement this packet, it shall set {\tt
dp\_Res1} to {\tt DOSFALSE} and {\tt dp\_Res2} to {\tt ERROR\_ACTION\_NOT\_KNOWN}.
The \emph{dos.library} then (attempts to) emulates this packet by setting
the match pattern in the {\tt ExAllControl} structure to a pattern that
matches no entry, and then continues the scan with a {\tt ACTION\_EXAMINE\_ALL}
packet. This would then clearly reach the end of the directory without
overruning the buffer. However, due to a defect in the \emph{dos.library} up
to the latest release, the (non-matching) pattern is a literal pattern and
not a pre-parsed pattern and thus, actually, could match an entry in the
directory. Thus, it is advised to always implement {\tt ACTION\_EXAMINE\_ALL\_END}
if {ACTION\_EXAMINE\_ALL} is implemented, even if it is just replied with
success and no additional resources need to be released.
\smallskip{}

On any other error, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt
  dp\_Res2} to an error code from {\tt dos/dos.h}.

\subsection{Examining from a File Handle}

The {\tt ACTION\_EXAMINE\_FH}\mkey{ACTION\_EXAMINE\_FH} packet provides meta
data on an object identified by a \emph{file handle} rather than a
\emph{lock}; that is, it uses the (implied) lock of the opened file to
retrieve information.

\begin{rkrmtable}{\tt ACTION\_EXAMINE\_FH} \label{table:actionexaminefh}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_EXAMINE\_FH (1034) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of the {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & BPTR to a {\tt FileInfoBlock} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ExamineFH()}\key{ExamineFH()} function of
the \emph{dos.library} and retrieves information on an object from a
\emph{file handle} rather than a \emph{lock}.
\smallskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of the
{\tt FileHandle} that is to be examined and thus serves to identify the
object to be examined\footnote{Note, again, that the information in~\cite{Bantam} on {\tt
  dp\_Arg1} is incorrect.}.
\smallskip{}

{\tt dp\_Arg2} is a BPTR to a {\tt FileInfoBlock} structure as documented in
section~\ref{sec:fib}, and which shall be filled by the \emph{file system}
with the information on the object identified by {\tt dp\_Arg1}. As for the
packet type {\tt ACTION\_EXAMINE\_OBJECT}\key{ACTION\_EXAMINE\_OBJECT}
specified in section~\ref{sec:actionexamineobject}, the {\tt FileInfoBlock}
passed out to the caller of the \emph{dos.library} and what the packet shall
deliver differ. In specific, {\tt fib\_FileName} and {\tt fib\_Comment} shall be
BSTRs with the length of the string in the zeroth element, and not {\tt
  NUL}-terminated C strings. The conversion to C strings happens within the
\emph{dos.library}.
\smallskip{}

Before replying this packet, the \emph{file system} shall set {\tt dp\_Res1}
to a boolean result code. On success, {\tt dp\_Res1} shall be set to {\tt
  DOSTRUE} and {\tt dp\_Res2} to~0. On failure, {\tt dp\_Res1} shall be set
to {\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\section{Packets for Working with Links}

The packets in this section interact with links; they create them, or in
case of soft-links, resolve them and update a path given the
link. Section~\ref{sec:links} provides background information on links and
on the interface within the \emph{dos.library} for links.

\subsection{Creating Links}

The {\tt ACTION\_MAKE\_LINK}\mkey{ACTION\_MAKE\_LINK} packet creates a link
in a file system.

\begin{rkrmtable}{\tt ACTION\_MAKE\_LINK} \label{table:actionmakelink}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_MAKE\_LINK (1021) \\ \hline
\tt dp\_Arg1  & BPTR to a {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to BSTR of the link to create \\ \hline
\tt dp\_Arg3  & BPTR to {\tt FileLock} or APTR to C-string \\ \hline
\tt dp\_Arg4  & Type of the link, from table~\ref{table:linktypes} \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt MakeLink()}\key{MakeLink()} function of the
\emph{dos.library} and as such creates soft- or hardlinks within the
\emph{file system}.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to a {\tt FileLock} structure that identifies the
directory within which the object is to be created.
\smallskip{}

{\tt dp\_Arg2} is a BPTR to a BSTR that provides the name of the link to be
created.
\medskip{}

{\tt dp\_Arg3} identifies the target of the link, i.e. the object the link
points to. If {\tt dp\_Arg4} is {\tt LINK\_HARD}, then this argument is a
{\tt BPTR} to a {\tt FileLock} structure identifying the target.  If this
{\tt FileLock} identifies an object on the same file system as {\tt
  dp\_Arg1}, then a hard link is created. If the object locked by {\tt
  dp\_Arg3} is a file, then the created link will represent a file,
otherwise a directory.
\smallskip{}

Resolution of hard links is up to the \emph{file system}. That is, if the
link is accessed, it is up to the \emph{file system} to locate the target of
the link and access it instead of the link. Multiple implementation
strategies exist for hard links: Either, each object includes a reference
count that is incremented for each directory entry pointing to it, that is
for each link created; likewise, this counter is decremented each time a
directory entry is removed. If the counter reaches~0, the object itself is
deleted.
\smallskip{}

Alternatively, each link is pointing to the linked object, and the object
itself contains a list of links that reference it. If a link is deleted, it
is removed from its directory and from the list of links within the target
object. If the object itself is deleted, one of the links becomes the object
itself and the list of links is copied from the deleted object to this
link. The FFS follows (mostly for backwards compatibility) this latter
approach.
\medskip{}

If {\tt dp\_Arg4} is {\tt LINK\_HARD} and the {\tt FileLock} pointed to by
{\tt dp\_Arg3} is on a different file system, then an external link shall be
created. That is, the \emph{file system} addressed by the packet shall
create a file or directory within its own file system in the directory
identified by {\tt dp\_Arg1}, and this file or directory shall mirror the
contents of the link target given by {\tt dp\_Arg4} whenever the link or an
object within the link is accessed; the file system shall thus implement
a ``copy on read'' for the linked object and all objects within the linked
object if this object is a directory.
\smallskip{}

If the target of such a link is deleted or an object within the linked
target, the copy within the \emph{file system} containing the link remains
accessible as a regular file or directory. If no copy has been created so
far, an attempt to access the linked object fails with {\tt
  ERROR\_OBJECT\_NOT\_FOUND}.
\smallskip{}

Currently, only the \emph{RAM-Handler} implements this type of link, and it
is there used to realize the {\tt ENV:} assign containing all preferences
settings. The external link pulls only those preferences settings into the
RAM disk that are actually required, at the time they are required.
\medskip{}

If {\tt dp\_Arg4} is {\tt LINK\_SOFT}, then {\tt dp\_Arg3} is a pointer to a
{\tt NUL}-terminated C string providing the target of the link. This string
is interpreted as a path name relative to the location of the link source at
the time the link is resolved\footnote{This is quite unusual as AmigaDOS
otherwise depends on BSTR representation for packets.}.
\smallskip{}

Resolution of soft links is performed within the \emph{dos.library} or
within the client application as not all functions of the library implement
soft link resolution. For a list of functions that \emph{do} implement it,
see table~\ref{table:softenabled}.
\smallskip{}

Upon accessing a soft link, or a path containing a soft link, the \emph{file
system} shall create an error code {\tt ERROR\_IS\_SOFT\_LINK}. If this
error is returned, the sender of a packet accessing the link --- thus
typically the \emph{dos.library} itself --- shall read the target of the
link with the {\tt ReadLink()}\key{ReadLink()} function specified in
section~\ref{sec:readlink}. This function then again contacts the file
system containing the link with a {\tt
  ACTION\_READ\_LINK}\key{ACTION\_READ\_LINK} which will construct from the
link an updated path to the object.
\smallskip{}

From this follows that a \emph{file system} is not aware whether the target
of a soft link actually exists as it can only provide the path to the
object, but not necessarily the object itself; in particular, soft links may
cross file system boundaries. If the target of a soft link is deleted, the
soft link itself remains and becomes a ``dangling'' link. When accessing
such a link, its resolution fails with an error {\tt
  ERROR\_OBJECT\_NOT\_FOUND}.
\medskip{}

Upon replying the packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and
{\tt dp\_Res2} to~0 on success. On failure, {\tt dp\_Res2} shall be set to
{\tt DOSFALSE} and {\tt dp\_Res1} to an error code.

\subsection{Resolving a Soft Link} \label{sec:actionreadlink}

The {\tt ACTION\_READ\_LINK}\mkey{ACTION\_READ\_LINK} packet constructs from
a path containing a soft link an updated path by inserting the target of the
link.

\begin{rkrmtable}{\tt ACTION\_READ\_LINK} \label{table:actionreadlink}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_READ\_LINK (1024) \\ \hline
\tt dp\_Arg1  & BPTR to a {\tt FileLock} \\ \hline
\tt dp\_Arg2  & APTR to C string \\ \hline
\tt dp\_Arg3  & APTR to buffer \\ \hline
\tt dp\_Arg4  & Buffer size \\ \hline \hline
\tt dp\_Res1  & Actual buffer size needed \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt ReadLink()}\key{ReadLink()} function of the
\emph{dos.library} and is used there to resolve soft links and obtain the
link target. Implementing this packet correctly requires, however, some care
as the soft link may be in the middle of the path provided by {\tt dp\_Arg2}
and not just its last component, and the soft link itself may be an absolute
or relative path. This packet needs to provide from the original path an
updated path that points to the intended location relative to the location
of the soft link, and not relative to {\tt dp\_Arg1}.
\smallskip{}

{\tt dp\_Arg1} is a lock to a directory in the \emph{file system} to which
this packet has been send and relative to which the path in {\tt dp\_Arg2}
shall be interpreted. This \emph{need not} to be the directory containing
the link.
\smallskip{}

{\tt dp\_Arg2} is a pointer to a path name containing a soft link on this
\emph{file system}. This is, unlike in many other packets, not a BPTR to a
BSTR but a pointer to a regular {\tt NUL}-terminated C string.
\smallskip{}

The \emph{file system} shall now proceed with soft link resolution as
follows: Starting from the directory given by {\tt dp\_Arg1}, it shall
interpret the path in {\tt dp\_Arg2} component by component as explained in
section~\ref{sec:paths}, until it finds a soft link. That is, colons (``{\tt
  :}'') indicate that the scan should continue at the root directory of the
volume, an isolated slash (``{\tt /}'') shall enter the parent directory,
and all other components terminated by a slash shall be interpreted as names
of directories that shall be recursively entered. This process continues
until either the end of the path is found, or --- and this is the purpose of
this packet --- a soft link is detected.
\smallskip{}

If a soft link is detected as part of the path, the target of the link as
stored in the file system shall be read. Note that the link target may not
only consist of an isolated file or directory name, but may well be an
absolute or relative path that shall be merged with the path provided in
{\tt dp\_Arg2}.
\smallskip{}

In particular, if the path stored in the soft link contains a colon (``{\tt
  :}''), and hence is an absolute path, the components parsed off from {\tt
  dp\_Arg2} up to the detection of the soft link shall be disregarded in
order to start from the root directory. If no device or volume name is
provided in the absolute link target, the \emph{file system} shall insert
the name of the current volume, and a colon, in order to provide an
unambiguous anchor of the newly constructed path. The remaining of the path
stored in the soft link is then concatenated to this device or volume
specification. Finally, the rest of the components from {\tt dp\_Arg2}
behind the component name of the soft link are concatenated to this
intermediate path, forming the final link target.
\smallskip{}

If the path stored in the soft link is a relative path, then it shall be
concatenated to the path from {\tt dp\_Arg2} up to the component name of the
soft link at which iterating through {\tt dp\_Arg2} was interrupted. The
remaining components from {\tt dp\_Arg2} behind the component name of the
soft link is then attached to this intermediate path, forming the final
result.
\smallskip{}

This procedure is tedious, but it ensures that the soft link is interpreted
relative to the path from which the client application detected it, even if
the soft link is the middle of the supplied path and not contained in the
directory provided by {\tt dp\_Arg1}. Note that the above algorithm only
resolves a single soft link in a path; this is intentional, the
\emph{dos.library} will send another {\tt ACTION\_READ\_LINK} packet to the
same or another file system if the remaining path contains additional soft
links, or even in case the soft link points to another soft link. It is
therefore important at the level of client application --- or the
\emph{dos.library} --- to detect endless loops of soft links pointing to
each other. The \emph{dos.library} aborts soft link resolution after~15
links.
\medskip{}

{\tt dp\_Arg3} is the pointer (not a BPTR) to a target buffer into which the
newly constructed path, with the soft link resolved, shall be provided as a
{\tt NUL}-terminated C string.
\smallskip{}

{\tt dp\_Arg4} is the size of this target buffer in bytes.
\smallskip{}

On an error, {\tt dp\_Res1} shall be set to~$-1$\footnote{~\cite{Bantam}
recommends to set it to~$-2$ on a target buffer overflow, though currently
any negative value will do. Unfortunately, even the latest version of the
FFS will \emph{not} return a negative value but~$0$ in case of an error;
this is a defect.} and {\tt dp\_Res2} to an error code. In particular, if
the target buffer size {\tt dp\_Arg4} is too small to hold the resolved
path, {\tt dp\_Res2} shall be set to {\tt ERROR\_LINE\_TOO\_LONG}.
\smallskip{}

If the source path in {\tt dp\_Arg2} does actually not contain a soft link
and the scanning algorithm aborted without finding one, this also
consistutes an error that shall be reported by setting {\tt dp\_Res1}
to~$-1$. This error is not handled consistently in AmigaDOS. The RAM-Handler
reports {\tt ERROR\_OBJECT\_WRONG\_TYPE}, the FFS the error code
{\tt ERROR\_OBJECT\_NOT\_FOUND}. The former error is probably more sensible.
\smallskip{}

On success, {\tt dp\_Res1} shall be set to the length of the constructed
path, i.e. to the length of the string in {\tt dp\_Arg3} (not including the
terminating {\tt NUL}), and {\tt dp\_Res2} to~0.
\smallskip{}

The following example is a skeleton code implementing the above algorithm:
\begin{verbatim}
/*
** Skeleton of an implementation of the readlink function
** lock   is from dp_Arg1 and a BPTR to a filelock
** string is from dp_Arg2 and the path containing a link
** buffer is from dp_Arg3 and the target buffer
** size   is from dp_Arg4 and the size of the buffer.
*/
LONG readlink(BPTR lock, UBYTE *string,UBYTE *buffer, ULONG size)
{
  struct node *node,*linknode;
  UBYTE *src  = string;
  LONG is_dir = FALSE;
  LONG path_before;
  LONG path_pos;
  LONG res,len;
  /* Pointer to DosList of this handler, needed
  ** for the name of the volume.
  */
  extern struct DosList *volumenode;
  
  /*
  ** Find the object from lock and string. This is a file
  ** system internal function that need to be provided
  ** by the user. 
  ** path_before is the offset of the last component
  ** of the path in the string that could be resolved
  ** successfully. If a softlink is found in the
  ** middle of the path, or some other error was found,
  ** NULL is returned.
  ** link_node is set to a pointer to a structure that
  ** represents the link.
  ** path_pos is set to the offset of the "/" behind 
  ** the soft link if a soft link is in the middle.
  ** If the link is the last component of the path, then
  ** the node that represents the soft link is returned,
  ** Otherwise, the node is returned.
  */
  node = locatenode(lock,string,&path_before,
                    &linknode,&path_pos);
  if (!node) {
    if (IoErr() == ERROR_IS_SOFT_LINK) {
      is_dir = TRUE;		/* remember... */
      node   = linknode;
    } else {
      /* Resolution did not work for some 
      ** other error. Return an error.
      */
      return -1;
    }
  }

  /* 
  ** Check whether the found object is a softlink
  */
  if (node->type != ST_SOFTLINK) {
    res2 = ERROR_OBJECT_WRONG_TYPE;
    return -1;
  }

  /*
  ** Check whether the link is in the middle or the end of
  ** the path.
  */
  if (is_dir) {
    /* must deal with '/' and ':' correctly in the soft link
    ** code below counts on these assigns! 
    */
    string = string + path_pos;
    len    = strlen(string) + 1;       /* + 1 for slash */
  } else {
    len    = 0;	/* softlink is last part of string */
  }

  /*
  ** Check whether there is sufficient room in the
  ** target buffer.
  */
  if (node->size + 1 + path_before + len >= size) {
    res2 = ERROR_LINE_TOO_LONG;
    return -2;
  }

  /*
  ** Copy the head of the link resolution path to the 
  ** target buffer, ready to append the contents of
  ** the link.
  */
  memcpy(buffer,src,path_before);

  /*
  ** copy the target of the soft link into the buffer behind
  ** the path of the link as zero-terminated C string. 
  ** This function also need to be provided by the 
  ** implementation of the file system. It returns
  ** the size of the soft link as result, or -1 on error.
  */
  res = readsoftlink(node,buffer + path_before,size - path_before);
  if (res < 0)
    return res; /* Deliver the error */

  /*
  ** If the link is absolute, i.e. contains a ':', then ignore the
  ** start of the string. 'res' is the length of the link location.
  */
  src = strchr(buffer + path_before,':');
  if (src) {
    /* Yes, is absolute. First check whether it is ":", thus
    ** whether it refers to this volume.
    */
    if (src == buffer + path_before) {
      /* Is relative to our root, but not necessarily 
      ** to the root of the caller, so fix up.
      */
      char *volname = (char *)BADDR(volumenode->dl_Name);
      LONG len      = *volname; /* It's a BSTR */
      /* Check whether there is enough buffer */
      if (len + res >= size) {
        SetIoErr(ERROR_LINE_TOO_LONG);
        return -2;
      } else {
        /* Move soft link behind the volume name,
        ** note that the softlink is ":" here and
        ** the ":" becomes part of the volume name.
        */
        memmove(buffer + len ,buffer + path_before,res + 1);
        /* Prepend the volume name */
        memcpy(buffer,volname + 1,len);
        res += len;
      }
    } else {
      /* Here the link is absolute to a given volume
      ** so move the soft link behind the volume name
      */
      memmove(buffer,buffer + path_before,res + 1);
    }
  }
  
  /* add on the rest of the path behind
  ** the soft link if it sits in the middle
  */
  if (is_dir) {
    if(!AddPart(buffer, string, size)) {
      SetIoErr(ERROR_LINE_TOO_LONG);
      return -2;
    }
  }

  /*
  ** The result is the length of the path created
  */
  return strlen(buffer);
}
\end{verbatim}

\section{Packets for Adjusting Metadata}

Packets in this section change metadata associated with file system objects,
such as name, comment, creation date or protection flags.

\subsection{Renaming or Moving Objects}

The {\tt ACTION\_RENAME\_OBJECT}\mkey{ACTION\_RENAME\_OBJECT} changes the
name of an object such as a file, directory or a link, and relocates it
within the directory tree of a volume.

\begin{rkrmtable}{\tt ACTION\_RENAME\_OBJECT} \label{table:actionrenameobject}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_RENAME\_OBJECT (17) \\ \hline
\tt dp\_Arg1  & BPTR to source {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to BSTR of the object path \\ \hline
\tt dp\_Arg3  & BPTR to target {\tt FileLock} \\ \hline
\tt dp\_Arg4  & BPTR to BSTR of the target path \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt Rename()}\key{Rename()} function of the
\emph{dos.library} and relocates and renames objects within the directory
structure of a volume. This packet cannot relocate across volumes,
i.e. {\tt dp\_Arg1} and {\tt dp\_Arg3} are locks to objects within the same
volume, and {\tt dp\_Arg2} and {\tt dp\_Arg4} represent paths within this
volume.
\smallskip{}

{\tt dp\_Arg1} represents the directory to which the source {\tt dp\_Arg2}
is relative to.
\smallskip{}

{\tt dp\_Arg2} is the path of the original object location. This path need
not to consist of a single component, though the object to rename or
relocate is the last component of this path. The \emph{file system} needs to
walk the provided path, starting from {\tt dp\_Arg1}, to identify the object
that is to be renamed or moved.
\smallskip{}

{\tt dp\_Arg3} is the directory to which the target path {\tt dp\_Arg4} is
relative to.
\smallskip{}

{\tt dp\_Arg4} is the target path of the object, relative to {\tt
  dp\_Arg3}.
\smallskip{}

Several cases for renaming exist the \emph{file system} shall consider: If
the last component does not yet exist within the file system, the object
identified by {\tt dp\_Arg1} and {\tt dp\_Arg2} shall be moved into the
directory represented by the second to last component of of {\tt dp\_Arg4}
starting from {\tt dp\_Arg3}, or directly into {\tt dp\_Arg3} if {\tt
  dp\_Arg4} only consists of a single component, and shall be renamed to the
last component of the path in {\tt dp\_Arg4}.
\smallskip{}

If the object identified by {\tt dp\_Arg3} and the path in {\tt dp\_Arg4}
does already exist and represents a directory, the object shall be moved
\emph{into} this directory, retaining its original name.
\smallskip{}

If the last component does already exist and is a file, and this file is
different from the source object, an error shall be generated. Renaming a
file or directory to itself, or to a file name that only differs in case
shall, however, be accepted, and shall adjust its case (i.e. changing
letters in its name to lower or upper case is permissible).
\smallskip{}

Particular care needs to be taken if the object to be relocated is a
directory. In such a case, the \emph{file system} shall test whether an
attempt is made to move the object into itself, i.e. into one of the
subdirectories of its own. As this would render the directory unreachable,
an error shall be generated.
\medskip{}

Before replying the packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On error, {\tt dp\_Res1} shall be to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Deleting an Object}

The {\tt ACTION\_DELETE\_OBJECT}\mkey{ACTION\_DELETE\_OBJECT} removes an
object from a directory, releasing the storage it occupies.

\begin{rkrmtable}{\tt ACTION\_DELETE\_OBJECT} \label{table:actiondeleteobject}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_DELETE\_OBJECT (16) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to BSTR of the object path \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt DeleteFile()}\key{DeleteFile()} function of
the \emph{dos.library}, which can delete files, directories and links.
\smallskip{}

{\tt dp\_Arg1} is a lock to the directory to which the path in {\tt
  dp\_Arg2} is relative. The {\tt DeleteFile()} function fills it with the
current directory of the calling process.
\smallskip{}

{\tt dp\_Arg2} is the path to the object to be deleted. The path can contain
multiple components, in which case the file system need to walk the path
starting at {\tt dp\_Arg1} until reaching its last component which is the
object to be deleted. If the target is a directory, the \emph{file system}
shall check, in addition, if the directory is empty, and if not so, refuse
to delete it.
\smallskip{}

Before replying the packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. In case of success, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and
{\tt dp\_Res2} to~0. On error, {\tt dp\_Res1} shall be set to {\tt DOSFALSE}
and {\tt dp\_Res2} to an error code.

\subsection{Changing the Protection Bits}

The {\tt ACTION\_SET\_PROTECT}\mkey{ACTION\_SET\_PROTECT} changes the
protection bits of a file system object.

\begin{rkrmtable}{\tt ACTION\_SET\_PROTECT} \label{table:actionsetprotect}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SET\_PROTECT (21) \\ \hline
\tt dp\_Arg2  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the object path \\ \hline
\tt dp\_Arg4  & New protection bits \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetProtection()}\key{SetProtection()}
function of the \emph{dos.library}; it changes the protection bits of an
object on the file system to that given in {\tt dp\_Arg4}. For the
definition of protection bits, see section~\ref{sec:fib},
table~\ref{table:protectionbits}. Some \emph{file systems} may support only
a subset of all protection bits, or may not be able to carry them on all
objects, such as directories; in such a case, they may ignore the request,
or may only implement a subset of all bits.
\smallskip{}

{\tt dp\_Arg2} is a lock of a directory which the path in {\tt dp\_Arg3} is
relative to\footnote{This not a typo, {\tt dp\_Arg1} is really unused}.
\smallskip{}

{\tt dp\_Arg3} is a path relative to {\tt dp\_Arg2} whose last component is
the object whose protection bits are to be changed.
\smallskip{}

{\tt dp\_Arg4} are the new protection bits as specified in
table~\ref{table:protectionbits}. Note that the first four bits are shown
inverted by most system tools such as the {\tt List} command.
\smallskip{}

Before replying to this packet, the \emph{file system} shall set {\tt
  dp\_Res1} to a boolean result code. On success, {\tt dp\_Res1} shall be
set to {\tt DOSTRUE} and {\tt dp\_Res2} shall be set to~0. On error, {\tt
  dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an error
code.

\subsection{Setting the Comment to an Object}

The {\tt ACTION\_SET\_COMMENT}\mkey{ACTION\_SET\_COMMENT} packet changes,
adds or removes a comment on a file system object such as a directory, file
or link.

\begin{rkrmtable}{\tt ACTION\_SET\_COMMENT} \label{table:actionsetcomment}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SET\_COMMENT (28) \\ \hline
\tt dp\_Arg2  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the object path \\ \hline
\tt dp\_Arg4  & BPTR to BSTR of comment \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetComment()}\key{SetComment()} function of
the \emph{dos.library} and as such changes, adds or removes a comment on a
file, directory or link. Not all file systems will support this request, or
may only support comments on a subset of objects.
\smallskip{}

{\tt dp\_Arg2} represents a directory relative to which the path in
{\tt dp\_Arg3} shall be interpreted.
\smallskip{}

{\tt dp\_Arg3} is the path relative to {\tt dp\_Arg2} of the object whose
comment is to be changed.
\smallskip{}

{\tt dp\_Arg4} is a BPTR to a BSTR of the new comment to be set. If this
string is empty, the comment will be removed.
\smallskip{}

Before replying to this packet, the \emph{file system} shall set {\tt
  dp\_Res1} to a boolean result code. On success, {\tt dp\_Res1} shall be
set to {\tt DOSTRUE} and {\tt dp\_Res2} shall be set to~0. On error, {\tt
  dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an error
code.

\subsection{Setting the Creation Date of an Object}

The {\tt ACTION\_SET\_DATE}\mkey{ACTION\_SET\_DATE} packet sets the creation
date of an object on a file system.

\begin{rkrmtable}{\tt ACTION\_SET\_DATE} \label{table:actionsetdate}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SET\_DATE (34) \\ \hline
\tt dp\_Arg2  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the object path \\ \hline
\tt dp\_Arg4  & BPTR to {\tt DateStamp} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetFileDate()}\key{SetFileDate()} function
of the \emph{dos.library} and sets the creation date of an object on a file
system. Not all \emph{file systems} will support this packet, or may only
support it with reduced precision of the date.
\smallskip{}

{\tt dp\_Arg2} represents a directory relative to which the path in {\tt
  dp\_Arg3} is interpreted\footnote{The information in~\cite{Bantam} is
incorrect, and {\tt dp\_Arg1} is, indeed, unused.}.
\smallskip{}

{\tt dp\_Arg3} is the path of the object whose creation date is to be
changed. This path shall be interpreted relative to {\tt dp\_Arg2}, and its
last component is the object whose creation date shall be changed.
\smallskip{}

{\tt dp\_Arg4} is a BPTR to a {\tt DateStamp} structure as specified in
section~\ref{sec:dates} and defines the target date to install for the
object.
\smallskip{}

Before replying to this packet, the \emph{file system} shall set
{\tt dp\_Res1} to a boolean result code. On success, {\tt dp\_Res1} shall be
set to {\tt DOSTRUE} and {\tt dp\_Res2} shall be set to~0. On error,
{\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an error
code.

\subsection{Setting the Owner of an Object}

The {\tt ACTION\_SET\_OWNER}\mkey{ACTION\_SET\_OWNER} packet sets the owner
and group ID of an object in a file system.

\begin{rkrmtable}{\tt ACTION\_SET\_OWNER} \label{table:actionsetowner}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SET\_OWNER (1036) \\ \hline
\tt dp\_Arg2  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg3  & BPTR to BSTR of the object path \\ \hline
\tt dp\_Arg4  & Owner information \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetOwner()}\key{SetOwner()} function of the
\emph{dos.library} and is supposed to set a group and user ID of an object
in a file system; the actual encoding of this information is specific to the
\emph{file system} and not defined by the \emph{dos.library} or the
packet. {\tt dp\_Arg4} is a literal copy of the second argument of {\tt
  SetOwner()}. Note further that most if not all AmigaDOS \emph{file
systems} do not implement this packet, and as AmigaDOS is not a multi-user
system, the value of this packet is questionable.
\smallskip{}

{\tt dp\_Arg2} represents a directory relative to which the path in {\tt
  dp\_Arg3} is interpreted.
\smallskip{}

{\tt dp\_Arg3} is the path of the object whose owner information is to be
changed. This path shall be interpreted relative to {\tt dp\_Arg2}.
\smallskip{}

{\tt dp\_Arg4} is a \emph{file system} specific owner information; the
\emph{dos.library} does not define its meaning. This argument is a verbatim
copy of the second argument of {\tt SetOwner()}.
\smallskip{}

Before replying to this packet, the \emph{file system} shall set
{\tt dp\_Res1} to a boolean result code. On success, {\tt dp\_Res1} shall be
set to {\tt DOSTRUE} and {\tt dp\_Res2} shall be set to~0. On error,
{\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an error
code.

\section{Packets for Starting and Canceling Notification Requests}

The packets in this section implement notification requests. Once a
notification request has been registered, the file system informs a task
through a signal or through a message send to a port. Notification requests
are explained in section~\ref{sec:notification}.

\subsection{Registering a Notification Request}

The {\tt ACTION\_ADD\_NOTIFY}\mkey{ACTION\_ADD\_NOTIFY} packet registers a
notification request at a file system.

\begin{rkrmtable}{\tt ACTION\_ADD\_NOTIFY} \label{table:actionaddnotify}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_ADD\_NOTIFY (4097) \\ \hline
\tt dp\_Arg1  & APTR to {\tt NotifyRequest} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt StartNotify()}\key{StartNotify()} function
of the \emph{dos.library}, registering a request at a \emph{file system} to
get informed on changes within the file system.
\smallskip{}

{\tt dp\_Arg1} is a C pointer\footnote{In~\cite{Bantam} this argument is
  documented to be a BPTR, though this information incorrect.} to a {\tt
  NotifyRequest} structure that defines the object to be monitored, and the
task, signal or message port to be triggered on such changes. This structure
is specified in section~\ref{sec:startnotify}.
\smallskip{}

The {\tt nr\_FullName} element of the {\tt NotifyRequest} structure is
already filled by an absolute path to the object to be monitored which may
or may not yet exist. This path is filled in by the \emph{dos.library}
within the {\tt StartNotify()} function from the {\tt nr\_Name} element and
the current directory of the calling process, and the \emph{file system} may
depend on this path.
\smallskip{}

The \emph{file system} should store this request in its internal
structures, and then monitor the object identified by {\tt nr\_FullName} for
changes. The following table lists the packets which shall or may trigger a
notification request upon a monitored object:

\begin{rkrmtable}{Packets triggering a Notification}
{\bf Packet}   & {\bf Notes}\\ \hline \hline
\tt ACTION\_WRITE\key{ACTION\_WRITE} & After closing the file with {\tt ACTION\_END} \\ \hline
\tt ACTION\_SET\_FILE\_SIZE\key{ACTION\_SET\_FILE\_SIZE} & After closing the
file with {\tt ACTION\_END} \\ \hline
\tt ACTION\_FINDOUTPUT\key{ACTION\_FINDOUTPUT} & After closing the file with
    {\tt ACTION\_END} \\ \hline \hline
\tt ACTION\_DELETE\_OBJECT\key{ACTION\_DELETE\_OBJECT} & Immediately \\ \hline
\tt ACTION\_SET\_DATE\key{ACTION\_SET\_DATE} & Immediately \\ \hline
\tt ACTION\_RENAME\key{ACTION\_RENAME} & Immediately \\ \hline \hline
\tt ACTION\_SET\_COMMENT\key{ACTION\_SET\_COMMENT} & Optionally \\ \hline
\tt ACTION\_SET\_PROTECT\key{ACTION\_SET\_PROTECT} & Optionally \\ \hline
\tt ACTION\_SET\_OWNER\key{ACTION\_SET\_OWNER} & Optionally \\ \hline
\end{rkrmtable}

If the {\tt NRF\_NOTIFY\_INITIAL} flag is set in {\tt nr\_Flags}, the
\emph{file system} shall send a notification immediately after receiving
this packet, regardless of whether or not the object has been modified
already. If {\tt NRF\_WAIT\_REPLY} is set, and a {\tt NotifyMessage} has
already been send out, it shall rather note the modification, though defer
any further notification on the same object until the former {\tt
  NotifyMessage} has been replied. This avoids queuing up too many
notifications at the client port.
\smallskip{}

A notification event is either signalled through {\tt Signal()} or by
sending a message to a {\tt MsgPort}:
\smallskip{}

If {\tt NRF\_SEND\_MESSAGE} is set in {\tt nr\_Flags}, then a {\tt
  NotifyMessage} is send to the port indicated in {\tt
  nr\_Msg.nr\_Port}. This structure is also specified in
section~\ref{sec:startnotify}. Its {\tt nm\_Class} element shall be set to
{\tt NOTIFY\_CLASS}, and its {\tt nm\_Code} element to {\tt NOTIFY\_CODE},
both are defined in {\tt dos/notify.h}. In addition, {\tt nm\_NReq} shall
point to the {\tt NotifyRequest} structure through which the object is
monitored. The elements {\tt nm\_DoNotTouch} and {\tt nm\_DoNotTouch2} may
be used for internal administration of the \emph{file system}.
\smallskip{}

If {\tt NRF\_SEND\_SIGNAL} is set, then the \emph{file system} should
trigger a signal bit on the target task if the monitored object changes by
\begin{verbatim}
    Signal(nr->nr_Signal.nr_Task,1UL<<nr->nr_Signal.nr_SignalNum);
\end{verbatim}
For this method, {\tt NRF\_WAIT\_REPLY} is, of course, non-functional.
\medskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Canceling a Notification Request}

The {\tt ACTION\_REMOVE\_NOTIFY}\mkey{ACTION\_REMOVE\_NOTIFY} packet cancels
a notification request and aborts monitoring the object in the {\tt
  NotifyRequest} structure.

\begin{rkrmtable}{\tt ACTION\_REMOVE\_NOTIFY} \label{table:actionremovenotify}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_REMOVE\_NOTIFY (4097) \\ \hline
\tt dp\_Arg1  & APTR to {\tt NotifyRequest} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt EndNotify()}\key{EndNotify()} function of
the \emph{dos.library} and terminates monitoring the object in {\tt
  nr\_FullName} element of the {\tt NotifyRequest} structure.
\smallskip{}

{\tt nr\_Arg1} is a C-pointer to the structure that indicates which
notification request shall be canceled. The {\tt NotifyRequest} structure is
specified in section~\ref{sec:startnotify}.
\smallskip{}

If any notifications are still pending, e.g. because the monitored object
has already been changed through a file handle though this file handle has
not yet been closed, such pending notifications shall be canceled as
well. The \emph{file system} shall be aware that even after this packet has
been replied, some {\tt NotifyMessage}s send out to clients may come back
because the client is still working on them. In particular, the memory
associated to such messages shall not be released upon receiving the {\tt
  ACTION\_REMOVE\_NOTIFY} packet, but only after the {\tt NotifyMessage} has
been replied and was received again by the \emph{file system}. The
\emph{dos.library} replies all {\tt NotifyMessage}s it finds
still pending in the port of the client application, but clearly cannot
handle those messages that are still being processed.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\section{Packets Operating on Entire Volumes}

The packets in this section impact the volume mounted on a \emph{file
system} in total and do not interact with individual objects, such as files,
directories or links on it.

\subsection{Determining the Currently Inserted Volume}

The packet {\tt ACTION\_CURRENT\_VOLUME}\mkey{ACTION\_CURRENT\_VOLUME}
determines from a \emph{FileHandle} a BPTR to the {\tt DosList}
structure representing the volume on which the file is located.

\begin{rkrmtable}{\tt ACTION\_CURRENT\_VOLUME} \label{table:actioncurrentvolume}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_CURRENT\_VOLUME (7) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} or {\tt ZERO} \\ \hline \hline
\tt dp\_Res1  & BPTR to {\tt DosList} structure\\ \hline
\tt dp\_Res2  & 0 \\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, but it used by it when
constructing an error requester through its {\tt ErrorReport()}
\key{ErrorReport()} function.  If an error is generated by a function taking
a \emph{FileHandle} as argument, this function is used to determine the {\tt
  DosList} entry representing the volume. From there, the name is copied
into the requester, for example to ask the user to insert it.
\smallskip{}

{\tt dp\_Arg1} shall be filled with a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure, or shall be {\tt ZERO}. If a handle is
provided, a BPTR to the {\tt DosList} of the volume the handle is located on
shall be provided in {\tt dp\_Res1}. In such case, the packet is safe as the
volume entry cannot go away as long as the lock implicit to the handle
uses it\footnote{In~\cite{Bantam}, {\tt dp\_Arg1} is not mentioned,
though providing it is important to avoid a race condition. The RAM-Handler
is probably an exception as it only maintains a single volume that cannot go
away during its lifetime.}.
\smallskip{}

If {\tt dp\_Arg1} is {\tt ZERO}, a BPTR to the {\tt DosList} of the
currently inserted volume, or {\tt ZERO} if no volume is inserted, shall be
returned. Unfortunately, as the volume may be ejected any time, it is
unclear whether the {\tt DosList} entry provided in {\tt dp\_Res1} is still
valid at the time it is interpreted by the issuer of of this packet. In such
a case, the issuer of the packet should lock the \emph{device list} upfront,
and should copy the name before the list is unlocked again, i.e.

\begin{verbatim}
char name[256];
struct DosList *dl;

  LockDosList(LDF_VOLUMES|LDF_READ);
  dl = (struct DosList *)BADDR(DoPkt0(port,ACTION_CURRENT_VOLUME));
  if (dl) {
    /* dol_Name is always a 0-terminated BSTR */
    strncpy(name,dl->dol_Name + 1,sizeof(name));
    name[sizeof(name)-1] = 0;
  } else name[0] = 0;
  UnLockDosList(LDF_VOLUMES|LDF_READ);
\end{verbatim}

The \emph{file system} shall set {\tt dp\_Res1} to a BPTR to the {\tt
  DosList} entry representing a volume, i.e. an entry on the device
list\key{Device list} whose {\tt dol\_Type} is {\tt DLT\_VOLUME} and whose
{\tt dol\_Task} points to a {\tt MsgPort} of this \emph{handler}. In case no
volume is inserted, {\tt dp\_Res1} shall be set to {\tt ZERO}. This packet
shall not fail, and {\tt dp\_Res2} is ignored by the \emph{dos.library}. For
practical purposes, {\tt dp\_Res2} shall be set to~0 indicating that no error has been
detected.

\subsection{Retrieving Information on a Volume from a Lock}

The {\tt ACTION\_INFO}\mkey{ACTION\_INFO} packet retrieves information on a
volume, given a lock on an object on the volume, and provides it in an
{\tt InfoData} structure.

\begin{rkrmtable}{\tt ACTION\_INFO} \label{table:actioninfo}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_INFO (26) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt FileLock} \\ \hline
\tt dp\_Arg2  & BPTR to {\tt InfoData} \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt Info()}\key{Info()} function of the
\emph{dos.library} and provides information on the volume on which the
locked object is located.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to a lock, used to identify a volume from which
information is to be requested. If the volume is not inserted, not validated
or the lock is invalid, this packet will fail.
\smallskip{}

{\tt dp\_Arg2} is a BPTR to an {\tt InfoData} structure as defined in
section~\ref{sec:info} into which information is provided such as the state
of the volume, the number of errors detected on it, its capacity and the
number of free blocks. Details on this structure are found in
section~\ref{sec:info}.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator that includes the result of the validity test of the lock. If the
lock is valid and information on the volume could be retrieved, {\tt
  dp\_Res1} shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall be set
to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt
  dp\_Res2} to an error code.

\subsection{Retrieving Information on the Currently Inserted Volume} \label{sec:packetdiskinfo}

The {\tt ACTION\_DISK\_INFO}\mkey{ACTION\_DISK\_INFO} packet retrieves
information on the volume currently mounted by the \emph{file system} (if
any) and provides this information in an {\tt InfoData} structure.

\begin{rkrmtable}{\tt ACTION\_DISK\_INFO} \label{table:actiondiskinfo}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_DISK\_INFO (25) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt InfoData} \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is currently not exposed by the \emph{dos.library} and must be
issued through the packet interface. It is almost identical to {\tt
  ACTION\_INFO}\key{ACTION\_INFO}, except that it does not take a lock as
argument. Therefore, it always refers to the currently inserted volume, and
not to the volume the locked object is located on. Otherwise, the
information provided by this packet and {\tt ACTION\_INFO} is identical.
\smallskip{}

This packet is also used to retrieve console specific information from the
Con-Handler, and is documented as such again in
section~\ref{sec:console}. The elements of the {\tt InfoData} are then
interpreted in an alternative way.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to an {\tt InfoData} structure as defined in
section~\ref{sec:info} into which information is provided such as the state
of the currently inserted volume, the number of errors detected on it, its
capacity and the number of free blocks. Details on this structure are found
in section~\ref{sec:info}.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Relabeling a Volume}

The {\tt ACTION\_RENAME\_DISK}\mkey{ACTION\_RENAME\_DISK} packet changes the
volume name of a medium.

\begin{rkrmtable}{\tt ACTION\_RENAME\_DISK} \label{table:actionrenamedisk}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_RENAME\_DISK (9) \\ \hline
\tt dp\_Arg1  & BPTR to BSTR of new volume name \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt Relabel()}\key{Relabel()} function of the
\emph{dos.library} and changes the volume name of a medium. As such, it
shall also change the name of the {\tt DosList} representing the volume in
the \emph{device list}, i.e. adjust the {\tt dol\_Name} element of the {\tt
  DosList} structure. Unfortunately, there is no guarantee that the volume
that is inserted in the drive or partition managed by the file system when
this packet is issued by the client is identical to the volume in the drive
when the file system receives it.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to a BSTR of the new volume name. Relabeling shall
be applied on the currently inserted volume.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Initializing a New File System} \label{sec:actionformat}

The {\tt ACTION\_FORMAT}\mkey{ACTION\_FORMAT} packet initializes a new file
system on a disk, writing all administration information on it represting a
blank volume. It therefore deletes all information stored previously on the
medium, drive or partition.

\begin{rkrmtable}{\tt ACTION\_FORMAT} \label{table:actionformat}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FORMAT (1020) \\ \hline
\tt dp\_Arg1  & BPTR to BSTR of new volume name \\ \hline
\tt dp\_Arg2  & Dos type or other private data \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt Format()}\key{Format()} function of the
\emph{dos.library}. It performs a soft-initialization of the drive, medium
or partition currently inserted into the drive. Note, however, that it does
not perform a low-level formatting, such as creating sectors on a floppy
disk or issuing a low-level SCSI command. If this is intended, it must be
performed by a client application, e.g. the {\tt Format} command of the
workbench disk. This packet only writes administrative information on a
volume representing it in empty state. This packet is probably the only one
that should be used while a \emph{file system} is inhibited and would usually
refuse to alter any information on disk, see also
section~\ref{sec:packetinhibit}.
\smallskip{}

{\tt dp\_Arg1} is a BPTR to a BSTR of the volume name the medium, partition
or drive shall be given\footnote{The information in~\cite{Bantam} that the
new volume name is in {\tt dp\_Arg2} and the {\tt DosType} is in {\tt
  dp\_Arg3} is incorrect.}. Typically, this packet will be
issued while the drive is inhibited, and thus the {\tt DosList} structure
representing the volume will be created or updated at the time the \emph{file
system} is unhibited. Otherwise, if the handler also allows an {\tt
  ACTION\_FORMAT} while not being inhibited, it should update the {\tt
  DosList} immediately, in particular its {\tt dol\_Name}, to the name given
by this argument.
\smallskip{}

{\tt dp\_Arg2} is \emph{file system} specific information that may be used
to define its flavour. For example, {\tt dp\_Arg2} carries for the FFS the
{\tt DosType}, which shall be one of the values documented in
table~\ref{table:ffsflavours} in section~\ref{sec:envec}. If such a change
of the {\tt DosType} also happens, and the handler allows formatting while
not being inhibited, the {de\_DosType} in the environment vector linked
through {\tt dol\_Dostype} shall be updated as well. Otherwise, this update
will happen when the \emph{file system} is uninhibited. The {\tt Format()}
function will take {\tt dp\_Arg2} from its third argument.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Make a Copied Disk Unique}

The {\tt ACTION\_SERIALIZE\_DISK}\mkey{ACTION\_SERIALIZE\_DISK} packet
serializes a disk, that is, ensures that the disk is unique and
distinguishable from other media available to the system.

\begin{rkrmtable}{\tt ACTION\_SERIALIZE\_DISK} \label{table:actionserializedisk}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SERIALIZE\_DISK (4200) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}. The packet interface
e.g. {\tt DoPkt()}\key{DoPkt()}, needs to be used to issue it. The purpose
of this packet is to ensure that the volume inserted in a drive is unique
and distinguishable from other volumes. Along with {\tt
  ACTION\_FORMAT}\key{ACTION\_FORMAT}, this packet should be issued while
the file system is inhibited, see sections~\ref{sec:inhibit}
and~\ref{sec:packetinhibit}.
\smallskip{}

This packet does not take any arguments, it affects the currently inserted
volume. The FFS implements this packet by setting the volume creation date to the
system date; other file systems can include volume IDs or other means to
uniquely label disks. The {\tt DiskCopy} command of the workbench uses this
packet after performing its job to ensure that the copy of a disk is
distinguishable from its original.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Write Protecting a Volume} \label{sec:packetlock}

The {\tt ACTION\_WRITE\_PROTECT}\mkey{ACTION\_WRITE\_PROTECT} packet enables or
disables a software write-protection on the currently inserted medium, thus
disallowing any write access through the file system on it.

\begin{rkrmtable}{\tt ACTION\_WRITE\_PROTECT} \label{table:actionwriteprotect}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_WRITE\_PROTECT (1023) \\ \hline
\tt dp\_Arg1  & Write protection flag \\ \hline
\tt dp\_Arg2  & Password hash \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by any function of the \emph{dos.library}, though
the {\tt Lock} command of the workbench uses it to enable or
disable write protection on media. Optionally, write protection may be
secured by a password of which only an integer hash key is provided to the
file system. To re-enable write access, the file system shall check whether
the password hash supplied matches the one when setting the write
protection, and shall refuse to unblock it if the password hash keys do not
match. How a password hash is computed is irrelevant to the file system, it
only checks the keys for enabling and disabling the write protection for
equality.
\smallskip{}

{\tt dp\_Arg1} is a boolean indicator that, if non-zero, enables write
protection, and if {\tt DOSFALSE} releases it. Any attempt to write data to
the protected medium, device or partition shall fail with the error code
{\tt ERROR\_DISK\_WRITE\_PROTECTED}, including an attempt to set a write
protection on an already write protected file system, regardless of the
password key used for re-protection.
\smallskip{}

{\tt dp\_Arg2} is an integer password hash key that is stored internally in
the file system when the write protection is set, and compared against if it
is to be released again. If the stored password hash is not equal to the
original hash, attempting to release the protection shall fail with
{\tt ERROR\_INVALID\_COMPONENT\_NAME}.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\section{Packets for Interactive Handlers} \label{sec:packetsinteractive}

The packet types documented in this section are specific for handlers that
interact with the environment of the computer system. Examples for
interactive handlers are the Con-Handler interacting with the user through a
window, the Aux-Handler which makes a console available through the serial
port, and the Port-Handler which reads and writes data through the serial
or parallel port and also makes the printer accessible to AmigaDOS.

\subsection{Waiting for Input Becoming Available}

The packet {\tt ACTION\_WAIT\_CHAR}\mkey{ACTION\_WAIT\_CHAR} waits for
characters becoming available on an interactive \emph{handler}.

\begin{rkrmtable}{\tt ACTION\_WAIT\_CHAR} \label{table:actionwaitchar}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_WAIT\_CHAR (20) \\ \hline
\tt dp\_Arg1  & Timeout in ticks \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt WaitForChar()}\key{WaitForChair()} function
of the \emph{dos.library}. As such, it checks whether (interactive) input is
available to satisfy a potential {\tt Read()}. Note that this packet does
not receive an indicator of a file handle, thus even if input is available,
it is not specified which {\tt ACTION\_READ} packet will receive the
available data.
\smallskip{}

{\tt dp\_Arg1} provides the timeout in ticks, where a tick is~20ms long, see
also section~\ref{sec:dates}.
\smallskip{}

This packet instructs the handler to wait at most {\tt dp\_Arg1} ticks. If
no input becomes available within this time period, {\tt dp\_Res1} shall be
set to {\tt DOSFALSE} and {\tt dp\_Res2} to~0.
\smallskip{}

If at least a single character of input becomes available, {\tt dp\_Res1}
shall be set to {\tt DOSTRUE}. If the handler implements line buffering such
as the Con-Handler, then {\tt dp\_Res2} shall be set to the number of lines
available in the output buffer. This feature is, for example, used by the
ARexx interpreter. If it does not implement line buffering, {\tt dp\_Res2}
should be set to~0.
\smallskip{}

In case of an error, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Setting the Line Buffer Mode}

The {\tt ACTION\_SCREEN\_MODE}\mkey{ACTION\_SCREEN\_MODE} packet changes the
buffer mode of an interactive console and disables or enables line
buffering.

\begin{rkrmtable}{\tt ACTION\_SCREEN\_MODE} \label{table:actionscreenmode}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SCREEN\_MODE (994) \\ \hline
\tt dp\_Arg1  & Buffer mode \\ \hline \hline
\tt dp\_Res1  & Boolean result code \\ \hline
\tt dp\_Res2  & Error code \\ \hline
\end{rkrmtable}

This packet implements the {\tt SetMode()} function of the
\emph{dos.library}. {\tt dp\_Arg1} is a copy of the second argument of this
function.
\smallskip{}

The purpose of this packet is to adjust the buffer mode of a console. The
CON-Handler, responsible for all types of consoles, serves both the {\tt
  CON:}, the {\tt RAW:} and (through an indirection layer) the {\tt AUX:}
device, all of which are incarnations of the same handler configured
differently; the CON-Handler described in section~\ref{sec:console}.
\smallskip{}

In particular, {\tt CON:} and {\tt RAW:} interact with the user through a
window of the graphical user interface; they are just two modes of the in
total three modes of the console. With this packet, a {\tt CON:} window can
be converted into a {\tt RAW:} window and vice-versa, and into a third type
of window for which no distinct device name exists.
\smallskip{}

The same type of mode switch can also be performed for the serial terminal
represented by the {\tt AUX:} window, which also exists in three modes in
total, though usually only one of them is exposed to the user as {\tt AUX:}
device. This packet makes two additional configurations available.
\medskip{}

{\tt dp\_Arg1} defines the mode into which the console shall be switched. In
total three modes are available, regardless whether the console is a
graphical console in a window or a serial console on an external
terminal. The modes are defined in table~\ref{table:conmodes} in
section~\ref{sec:setmode}.
\smallskip{}

Only values between 0 and 2 shall be provided in {\tt dp\_Arg1}; all other
values are reserved for future use and may or may not correspond to modes
that are currently not documented. The console does not generate an error if
an invalid mode is requested, but may interpret this mode change request in
an unexpected way.
\smallskip{}

Before replying this packet, the console shall set {\tt dp\_Res1} to {\tt
  DOSTRUE} and {\tt dp\_Res2} to~0 in case the mode switch could be
performed. Otherwise, if the mode switch is not possible, the console shall
set {\tt dp\_Res1} to {\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\subsection{Retrieving IORequest and the Window Pointer from the Console} \label{sec:diskinfoconsole}

The {\tt ACTION\_DISK\_INFO}\key{ACION\_DISK\_INFO} packet retrieves from a
console pointers to its underlying resources.

\begin{rkrmtable}{\tt ACTION\_DISK\_INFO}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_DISK\_INFO (25) \\ \hline
\tt dp\_Arg1  & BPTR to {\tt InfoData} \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}; it is the same packet
as the one introduced in section~\ref{sec:packetdiskinfo} and takes the same
parameters.  However, when applied to consoles, it returns additional
information and is thus discussed here again.
\smallskip{}

The {\tt id\_DiskType} element of the {\tt InfoData} structure (see
section~\ref{sec:info}) pointed to by {\tt dp\_Arg1} provides information on
the mode the console is in:

\begin{rkrmtable}{\tt id\_DiskType}
{\bf Value of {\tt \bf id\_DiskType}} & {\bf Console Mode}\\ \hline \hline
{\tt 'CON\textbackslash0'} & Cooked or medium mode \\ \hline
{\tt 'RAW\textbackslash0'} & Raw mode \\ \hline
\end{rkrmtable}

Section~\ref{sec:console} provides more information on console modes; they
describe whether the console buffers entire lines and which key presses are
reported how.
\smallskip{}

The {\tt id\_VolumeNode} element of the {\tt InfoData} structure provided in
{\tt dp\_Arg1} is filled with a pointer to the intuition window the console
runs in. For a serial console, or a console running on any other device,
this element remains {\tt NULL}.
\smallskip{}

The {\tt id\_InUse} element is filled with a pointer to the {\tt IoRequest}
structure (see {\tt exec/io.h}) which is used to communicate with the device
the handler operates on. For a graphical console, this is a {\tt IORequest}
to the {\tt console.device}; for the {\tt AUX:} console, it is an {\tt
  IORequest} to the corresponding device the console runs on, e.g. of
the {\tt serial.device}. Other devices are also possible.
\medskip{}

Even though this packet provides useful information to the caller, it has
several drawbacks and its usage is discouraged. First, as it potentially
provides information on the intuition window, a window opened in {\tt AUTO}
mode cannot be closed anymore, and neither can be iconified. This is because
both operations would invalidate the window pointer provided by this packet.
\smallskip{}

Applications should inform the console by sending an {\tt
  ACTION\_UNDISK\_INFO} packet at the time the window pointer or the {\tt
  IORequest} is no longer required. Console windows then regain the {\tt
  AUTO} and iconification capabilities. {\tt ACTION\_UNDISK\_INFO} is specified in
section~\ref{sec:packetundiskinfo}.
\smallskip{}

Second, {\tt ACTION\_DISK\_INFO} will not provide a window if the
console is not running in an intuition window, but remotely over a serial
line or any other device. The {\tt IORequest} pointer then corresponds to
the target device over which the console communicates with the user, and not
the {\tt console.device}.
\medskip{}

Often, applications (mis-)use this packet to retrieve the current cursor
position or the dimensions of the window in character positions, assuming
that the {\tt IORequest} pointer in {\tt id\_InUse} is, actually,
corresponding to a {\tt console.device} and as such {\tt io\_Unit} of the
request is a pointer to a {\tt ConUnit}. However, this assumption may not be
true, and console dimensions and the cursor position cannot be obtained in
general in this way.
\smallskip{}

The following algorithm provides an alternative by switching the console to
{\tt RAW} mode, and requesting the required information through CSI
sequences. These sequences operate independent of the device and only
require that the local or remote console implements a VT-100 compatible
interface.
\smallskip{}

\begin{verbatim}
/* Retrieve the window dimensions in characters
** from a console connected to a file handle "file"
*/
void WindowSize(BPTR file,LONG *width,LONG *height)
{
  if (!ParsePosition(file,'r',width,height)) {
    /* Provide a standard console size in
    ** case of failure.
    */
    if (width)
      *width = 80;
    if (height)
      *height = 24;
  }
}

/* Retrieve the cursor position from a console
** connected to a file handle "file"
*/
void CursorPosition(LONG *x,LONG *y)
{
  ParsePosition(stdOut,'R',x,y);
}

/*
** Maximum time to wait for the console
** to respond in ticks. May require 
** adjustment on slow connections.
*/
#define MAX_DELAY       200000

/* Generic CSI sequence parser for a VT-xxx
** console. Returns TRUE if the sequence could
** be parsed.
*/
BOOL ParsePosition(BPTR file,char answer,LONG *width,LONG *height)
{
BOOL success;
BOOL incsi,innum,negative,inesc;
LONG counter;
LONG args[5];
UBYTE in;

  memset(args,0,sizeof(args));
  SetMode(file,1);

  success  = TRUE;
  incsi    = FALSE;
  inesc    = FALSE;
  innum    = FALSE;
  negative = FALSE;
  counter  = 0;

  /* Now send a window borders request to the stream */
  if (answer == 'R') {
    Write(file,"\033[6n",4);
  } else {
    Write(file,"\033[0 q",5);
  }

  /* Now parse an incoming string */
  for(;;) {
    if (WaitForChar(file,MAX_DELAY) == FALSE) {
      success = FALSE;
      break;
    }

    if (Read(file,&in,1) != 1) {
      success = FALSE;
      break;
    }

    if (incsi) {
      if ((in<' ') || (in>'~')) { /* Invalid sequence? */
        incsi = FALSE;
      } else if ((in>='0') && (in<='9')) {
        /* Valid number? */
        if (innum == FALSE) {
          innum = TRUE;
          args[counter] = 0;
        }
        args[counter] = args[counter]*10+in-'0';
      } else {
        /* Abort parsing the number. Install its sign */
        if (innum) {
          if (negative)
            args[counter] = -args[counter];
          innum    = FALSE;
          negative = FALSE;
        }
        if ((in>='@') && (in<='~')) { /* End of sequence? */
          /* Is it a bounds report? */
          if ((in=='r') && (answer=='r') && (counter==3)) {
            if (height)
              *height = args[2]-args[0]+1;
            if (width)
              *width  = args[3]-args[1]+1;
            break;
          }
          /* Is it a cursor report? */
          if ((in=='R') && (answer=='R') && (counter==1)) {       
            if (height)
              *height = args[0];
            if (width)
              *width  = args[1];
            break;
          }
          incsi = FALSE; /* Abort sequence */
        } else if (in==';') { /* Argument separator? */
          counter++;
          /* Do not parse more than 5 arguments, 
          ** throw everything else away 
          */
          if (counter>4) counter=4;
          innum    = FALSE;
          negative = FALSE;
        } else if (in=='-') {
          if (innum)
            incsi = FALSE;  /* minus sign in the middle is invalid */
          negative = ~negative;
        } else if (in==' ') {
          /* Ignore SPC prefix */
        } else {
          /* Abort the sequence */
          incsi = FALSE;
        }
      }
    } else if (inesc) {
      if (in == '[') {
        inesc    = FALSE;
        incsi    = TRUE;   /* found a CSI sequence */
        innum    = FALSE;  /* but not yet a valid number */
        negative = FALSE;
        counter  = 0;
        args[0]  = args[1]=args[2]=args[3]=args[4] = 1;
      } else if ((in >= ' ') && (in <= '/')) {
        /* ignore the ESC sequence contents */
      } else {
        inesc    = FALSE;  /* terminate the ESC sequence */
      }
    } else if (in == 0x9B) {
      incsi    = TRUE;   /* found a CSI sequence */
      innum    = FALSE;  /* but not yet a valid number */
      negative = FALSE;
      counter  = 0;
      args[0]  = args[1]=args[2]=args[3]=args[4] = 1;
    } else if (in == 0x1B) {
      inesc    = TRUE;  /* found an ESC sequence */
    } /* Everything else is thrown away */
  }

  SetMode(file,0);
  return success;
}
\end{verbatim}
The above algorithm supports both 7-bit and 8-bit consoles and is aware of
the 7-bit two-character equivalent of CSI.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Releasing Console Resources} \label{sec:packetundiskinfo}

The {\tt ACTION\_UNDISK\_INFO}\mkey{ACTION\_UNDISK\_INFO} packet releases
any resources obtained by {\tt ACTION\_DISK\_INFO}\key{ACTION\_DISK\_INFO}.

\begin{rkrmtable}{\tt ACTION\_UNDISK\_INFO}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_UNDISK\_INFO (513) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, the packet needs to be
issued through the {\tt DoPkt()}\key{DoPkt()} function.
\smallskip{}

The purpose of this packet is to let the console know that the pointers to
the window and the {\tt IORequest} provided by
{\tt ACTION\_DISK\_INFO}\key{ACTION\_DISK\_INFO} are no longer needed and
the console may close the window or release the {\tt IORequest} if
needed. This has the the practical consequence that {\tt AUTO} windows can
be closed again, and the console can also be iconified again.
\smallskip{}

To implement this packet, the console should keep a counter to track the
number of times its resources have been provided to clients. An {\tt
  ACTION\_DISK\_INFO} increments it, and {\tt
  ACTION\_UNDISK\_INFO} decrements it. As long as the counter is non-zero,
the window shall be open and the connection to the device implementing the
console functionality shall be established. This includes that the window
needs to be forced open on the first {\tt ACTION\_DISK\_INFO} if it is
closed, either by iconification or because it is an {\tt AUTO} window that
was closed by the user.
\medskip{}

This packet does not take any arguments. Even though there is practically no
reason why this packet could fail, the console handler shall set {\tt
  dp\_Res1} to {\tt DOSTRUE} and {\tt dp\_Res2} to~0 on success. On an
error, if such an error should be possible, {\tt dp\_Res1} shall be set to
{\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\subsection{Stack a Line at the Top of the Output Buffer}

The {\tt ACTION\_STACK}\mkey{ACTION\_STACK} packet injects a line at the
start of the output buffer of the console.

\begin{rkrmtable}{\tt ACTION\_STACK}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_STACK (2002) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & APTR to characters \\ \hline
\tt dp\_Arg3  & Size of the buffer in bytes \\ \hline \hline
\tt dp\_Res1  & Number of characters stacked\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, it rather needs to be
issued through the packet interface, e.g. {\tt DoPkt()}\key{DoPkt()}. This packet injects
a line at the end of the output buffer of the console. This buffer keeps all
lines entered by the user, and lines injected by {\tt ACTION\_STACK} and
{\tt ACTION\_QUEUE}. The number of lines in this output buffer can be
obtained through {\tt ACTION\_WAIT\_CHAR} which delivers the line count in
{\tt dp\_Res2}.
\smallskip{}

Lines from this buffer are provided to clients on {\tt ACTION\_READ}\key{ACTION\_READ}
packets that empty this buffer line by line. Thus, a line provided through this packet
will be delivered to the next reading client, before any other buffered
lines, but after user input.
\smallskip{}

Lines injected into the console output buffer are not echoed on the
screen. Arexx uses this packet to employ the console as ``external
stack''. This packet places a line at the top of this stack.
\medskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure interfacing to the console.
\smallskip{}

{\tt dp\_Arg2} is a C pointer (not a BPTR) to an array of characters
to be injected into the output buffer of the console.
\smallskip{}

{\tt dp\_Arg3} is the size of the buffer in characters.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to the number of
characters that could be stacked in the output buffer of the console, or
to~$-1$ in case of failure. On success, {\tt dp\_Res2} shall be set to~0, or
to an error code on failure.

\subsection{Queue a Line at the End of the Output Buffer}

The {\tt ACTION\_QUEUE}\mkey{ACTION\_QUEUE} packet injects a line at the end
of the output buffer of the console.

\begin{rkrmtable}{\tt ACTION\_QUEUE}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_QUEUE (2003) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & APTR to characters \\ \hline
\tt dp\_Arg3  & Size of the buffer in bytes \\ \hline \hline
\tt dp\_Res1  & Number of characters stacked\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, it rather needs to be
issued through the packet interface, e.g. {\tt DoPkt()}\key{DoPkt()}. This packet injects
a line at the end of the output buffer of the console. This buffer keeps all
lines entered by the user, and lines injected by {\tt ACTION\_STACK} and
{\tt ACTION\_QUEUE}. The number of lines in this output buffer can be
obtained through {\tt ACTION\_WAIT\_CHAR} which delivers the line count in
{\tt dp\_Res2}.
\smallskip{}

Lines from this buffer are provided to clients on {\tt
  ACTION\_READ}\key{ACTION\_READ} packets that empty this buffer line by
line. Thus, a line provided through this packet will be delivered to a
reading client after all other buffered lines have been read from the
console, including user input.
\smallskip{}

Lines injected into the console output buffer are not echoed on the screen.
ARexx uses this packet to employ the console as ``external stack''. This
packet places a line at the end of this stack, i.e. queues them up.
\medskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure interfacing to the console.
\smallskip{}

{\tt dp\_Arg2} is a C pointer (not a BPTR) to an array of characters
to be injected into the output buffer of the console.
\smallskip{}

{\tt dp\_Arg3} is the size of the buffer in characters.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to the number of
characters that could be stacked in the output buffer of the console, or
to~$-1$ in case of failure. On success, {\tt dp\_Res2} shall be set to~0, or
to an error code on failure.

\subsection{Force Characters into the Input Buffer} \label{sec:actionforce}

The {\tt ACTION\_FORCE}\mkey{ACTION\_FORCE} packet injects characters into
the keyboard input buffer of the console, as if the user typed them.

\begin{rkrmtable}{\tt ACTION\_FORCE}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_QUEUE (2001) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & APTR to characters \\ \hline
\tt dp\_Arg3  & Size of the buffer in bytes \\ \hline \hline
\tt dp\_Res1  & Number of characters stacked\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, it rather needs to be
issued through the packet interface, e.g. {\tt DoPkt()}\key{DoPkt()}. This packet injects
characters into the input buffer of the console, at the same place
keystrokes are recorded. Such characters are echoed on the console, or
executed in case of control sequences. E.g, this packet allows also to move
the cursor left or right, or erase the current line by emulating the
corresponding keystrokes.
\smallskip{}

Note that the keyboard input buffer is different from the line output
buffer; lines entering the console through {\tt ACTION\_FORCE} qualify as
keyboard input\footnote{Even though the V40 CON-Handler already supported
this packet, it is there implemented incorrectly and does not impact the
keyboard buffer. This was fixed in V47.}. The main user of this packet is
the Shell which injects TAB-expanded file names into the console. The
{\tt ConClip} command also uses this packet to insert the paths of icons
dropped on the console.
\medskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure interfacing to the console.
\smallskip{}

{\tt dp\_Arg2} is a C pointer (not a BPTR) to an array of characters
to be injected into the output buffer of the console.
\smallskip{}

{\tt dp\_Arg3} is the size of the buffer in characters.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to the number of
characters that could be injected into the keyboard input buffer of the
console, or to~$-1$ in case of failure. On success, {\tt dp\_Res2} shall be
set to~0, or to an error code on failure.

\subsection{Drop all Stacked and Queued Lines in the Output Buffer}

The {\tt ACTION\_DROP}\mkey{ACTION\_DROP} packet disposes all lines that
have been injected into the output buffer and thus reverts any {\tt
  ACTION\_STACK} and {\tt ACTION\_QUEUE} packets.

\begin{rkrmtable}{\tt ACTION\_DROP}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_DROP (2004) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & 0 \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}, it rather needs to be
issued through the packet interface, e.g. {\tt DoPkt()}\key{DoPkt()}. This packet removes
any lines injected by {\tt ACTION\_STACK} and {\tt ACTION\_QUEUE} from
the output buffer of the console and thus reverts their results. User
keyboard inputs remain unaffected. Thus, this packet resets the line stack
in the console. The intended purpose this packet is ARexx which,
however, at the time of writing does not use it.
\smallskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure interfacing to the console.
\smallskip{}

{\tt dp\_Arg2} shall be~0. This element is reserved for future use as a
priority and shall be zero-initialized for forewards compatibility.

Upon replying this packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and
{\tt dp\_Res2} to~0 on success. On error, {\tt dp\_Res1} shall be set to
{\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\subsection{Bring the Console Window to the Foreground}

The {\tt ACTION\_SHOWWINDOW}\mkey{ACTION\_SHOWWINDOW} activates the console
window, if it is open, and brings it to the foreground.

\begin{rkrmtable}{\tt ACTION\_SHOWWINDOW}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_SHOWWINDOW (506) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}. The packet interface,
e.g. {\tt DoPkt()}\key{DoPkt()}, is required to issue it. This packet brings the window
associated console, should such a window exist, to foreground and activates
it. If the console is a serial console or the console window is closed or
iconified, no activity is performed and no error is reported. Unlike {\tt
  ACTION\_DISK\_INFO}, it will not force the window open if the window is
currently closed.
\smallskip{}

The primary user of this packet is the {\tt ConClip} tool
which sends this packet to make the window visible whenever an icon is
dropped on it. The path of the icon is injected into the keyboard input
buffer with {\tt ACTION\_FORCE}\key{ACTION\_FORCE}.
\smallskip{}

Upon replying this packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and
{\tt dp\_Res2} to~0 on success. On error, {\tt dp\_Res1} shall be set to
{\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\subsection{Change the Target Port to Receive BREAK signals}

The {\tt ACTION\_CHANGE\_SIGNAL}\mkey{ACTION\_CHANGE\_SIGNAL} packet sets a
{\tt MsgPort} to whose task the console sends break signals generated by
the {\tt Ctrl-C} to {\tt Ctrl-F} key combinations.

\begin{rkrmtable}{\tt ACTION\_CHANGE\_SIGNAL}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_CHANGE\_SIGNAL (995) \\ \hline
\tt dp\_Arg1  & {\tt fh\_Arg1} of a {\tt FileHandle} \\ \hline
\tt dp\_Arg2  & APTR to {\tt MsgPort} structure \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}. The packet interface,
e.g. {\tt DoPkt()}\key{DoPkt()}, is required to issue it. It defines a port to which
break signals as generated by the {\tt Ctrl-C} to {\tt Cltr-F} key
combinations are send. Actually, this \emph{break port} is not used as a
target of a message, but only its {\tt mp\_Task} element to which the signal
is send.
\smallskip{}

Despite this port, the console also sends break signals to the last process
that issued an {\tt ACTION\_WRITE} request, provided this process is not a
Shell process running in background. To avoid race conditions of
applications forgetting to reset this port, the console resets this port
whenever an {\tt ACTION\_CLOSE} is received from the \emph{break port},
i.e. whenever the process to which this port belongs closes its connection
to the console. Furthermore, the console also tests the validity of the
\emph{break port} by testing whether its {\tt mp\_Task} field is known to
the exec scheduler.
\smallskip{}

This packet is, for example, used when a Shell is started in a console
window, or a {\tt NewShell} command creates another in an already open
console window. In such a case, the {\tt System()}\key{System()} function as
part of the \emph{dos.library} sends a {\tt ACTION\_CHANGE\_SIGNAL} to the
console to ensure that break signals are received by the new Shell just
started, and not the Shell then running in the background. This packet is
\emph{not} send for executables placed by the {\tt Run} command in the
background. Even though {\tt Run} also goes through {\tt System()}, it uses
different parameters.
\medskip{}

{\tt dp\_Arg1} is a copy of the {\tt fh\_Arg1} element of
a {\tt FileHandle} structure that is opened to the console.
\smallskip{}

{\tt dp\_Arg2} is a pointer to a {\tt MsgPort} to whose task break signals
will be send. In addition to this port, the console also sends break signals to the
last issuer of an {\tt ACTION\_WRITE} packet, provided it is not a background
Shell process.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} on
success, and {\tt dp\_Res2} the port that was previously installed as
\emph{break port}, or {\tt NULL} if no such port was configured. On error,
{\tt dp\_Res1} shall be set to {\tt DOSFALSE} and {\tt dp\_Res2} to an
error code.

\section{Packets Controlling the Handler in Total}

The packets in this section impacts file systems and handlers at
global. They do not apply to a particular volume.

\subsection{Adjusting the File System Cache}

The {\tt ACTION\_MORE\_CACHE}\mkey{ACTION\_MORE\_CACHE} packet increases or
decreases the number of file system buffers.

\begin{rkrmtable}{\tt ACTION\_MORE\_CACHE} \label{table:actionmorecache}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_MORE\_CACHE (18) \\ \hline
\tt dp\_Arg1  & Buffer increment \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Buffer count or error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt AddBuffers()}\key{AddBuffers()} function of
the \emph{dos.library}. In increases or decreases the number of buffers the
file system may use to cache data. How exactly a file system uses these
buffers and how large these buffers are is specific to the file system
implementation and its configuration.
\smallskip{}

The FFS uses these buffers to temporary store administrative data such as
blocks describing the directory structure or information on which blocks a
particular file occupies on disk. Providing additional buffers (within
limits) can thus help to improve the performance of a file system by
reducting the number of times the underlying device needs to be contacted.
The FFS also uses these buffers to store payload data if the source or
destination buffer of the client is not reachable by the exec device
driver. The {\tt de\_Mask} element of the environment vector is used to
determine such incompatibilities, see section~\ref{sec:envec}.
\smallskip{}

{\tt dp\_Arg1} is the increment (or decrement, if negative) of the number of
buffers to be added (or removed) from the pool of cache buffers of the file
system. File systems may clamp this value to guarantee that a minimum number
of buffers are available, or limit the buffer count to a useful value.
\smallskip{}

If this packet succeeds, the file system shall set {\tt dp\_Res1} to {\tt
  DOSTRUE} and {\tt dp\_Res2} to the number of buffers currently
allocated. Thus, the current buffer count can obtained by sending this
packet with {\tt dp\_Arg1} set to~0. On an error, {\tt dp\_Res1} shall be
set to {\tt DOSFALSE} and {\tt dp\_Res2} to an error code.

\subsection{Inhibiting the File System} \label{sec:packetinhibit}

The {\tt ACTION\_INHIBIT}\mkey{ACTION\_INHIBIT} packet disables or enables
access of the \emph{file system} to the underlying device; once file system
access is disabled, application programs such as {\tt Format} may access the
underlying device directly.

\begin{rkrmtable}{\tt ACTION\_INHIBIT} \label{table:actioninhibit}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_INHIBIT (31) \\ \hline
\tt dp\_Arg1  & Inhibit flag \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt Inhibit()}\key{Inhibit()} function of the
\emph{dos.library}. An inhibited file system is blocked from accessing its
underlying medium for read and write access, with the exception of {\tt
  ACTION\_FORMAT} and {\tt ACTION\_SERIALIZE\_DISK} which remain
operational. An inhibited file system changes its disk type as reported by
{\tt ACTION\_INFO}\key{ACTION\_INFO} or {\tt
  ACTION\_DISK\_INFO}\key{ACTION\_DISK\_INFO} in the {\tt InfoData}
structure to `{\tt BUSY}', see table~\ref{table:disktype} in
section~\ref{sec:info}.
\smallskip{}

Once the file system is unhibited again, it shall perform a validation of
the medium, as if the medium was been re-inserted. This is necessary because
an application bypassing the file system to access it directly could have
changeed the file system structure, the volume name or the date, or may have
even written a completely new file system structure to it. This check thus
implies checking the flavour of the file system, e.g. the {\tt DosType} for
the FFS, and potentially creating and inserting a {\tt DosList} entry into
the \emph{device list} representing the volume. Thus, first inhbiting and
uninhibiting a file system is equivalent to simulating a medium change; in
fact, the {\tt DiskChange} command enforces a medium change by first
inhibiting and then unhibiting the file system.
\smallskip{}

{\tt id\_Arg1} is a boolean indicator that defines whether the file system
shall be inhibited or uninhibited. If {\tt dp\_Arg1} is {\tt DOSFALSE}, the
file system is unhibited and a file structure check shall be performed. In
all other cases, the file system shall be inhibited and, with the exception
of {\tt ACTION\_FORMAT}, should refrain from accessing the medium, partition
or device.
\smallskip{}

Before replying this packet, {\tt dp\_Res1} shall be set to a boolean success
indicator. On success, it shall be set to {\tt DOSTRUE} and {\tt dp\_Res2} shall
be set to~0. On failure, {\tt dp\_Res1} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\subsection{Check if a Handler is a File System}

The {\tt ACTION\_IS\_FILESYSTEM}\mkey{ACTION\_IS\_FILESYSTEM} tests whether
a handler is a file system.

\begin{rkrmtable}{\tt ACTION\_IS\_FILESYSTEM} \label{table:actionisfilesystem}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_IS\_FILESYSTEM (1027) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Buffer count or error code\\ \hline
\end{rkrmtable}

This packet implements the {\tt IsFileSystem()}\key{IsFileSystem()} function
of the \emph{dos.library} and tests whether a particular handler provide
sufficient services to operate as a \emph{file system}. A file system shall
be able to access multiple separate files, shall be able to support locks
and shall also be able to examine directories. A file system may be either a
flat or a hierarchical file system, i.e. a file system is not required to
support multiple directories on a storage medium, device or partition.
\smallskip{}

This packet does not take any arguments. It shall set {\tt dp\_Res1} to {\tt
  DOSTRUE} and {\tt dp\_Res2} to~0 in case the handler qualifies as a file
system. In case the handler supports this packet but does not implement a
file system, it shall set {\tt dp\_Res1} to {\tt DOSFALSE} and {\tt
  dp\_Res2} to~0. 
\smallskip{}

If the handler sets {\tt dp\_Res1} to {\tt DOSFALSE} and {\tt dp\_Res2} to
{\tt ERROR\_ACTION\_NOT\_KNOWN}, then this is an indication that the handler
cannot interpret this particular packet. If this secondary result code is
identified by the {\tt IsFileSystem()} function, it falls back to a
heuristic for determining whether a handler is a file system: It uses {\tt
  Lock(":",SHARED\_ACCESS)}, i.e. {\tt ACTION\_LOCATE\_OBJECT} on the file
system root. If such a lock can be obtained, then this heuristic assumes
that the handler is, in fact, a file system.

\subsection{Write out all Pending Modifications}

The {\tt ACTION\_FLUSH}\mkey{ACTION\_FLUSH} packet instructs the file system
to write all pending or cached modifications out to disk\footnote{Users of
unixoid systems may consider this as the AmigaDOS equivalent of {\tt sync}.}.

\begin{rkrmtable}{\tt ACTION\_FLUSH} \label{table:actionflush}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_FLUSH (27) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library} and thus can only be
send manually through the packet interface, e.g. {\tt DoPkt()}\key{DoPkt()}. File
systems may cache writes in order to improve their performance, and may
defer any write operations an arbitrary amount of time. This packet instructs
the file system to write out all modifications immediately.
\smallskip{}

This packet shall not be replied before all changes have been written and,
if applicable, the drive motor has been turned off. However, FFS versions of
V40 and before replied {\tt ACTION\_FLUSH} immediately and thus only
established a write barrier. This was fixed in V43.
\smallskip{}

Even though it is unclear how clients could make use of the result code,
file systems should set {\tt dp\_Res1} to {\tt DOSTRUE} and {\tt dp\_Res2}
to~0 on success\footnote{The official reference~\cite{Bantam} only states
that {\tt dp\_Res1} shall be set to {\tt DOSTRUE}. This is probably what
most AmigaDOS file systems implement, though the value of unconditionally
indicating success is questionable.}. In case of error, file systems should
set {\tt dp\_Res1} to {\tt DOSFALSE} and {\tt dp\_Res2} to an error
code.

\subsection{Shutdown a Handler} \label{sec:packetactiondie}

The packet {\tt ACTION\_DIE}\mkey{ACTION\_DIE} requests a file system or
handler to unmount its volumes and terminate.

\begin{rkrmtable}{\tt ACTION\_DIE} \label{table:actiondie}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_DIE (5) \\ \hline \hline
\tt dp\_Res1  & Boolean result code\\ \hline
\tt dp\_Res2  & Error code\\ \hline
\end{rkrmtable}

This packet is not exposed through the \emph{dos.library}; rather, the
packet needs to be send through the packet interface, i.e. through {\tt
  DoPkt()}\key{DoPkt()}. This packet requests the file system to release all resources,
set the {\tt dol\_Task} elements of the {\tt DosList} structures in the
\emph{device list} to {\tt NULL}, and then terminate the process.
\smallskip{}

A file system or handler may not be able to terminate itself if some files
are still open or some locks have not yet been unlocked. In such a case,
this packet should fail with an error by setting {\tt dp\_Res1} to {\tt
  DOSFALSE} and {\tt dp\_Res2} to an error code, e.g. {\tt
  ERROR\_OBJECT\_IN\_USE}. In case of success, {\tt dp\_Res1} shall be set
to {\tt DOSTRUE} and {\tt dp\_Res2} to~0.
\smallskip{}

After unmounting the volume and replying to this packet, the {\tt
  MsgPort}(s) of this handler or file system used for packet communication
may still contain packets that were submitted after {\tt ACTION\_DIE} has
been received. In order to avoid a deadlock, the file system still needs to
reply these packets, for example by the default result codes from
table~\ref{table:unimp}, see also section~\ref{sec:terminatehandler}.
\smallskip{}

Some handlers do not initialize the {\tt dol\_Task} element of its {\tt
  DosList} entrie(s) with an address of their port(s); file systems are
typical examples. Such handlers shall terminate themselves without requiring
an {\tt ACTION\_DIE} when the last lock and file have been released.

\subsection{Do Nothing}

The {\tt ACTION\_NIL}\mkey{ACTION\_NIL} packet performs no activity.

\begin{rkrmtable}{\tt ACTION\_NIL} \label{table:actiondie}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Type  & \tt ACTION\_NIL (0) \\ \hline \hline
\tt dp\_Res1  & \tt DOSTRUE \\ \hline
\tt dp\_Res2  & 0\\ \hline
\end{rkrmtable}

This packet is not exposed by the \emph{dos.library}. It does not perform
any activity. A handler or file system implementation should indicate
success when replying this packet. Another reason why a seemingly {\tt
  ACTION\_NIL} packet can appear at a handler {\tt MsgPort} is because the
startup package has its {\tt dp\_Type} set to~0, too, and thus identifies itself
also as {\tt ACTION\_NIL}. While {\tt ACTION\_NIL} does not provide
any arguments, the startup package does, see
section~\ref{sec:handlerstartup}.
\medskip{}

There is no reason why this packet should actually fail, unless a handler
implements startup handling through the packet type {\tt ACTION\_NIL}. On
success, {\tt dp\_Res1} shall be set to {\tt DOSTRUE} and {\tt dp\_Res2}
to~0. On an error {\tt dp\_Res2} shall be set to {\tt DOSFALSE} and
{\tt dp\_Res2} to an error code.

\section{Handler Internal Packets}

The packets in this section shall never be sent to a handler or filesystem
as part of an application request. Instead, these packets are only used
internally within the handler, and are rather an implementation trick to
uniform the handler event processing. While regular {\tt DosPackets} are
carried by an exec message, the packets listed here are instead linked to an
{\tt IORequest} (see {\tt exec/io.h}). This allows using a shared port,
typically the {\tt pr\_MsgPort} of the handler process, for receiving
replied {\tt IORequest}s and incoming packets as both appear as {\tt
  DosPackets}.
\smallskip{}

The {\tt io\_Message.mn\_Node.ln\_Name} points to the {\tt DosPacket}
structure, and its {\tt dp\_Link} elements points back to qthe {\tt
  IORequest}. Handlers dispatch these {\tt IORequest} to exec devices
asynchronously with {\tt SendIO()}, and continue to process requests while
the exec device is busy with the requested input or output command. Due to
its linkage to a {\tt DosPacket}, a completed {\tt IORequest} is received by
the packet interface of the handler as one of the packet types listed here.

\subsection{Receive a Returning Read}

The {\tt ACTION\_READ\_RETURN} packet is part of a returning {\tt CMD\_READ}
or similar read {\tt IORequest} sent to an exec device and indicates that
reading data completed.

\begin{rkrmtable}{\tt ACTION\_READ\_RETURN} \label{table:readreturn}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Link  & APTR to {\tt IORequest} \\ \hline  
\tt dp\_Type  & \tt ACTION\_READ\_RETURN (1001) \\ \hline
\end{rkrmtable}

This packet does \emph{not} constitute a request to the handler, it rather
indicates that the {\tt IORequest} pointed to by {\tt dp\_Link} completed
and the requested data is now available. As such, this packet shall never be
replied.

\subsection{Receive a Returning Write}

The {\tt ACTION\_WRITE\_RETURN} packet is part of a returning {\tt CMD\_WRITE}
or similar write {\tt IORequest} sent to an exec device and indicates that
writing data completed.

\begin{rkrmtable}{\tt ACTION\_WRITE\_RETURN} \label{table:writereturn}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Link  & APTR to {\tt IORequest} \\ \hline  
\tt dp\_Type  & \tt ACTION\_WRITE\_RETURN (1002) \\ \hline
\end{rkrmtable}

This packet does \emph{not} constitute a request to the handler, it rather
indicates that the {\tt IORequest} pointed to by {\tt dp\_Link} completed
and writing data completed. As such, this packet shall never be
replied.

\subsection{Receive a Returning Timer Request}

The {\tt ACTION\_TIMER} packet is part of a returning {\tt TR\_ADDREQUEST},
a {\tt timer.device} request to wait for a time period. 


\begin{rkrmtable}{\tt ACTION\_TIMER} \label{table:actiontimer}
{\bf DosPacket Element}   & {\bf Value}\\ \hline \hline
\tt dp\_Link  & APTR to {\tt IORequest} \\ \hline  
\tt dp\_Type  & \tt ACTION\_TIMER (30) \\ \hline
\end{rkrmtable}

This packet does \emph{not} constitute a request to the handler, it rather
indicates that the {\tt IORequest} pointed to by {\tt dp\_Link} completed
and the requested time span passed. As such, this packet shall never be
replied. The FFS uses this packet to turn off the drive motor after the last
read or write operation, and interactive handlers such as the console use it
to implement {\tt ACTION\_WAIT\_CHAR}\key{ACTION\_WAIT\_CHAR}.

\section{The CON-Handler} \label{sec:console}

The CON-Handler implements the console of AmigaDOS. It not only serves the
graphical console, but also the serial console. The AUX-Handler is only a
minimal wrapper that locates the CON-Handler in the ROM and then initates
the CON-Handler with a suitable startup packet. Therefore, it serves the {\tt CON:},
{\tt RAW:} and {\tt AUX:} device.
\smallskip{}

Quite similar to file systems, the CON-Handler does not implement all of its
functionality itself. It rather depends on services of exec devices. For the
graphical console, it creates an intuition window and initializes the {\tt
  console.device} to run within. For the serial console, i.e. {\tt AUX:}, it
operates on top of the {\tt serial.device}, but can be made to use any other
interface device with proper mount parameters.

\subsection{CON-Handler Path for Graphical Consoles} \label{sec:conwindowpath}

The path through which a stream to the CON-Handler is opened determines for
the graphical console the size, position and features of the window the
console appears within; for the serial console, it defines connection
parameters such as the baud rate and the parity. The path for the graphical
console accessed through {\tt CON:}, and for {\tt RAW:} likewise are as
follows:

\begin{verbatim}
CON:<left>/<top>/<width>/<height>/<title>[/<options>]
\end{verbatim}

The {\tt <left>} parameter determines the left edge of the window within
which the console shall appear; it is measured in pixels. If this parameter
is not present or negative, intuition is instructed to pick a default. This
is usually under the cursor position.
\smallskip{}

The {\tt <top>} parameter is the top edge of the window, also measured in
pixels. If this parameter is not present or negative, intuition is
instructed to pick a default.
\smallskip{}

The {\tt <width>} parameter is the width of the window, including all window
decorations. If this is not present or negative, the handler instructs
intuition to pick a default. This is typically the width of the screen. If
no parameters are present at all, i.e. the path is just {\tt CON:}, the
width of the window is set to 640 pixels for legacy reasons.
\smallskip{}

The {\tt <height>} parameter is the height of the window, including all
window decorations. If this parameter is not present, the window height is
set to 100 pixels for legacy reasons. If this parameter is negative, the
window height will be the height of the screen.
\smallskip{}

The {\tt <title>} parameter is the string that is put into the drag bar of
the console window to create. To insert the forward slash (``{\tt /}'') into
the string, it is escaped with a backslash, i.e. ``{\tt \textbackslash{}/}''
creates a single forwards slash that does not act as a path
separator\footnote{Given the overall syntax of AmigaDOS, the asterisk {\tt
  *} would have been a more logical choice.}, the backslash is escaped by
itself, i.e. ``{\tt \textbackslash{}\textbackslash{}}'' creates a single
backslash in the title.
\medskip{}

All following path components configure options for the graphical
terminal; multiple of these parameters may be combined, separated by a
forwards slash (``{\tt /}'') from each other:
\smallskip{}

{\tt CLOSE} adds a close gadget to the window. Pressing on it creates an
end-of-file indication on the next attempt to read data from the console,
similar to the key combination Ctrl+\textbackslash{}.
\smallskip{}

{\tt NOCLOSE} is the negative form of the above option and removes a
potentially added close gadget from the window.
\smallskip{}

{\tt AUTO} delays opening the window to the point where an attempt is made
to read data from the console or write data into the console.  Up to that
point the console remains closed. If neither read requests nor write
requests are pending, the close gadget will also close the window without
queuing an end-of-file; the window will pop-open again as soon as input or
output requests appear. Unfortunately, an {\tt ACTION\_DISK\_INFO} will
lock the window open, see section~\ref{sec:diskinfoconsole} for alternatives
to this packet or how to regain the {\tt AUTO} feature.
\smallskip{}

{\tt WAIT} delays closing the window after every file handle to the console
has been closed. With this flag, the window stays open until the close
gadget has been pressed, even if no client is connected to the terminal
anymore to receive input or perform output.
\smallskip{}

{\tt SMART} enforces smart refresh of the window. If this is enabled, more
RAM is required, but it is not necessary to re-render the contents of the
console window if it is made visible behind another window.  In most cases,
this makes little difference and only increases the RAM footprint.
\smallskip{}

{\tt SIMPLE} enforces simple refresh of the window. If hidden window
contents are made visible again they will be reprinted. This does usually
not cost a lot of time, saves RAM and is also the default.
\smallskip{}

{\tt INACTIVE} prevents that the window is receiving automatically the input
focus when it is opened. The user has to click into it to type in the
console.
\smallskip{}

{\tt BACKDROP} instructs intuition to place the window behind all other
windows on a screen. This works best in conjuction with {\tt NOBORDER}, an
empty window title, the {\tt NOSIZE}, {\tt NODRAG} and {\tt NODEPTH} option
and a console redirected to a public screen. If the window is made as large
as the screen, the result will create a full-screen console.
\smallskip{}

{\tt NOBORDER} removes the window decorations; if a title is present, the
drag bar will still appear. Thus, this option is ideally combined with an
empty title string.
\smallskip{}

{\tt NOSIZE} removes the size gadget of the console on the top right edge of
the window and thus creates a fixed-size window.
\smallskip{}

{\tt NODRAG} removes the dragbar at the top of the window and makes the
window non-movable. A potential application is to create a non-movable
console as screen background.
\smallskip{}

{\tt WINDOW} instructs the console to hijack an already open window and
place the console within this window. This window will also be closed if the
console closes. The address of the {\tt Window} structure is provided in
hexadecimal behind the parameter, optionally separated by spaces, e.g. {\tt
  WINDOW~200AFC0}. An optional ``0x'' string may appear upfront the
hexadecimal window address to indicate the base. This parameter replaces a
legacy startup mechanism by which the console could also be placed into an
already opened window.
\smallskip{}

{\tt SCREEN} provides a name of a public screen on which the console shall
appear instead of the workbench. The public screen name follows, optionally
separated by spaces, e.g. {\tt SCREEN~myProgram.1}. If the screen name is
{\tt *}, then the frontmost public screen will be used as host for the
console.
\smallskip{}

{\tt ALT} provides alternative window dimensions and placement to which the
window can be toggled by the top-left zoom gadget of the window. The
alternative window placement provides left edge, top edge, width and height,
similar to the main window placement, though numerical arguments are
separated by comma (``{\tt ,}'') and not by the forwards slash. This
alternate placement shall follow directly behind the {\tt ALT} keyword,
e.g. {\tt ALT 0,0,320,200}.
\smallskip{}

{\tt ICONIFY} equips the window with an iconfication gadget. This requires
the {\tt ConCip} program running in order to have an icon available for the
console. If the iconification gadget is pressed, this icon will appear on
the workbench, and the window will disappear. The window will be forced open
when a incoming read or write request requires a window to read from or
write data into. Similar to the {\tt AUTO} option, windows will loose the
ability to become iconified if a program requests the window pointer through
{\tt ACTION\_DISK\_INFO}, see again section~\ref{sec:diskinfoconsole} for
details.

\subsection{CON-Handler Path for Serial Consoles}

If the console is a serial console, e.g. mounted as {\tt AUX:} handler,
another set of parameters becomes available that configures the serial
connection; if the console is run on any other than the {\tt serial.device}
through mount parameters, this device shall support the
{\tt SDCMD\_SETPARAMS} command through which these path parameters are
installed.

\begin{verbatim}
AUX:<baud>/<control>[/<options>]
\end{verbatim}

{\tt baud} defines the baud rate of the serial console, e.g. {\tt 9600}. If
this parameter is not provided, it is taken from the {\tt BAUD} mount
option, and if that is not provided, the settings come from the serial
preferences.
\smallskip{}

{\tt control} defines the number of data bits, the parity and the number of
stop bits, all concatenated into a string of 3 characters. The number of
data bits is a digit between ``{\tt 1}'' and ``{\tt 8}'' and does not
include the parity bit. The parity is either ``{\tt N}'' for no parity,
``{\tt E}'' for even and ``{\tt O}'' for odd parity, or ``{\tt M}'' for mark
and ``{\tt S}'' for space parity. The number of stop bits is either the
digit ``{\tt 0}'', ``{\tt 1}'' or ``{\tt 2}''. A rather typical setting is
{\tt 8N1}, i.e. 8 data bits, no parity, one stop bit. This is also the
configuration within which the performance of the {\tt serial.device} is
optimal. If this parameter is not present, it is taken (with identical
encoding) from the {\tt CONTROL} parameter of the mount list, and if it is
not present there, from the serial preferences editor.
\medskip{}

As for the graphical console, several optional parameters follow:
\smallskip{}

{\tt RAW} forces the console into the (non-cooked) raw mode within which
input characters are not echoed and no line buffering takes place. The same
can be reached with the mount parameter {\tt STARTUP=1}.
\smallskip{}

{\tt UNIT} defines the unit of the device over which the connection shall be
made if multiple units exist. The unit follows the keyword as decimal
number, optionally separated by spaces, e.g. {\tt UNIT 1}. The unit can
also be configured through the mount list {\tt UNIT} keyword.
\smallskip{}

{\tt AUTO} indicates that the serial connection shall not be opened
immediately, but only after the first attempt is made to write data through
it or to read data from it. This works similar to the {\tt AUTO} keyword for
the graphical console.
\smallskip{}

{\tt WAIT} indicates that the serial connection stays open even after every
file handle to the console was closed. To shut down the serial connection,
an ASCII {\tt FS} character = Hex {\tt 0x1c} shall be send by the user. This
character is created on the Amiga keyboard with Ctrl+\textbackslash{}. This
also mirrors the {\tt WAIT} keyword of the graphical console.

\subsection{CON-Handler Line Buffer Modes}

In addition to the window or serial parameters communicated to the path, the
console is also configured through the {\tt SetMode()}\key{SetMode()}
function, see section~\ref{sec:setmode} and table~\ref{table:conmodes}. This
mode sets the buffer mode of the console, regardless of the device the
console runs on. In particular, {\tt SetMode()}\key{SetMode()} allows to
convert a {\tt CON:} window into a {\tt RAW:} window, create an equivalent
of a {\tt RAW:} handler from an {\tt AUX:} connection.
\smallskip{}

The buffer mode~0 corresponds to a regular {\tt CON:} window and also to the
{\tt AUX:} console. In this so called \emph{cooked mode}, the console echoes
every keystroke on the window, and provides line editing functionalities
such as cursor movements. Only when the user presses {\tt RETURN}, an entire
line of data enters the output buffer, and there becomes available for an
{\tt ACTION\_READ}.
\smallskip{}

One particular difference between the V47 console and previous versions its
predecessors is that the console no longer offers a history. Rather, the
history functions have been moved to the Shell using the medium mode
corresponding to buffer mode~2 described below.
\smallskip{}

In the cooked mode, and also in the medium mode, the CON-Handler interprets
the following keystrokes:

\begin{rkrmtabular}{Cooked Keyboard Sequences} \label{table:cookedconsole}
\begin{longtable}{|ll|} \hline
{\bf Keystroke} & {\bf Function}\\ \hline \hline
Cursor left       & Move left one character \\ \hline
Cursor right      & Move right one character \\ \hline
Cursor up         & Do nothing${}^*$ \\ \hline
Cursor down       & Do nothing${}^*$ \\ \hline
Shift+cursor up   & Do nothing${}^*$ \\ \hline
Shift+cusor down  & Do nothing${}^*$ \\ \hline
Shift+cursor left & Move to the start of line\\ \hline
Shift+cursor right& Move to the end of line\\ \hline
Shift+cursor up   & Move to the start of line${}^*$ \\ \hline
Shift+cursor down & Erase line${}^*$ \\ \hline
TAB               & Inserts a TAB control code${}^*$ \\ \hline
Shift+TAB         & Do nothing${}^*$ \\ \hline
Ctrl+a            & Move to the start of line \\ \hline
Ctrl+b            & Erase entire line \\ \hline
Ctrl+c            & Sends signal 12 \\ \hline
Ctrl+d            & Sends signal 13 \\ \hline
Ctrl+e            & Sends signal 14 \\ \hline
Ctrl+f            & Sends signal 15 \\ \hline
Ctrl+x            & Erase entire line \\ \hline
Cltr+k            & Kill characters into yank buffer \\ \hline
Cltr+q            & Resume output \\ \hline
Ctrl+s            & Suspend output \\ \hline
Ctrl+r            & Do nothing${}^*$ \\ \hline
Ctrl+u            & Delete beginning of line \\ \hline
Cltr+w            & Delete word \\ \hline
Cltr+y            & Paste characters from yank buffer\\ \hline
Ctrl+z            & Move to end of line \\ \hline
Ctrl+\textbackslash & Signal an end-of-file \\ \hline
Backspace         & Delete character upfront cursor \\ \hline
Del               & Delete character under cursor \\ \hline
\multicolumn{2}{|l|}{\small ${}^*$ Interpreted differently in medium mode, see
  table~\ref{table:mediumcsi}} \\ \hline
\end{longtable}
\end{rkrmtabular}
As seen in the table, some keystrokes operate differently in the medium
mode; in that mode, they request a particular function from the shell by
sending a ``TAB Report'' CSI sequence.
\smallskip{}

The ``yank buffer'' keeps characters that have been cut out with Ctrl+k. Its
contents can be reinserted into the console with Ctrl+y. It operates
independently of the clipboard and is local to each console window.
\medskip{}

The buffer mode~1 corresponds to a {\tt RAW:} window and is denoted the
\emph{raw mode}. In this mode, every keystroke becomes available to client
programs as it enters the output buffer immediately. Cursor movements thus
become available as CSI sequences. In this mode, the console does not echo
user input. The CSI sequences are those defined by the {\tt console.device},
resp. the current keymap of the device.
\medskip{}

The buffer mode~2 is not available under a device name, even though one
could in principle create a suitable mount list for it. The mode is reserved
for the shell and forewards TAB-Expansion and history functions to the
shell. While the console again provides line editing features and echoes
most keys on the screen, some keyboard sequences create immediate output
through a ``TAB Report'' CSI sequence that enters the output buffer
immediately. These sequences are interpreted by the Shell and trigger there
corresponding functions, such as expanding a pattern or working through the
command history. A TAB Report sequence looks as follows:

\begin{verbatim}
CSI <m>;<s>;<c>U <line>
\end{verbatim}

Here {\tt CSI} is the ANSI ``control sequence introducer'', which has the
byte value {\tt 0x9b}. The {\tt <m>} value is a decimal number that
identifies the keystroke and also the function the Shell is requested to
perform. Such functions browse in the history or expand a file name
pattern. The Shell re-inserts the result of such a function back into the
console with an {\tt ACTION\_FORCE} packet, see section~\ref{sec:actionforce}.
\smallskip{}

The parameters {\tt <s>} and {\tt <c>} provide the length of the current
line input buffer of the console the user is editing, and the (1-based,
i.e. cursor at the left edge corresponds to {\tt <c>} = 1) cursor position
within this buffer.
\smallskip{}

The {\tt U} is a literal character and identifies this sequence as
TAB-Report. {\tt <line>} is a copy of the current line that is edited by the
user. For many sequences, this input is used as a template the shell to
perform the requested action, e.g. for a TAB-expansion, it provides the
entire input, though the command line argument within which the cursor is
positioned is used to generate a wildcard the Shell uses to find possible
candidates for its expansion.
\smallskip{}

The keystrokes that trigger such TAB Report sequences, along with their
purpose, are as follows:

\begin{rkrmtable}{Medium Mode CSI Sequences} \label{table:mediumcsi}
{\bf Keystroke} & {\bf Sequence}\\ \hline \hline
Cursor up         & {\tt <U>}=2, move upwards in the history \\ \hline
Cursor down       & {\tt <U>}=3, move downwards in the history \\ \hline
Shift+cursor up   & {\tt <U>}=4, search history upwards \\ \hline
Shift+cursor down & {\tt <U>}=5, search history downwards \\ \hline
Ctrl+r            & {\tt <U>}=6 ,search history upwards, partial pattern \\ \hline
Ctrl+b            & {\tt <U>}=10,rewind history \\ \hline
TAB               & {\tt <U>}=12,iterate forwards through expansion \\ \hline
Shift+TAB         & {\tt <U>}=13,iterate backwards through expansion \\ \hline
\end{rkrmtable}

The only difference between the cases {\tt <U>}=6 and {\tt <U>}=4 is that
the former only uses the line input buffer up to the cursor position as
search pattern and ignores everything past it.
\medskip{}

\subsection{CON-Handler Startup Parameters}

In addition to the window or serial parameters communicated to the path, the
console is also configurd through the handler startup mechanism. It provides
defaults for the serial console, but also define the line buffer mode of the
console described in the previous section.
\smallskip{}

The mount parameters for {\tt CON:} and {\tt RAW:} are hard-coded into the
Kickstart ROM, though the mountlist for {\tt AUX:} is available in the {\tt
  DEVS:DosDrivers} directory and can be altered there; however, users can
create custom mount lists for additional devices with custom mount
parameters.
\smallskip{}

The handler startup mechanism is described in
section~\ref{sec:handlerstartup}, and in particular, {\tt dp\_Arg2} of the
startup packet is a copy of the {\tt dol\_Startup} entry of the {\tt
  DosList} created from the mount list; details on this mechanism are
described in section~\ref{sec:filesysstartup}.
\smallskip{}

The following table specifies the values of {\tt dol\_Startup} the
CON-Handler recognizes:

\begin{rkrmtable}{CON-Handler Startup Code} \label{table:constartup}
{\bf \tt dol\_Startup}   & {\bf Description}\\ \hline \hline
< 0 & RAW: raw mode, within a window pointed to by {\tt dp\_Arg1} \\ \hline
0   & CON: cooked mode, create a new window \\ \hline
1   & RAW: raw mode, create a new window \\ \hline
2   & CON: medium mode, create a new window \\ \hline
3   & RAW: reserved for future extensions \\ \hline
BPTR with bit 30 cleared & raw mode open on a device specified by a
FileSysStartupMsg \\ \hline
BPTR with bit 30 set    & cooked mode open on a device specified by a
FileSysStartupMsg \\ \hline
\end{rkrmtable}

The values~0 to~3 configure the line buffer mode and are correspond to the
buffer mode selected through~{\tt SetMode()}\key{SetMode()}. The buffer
mode~3 is currently not used and reserved for future extensions.
\smallskip{}

The case of a negative {\tt dol\_Startup} value is a legacy startup
mechanism of the console. In this confguration, {\tt dp\_Arg1} of the
startup packet (see section~\ref{sec:handlerstartp}) is not a BPTR to a path
as usual, but instead a pointer (not a BPTR) to an intuition {\tt Window}
structure; the CON-Handler then creates a graphical console within this
window. It is quite hard to make practical use of this startup mechanism and
thus it is discouraged, but~\cite{guru} provides example code how to trigger
it. A better mechanism to redirect a console to a particular window is the
{\tt WINDOW} argument of the command path which is described in
section~\ref{sec:conwindowpath}.
\smallskip{}

In all other cases, {\tt dol\_Startup} is a BPTR to a {\tt FileSysStartupMsg} described
in more detail in section~\ref{sec:filesysstartup}. The {\tt fssm\_Device}
and {\tt fssm\_Unit} elements of this structure provide a device and
unit the console shall run on. The {\tt AUX:} handler uses this mechanism to
create a {\tt FileSysStartupMsg} to the CON-Handler which points to the {\tt
  serial.device} unit~$0$, but also accepts custom mount parameters to mount
it on other devices through the {\tt EHandler} mount parameter. The
{\tt Device} parameter of the mount list is then extracted, and forwarded to
the CON-Handler through a startup packet. Thus, a console can be generated on
either type of device provided it supports {\tt CMD\_WRITE} to write data out
and {\tt CMD\_READ} to receive keystrokes.
\smallskip{}

As BPTRs are upshifted by two bits to gain a regular pointer, the otherwise
unused bit 30 of the BPTR is used for mode selection. If this bit is~1, the
console will be a cooked console with line buffer, and if this bit is~0, the
console is raw.
\smallskip{}

To make the {\tt Mount} command create a {\tt DosList} corresponding to the
latter case, the CON-Handler needs to be mounted as {\tt EHANDLER}. The
following is an example mountlist providing a serial console on a custom
serial hardware:

\begin{verbatim}
EHandler = CON-Handler
Device   = duart.device
Unit     = 0
Baud     = 9600
Control  = "8N1"
\end{verbatim}

The very same mountlist can be used with the AUX-Handler; if it is mounted
as an extended handler, it will just take its mount parameters and forwards
them to the CON-Handler. If mounted with the (regular) {\tt HANDLER} keyword
in the mountlist, it will create a {\tt FileSysStartupMsg} corresponding to
the {\tt serial.device} and provide this to the CON-Handler. The AUX-Handler
is therefore rather minimal.

\section{The Port-Handler}

The Port-Handler is responsible for the {\tt PAR:}, {\tt SER:} and {\tt
  PRT:} devices and thus represents the Amiga hardware interfaces as
AmigaDOS devices. Clearly, {\tt PAR:} interfaces to the {\tt
  parallel.device}, {\tt PRT:} to the {\tt printer.device} and {\tt SER:} to
the {\tt serial.device}. The difference between {\tt SER:} and {\tt AUX:} is
that the former processes raw streams of bytes transmitted over a serial
connection, whereas {\tt AUX:} provides line buffering and line editing
capabilities and thus implements a console.

\subsection{Port-Handler Path}

Access to the Port-Handler is configurable through the path following the
device name. The path looks as follows:

\begin{verbatim}
SER:[<options>]
\end{verbatim}

The following keywords in {\tt options} exist, where options are
separated by a forwards slash (''{\tt /}'') from each other.
\smallskip{}

{\tt BAUD} sets the baud rate, which is only relevant for serial
connections. It specifies the number of bits per second transmitted over a
serial connection. If this parameter is not present, the default from the
serial preferences is used. Optionally, this parameter may be introduced
with the keyword {\tt BAUD} which shall be separated from the decimal baud
rate by spaces or an equals sign, e.g. {\tt BAUD~9600}. Clearly, this
parameter is only used by {\tt SER:}.
\smallskip{}

{\tt control} specifies additional parameters of the serial connection such
as number of data bits, parity and number of stop bits, represented as 3
letter string. The string follows the same convention used for the {\tt
  AUX:} terminal. The first digit is between ``{\tt 1}'' and ``{\tt 8}'',
specifying the data bits, the second letter the parity, which is either {\tt
  N}, {\tt E}, {\tt O}, {\tt M} or {\tt S}, indicating no parity, even or
odd parity, or mark or space parity. The last digit is the number of stop
bits and is a digit between ``{\tt 0}'' and ``{\tt 2}''.
\smallskip{}

A typical control string is {\tt 8N1} indicating 8 data bits, no parity and
1 stop bit, corresponding to the fastest possible console. Optinally, this
parameter may be introduced with the keyword {\tt CONTROL} which shall be
separated from the control string by spaces or an equals-sign, e.g. {\tt
  CONTROL 8N1}.
\smallskip{}

If this parameter is not present, the default from the serial preferences is
used. Obviously, this parameter is only used by {\tt SER:} and ignored
otherwise.
\medskip{}

{\tt TRANSPARENT} is a boolean switch that, if present, indicates that CSI
sequences written over this device shall not be translated to the configured
printer, but shall rather be send directly to the printer. By default, the
{\tt PRT:} device uses the AmigaDOS defined CSI sequences that are device
independent. This option is only used by the {\tt PRT:} device and ignored
otherwise.
\smallskip{}

{\tt RAW} is a boolean switch that, if present, disables translation of the
AmigaDOS newline-character {\tt 0x0a} to {\tt 0x0a 0x0c} pairs, i.e. a line
feed followed by carriage return. This switch only applies to the {\tt PRT:}
device and is not used otherwise.
\smallskip{}

{\tt UNIT} takes a numeric argument and provides the device unit that will
be opened. This makes most sense if the Port-Handler is not mounted on the
standard exec devices, but a custom device is provided through the {\tt
  DEVICE} keyword of a custom mountlist. The unit number is represented as
decimal number separated from the keyword by spaces or an equals-sign,
e.g. {\tt UNIT 1}. This option is operational regardless of the underlying
device.
\smallskip{}

{\tt NOWAIT} is boolean switch that, if present, avoids blocking when
reading from a serial connection. If no data is available at the serial
port, a connection configured with {\tt NOWAIT} will report an end-of-file
condition. Otherwise, such a stream would block until data is
available. This option is only supported for serial connections.
\smallskip{}

Another possibility to implement non-blocking reading from the serial port
is to use {\tt WaitForChar()}\key{WaitForChar()} which is also supported by
the Port-Handler. It blocks until either the specified timeout is reached,
or input data is available on the port.

\subsection{Port-Handler Startup}

The Port-Handler is also configurable through a mountlist, though mount
parameters for {\tt PAR:}, {\tt SER:} and {\tt PRT:} are hard-coded within
the Kickstart ROM. However, users may create custom mountlists and mount the
handler under a custom name.
\smallskip{}

As for all handlers, it is customized through {\tt dol\_Startup},
transmitted in {\tt dp\_Arg2} in the handler startup packet. The following
values are recognized:

\begin{rkrmtable}{Port Handler Startup Code} \label{table:portstartup}
{\bf \tt dol\_Startup}   & {\bf Description}\\ \hline \hline
0 & SER: serial output through the serial.device \\ \hline
1 & PAR: parallel output through the parallel.device \\ \hline
2 & PRT: printer output through the printer.device \\ \hline
BPTR & serial output with parameters from the FileSysStartupMsg
\\ \hline
\end{rkrmtable}

The values~0 to~2 represent the standard handlers {\tt SER:}, {\tt PAR:} and
{\tt PRT:} mounted by the kickstart. They can be recreated by a {\tt
  STARTUP=<n>} entry in a mountlist. For these options, the standard Amiga
device names for the serial, parallel and printer interface is used.
\smallskip{}

The last option allows to customize the target exec device to run on. In
this case, {\tt dol\_Startup} is a BPTR to a {\tt FileSysStartupMsg}
described in section~\ref{sec:filesysstartup}. To make the {\tt Mount}
command create a suitable {\tt DosList} entry, {\tt EHANDLER} keyword is
used, and a {\tt DEVICE} and {\tt UNIT} option can be provided. If the
mountlist includes in addition a {\tt BAUD} value, that is used as default
value for the baud rate, which can be overridden by the Port-Handler path
described in the previous section. The {\tt CONTROL} parameter in the
mountlist, if present, also control sthe serial settings. An example
mountlist would look as follows:

\begin{verbatim}
EHandler = Port-Handler
Device   = duart.device
Unit     = 1
Baud     = 19200
Control  = "8N1"
\end{verbatim}

\section{The Queue-Handler}

The Queue-Handler provides inter-process communication on the basis of
AmigaDOS file handles. It is used by the Shell to implement pipes; they
collect the output of one command and provide it as input to another,
without requiring to store the entire output. The reading end of a pipe
blocks as long as no data becomes available at the writing end, and the
writing end blocks if the reading end is not able to consume data fast
enough. If the reading end closes the pipe, the Queue-Handler attempts to
abort the writing end.
\smallskip{}

Even though the Queue-Handler is disk-based, it is already mounted by the
Kickstart-ROM as {\tt PIPE:}, though additional instances under other device
names can be mounted through the user.

\subsection{Queue-Handler Path}

Pipes are created and identified by a unique name; reading and writing ends
of the same name are connected together. The name itself does not matter as
long as it uniquely identifies the pipe; the Shell constructs a pipe name
from the process indicator and a second unique number that is incremented
for each pipe used. The packet {\tt ACTION\_FINDINPUT} opens the reading
end, and {\tt ACTION\_FINDOUTPUT} the writing end. The third open mode, {\tt
  ACTION\_FINDUPDATE} is not supported.
\smallskip{}

The empty name establishes a special case. It identifies a pipe that is
already open as standard input or standard output of a process. In case a
pipe is openend without a name, the Queue-Handler checks whether the
standard input or standard output of the client process is already open to a
pipe, and if so, this end is reused. This allows constructions such as

\begin{verbatim}
list | type PIPE: hex
\end{verbatim}

where the reading end of the pipe is explicitly addressed by an empty pipe
name as it is already established by the Shell as standard input of the {\tt
  type} command. It is necessary here because the command line syntax of
{\tt type} does not include provisions to read from its input stream.
\smallskip{}

The pipe path may follow by options configuring the pipe, thus the complete
path specification is as follows:

\begin{verbatim}
PIPE:name[/quantumsize[/buffercount]]
\end{verbatim}

The {\tt quantumsize} is the size of a block the Queue-Handler uses to
buffer intermediate data. Written data is is queued up until a buffer is
full or the writing end is closed, and the full block is then made available
to the reading end. This minimizes the communication overhead as the reading
process does not need to wake up for every single byte. The default quantum
size is 1024 bytes.
\smallskip{}

The {\tt buffercount} configures the number of buffers the Queue-Handler
makes available to the writing end. If all buffers are full without being
retrieved by the reading end, the writing end blocks. This avoids that a
fast writing process floods the memory of the system. The special value of~0
indicates that system memory may be filled up to a safety margin of 64K. The
default buffer count is~8, i.e. at most 8K of data can be waiting in a pipe.

\subsection{Queue-Handler Startup}

The Queue-Handler can also be configured through its startup packet. For
this, {\tt dol\_Startup} in its {\tt DosList} entry shall be a BPTR to a
{\tt FileSysStartupMsg} as specified in section~\ref{sec:filesysstartup}.
The device and unit found there are irrelevant, though the environment
vector in {\tt fssm\_Environ} discussed in section~\ref{sec:envec} contains
some relevant entries.
\smallskip{}

{\tt de\_SizeBlock} set the size of the Quantum, and thus corresponds to the
default of the first optional argument in the path.
\smallskip{}

{\tt de\_NumBuffers} sets the number of such buffers for each pipe and
corresponds to the default of the second optional argument of the path.
\smallskip{}

The Kickstart ROM does not provide a startup value and thus mounts the Queue
handler with its defaults parameters. However, within a custom mountlist,
they can be provided as follows:

\begin{verbatim}
EHandler        = Queue-Handler
BlockSize       = 1024
Buffers         = 8
\end{verbatim}

The {\tt BlockSize} keyword sets the quantum size, and the {\tt Buffers}
keyword the number of quantum buffers.

\section{The RAM-Handler}

The RAM-Handler is a ROM-based file system that places its data in available
RAM of the system. It implements almost all of the file system packets
listed in sections~\ref{sec:fileactions} and following, with the exception
of record locking. The RAM-Handler provides one extended feature, namely
external links, also explaned in section~\ref{sec:links}. Such a link points
to a target outside of the RAM disk; while such objects are initially empty,
their contents will be made accessible by copying the objects within the
link target to the RAM disk.
\smallskip{}

This feature is used within AmigaDOS to realize the {\tt ENV:} assign which
contains the system preferences. This allows to save RAM by only
keeping those files in {\tt RAM:} that are actually accessed.
\smallskip{}

The RAM handler does not interpret any arguments in its startup packet and
cannot be configured through it.

\section{The Fast File System}

The Fast File System (FFS) is the standard Amiga file system and as such
included in the ROM. However, the bootstrap code of Amiga hostadapters are
typically able to load an updated version of this (and other) file systems
from the \emph{rigid disk block} of the boot disk and make it available to
the system. The \emph{System-Startup} module will make such updated version
then also available for all other devices.
\smallskip{}

The same code serves multiple flavours of the file system that differ in the
structure and organization of on disk. Table~\ref{table:ffsflavours} in
section~\ref{sec:envec} provides an overview on the available flavours.
\smallskip{}

As standard file system, the FFS supports all file-system relevant packets
listed from section~\ref{sec:fileactions} onwards with the exclusion of
packets specific to interactive handlers listed in
section~\ref{sec:packetsinteractive}, and the {\tt ACTION\_SET\_OWNER}
packet which remains exclusive to multi-user network file systems. The FFS does
support record locking, soft- and hard links and notification
requests. External links remain currently exclusive to the RAM-Handler and
are neither supported. Latest versions of the FFS can also be shut down by
{\tt ACTION\_DIE} and thus be unmounted.

\subsection{Configuring the FFS}

The FFS is configured through multiple sources. First of all, the {\tt
  DosList}, the {\tt FileSysStartupMsg} pointed to by this structure, and
the environment vector in the latter. Section~\ref{sec:mountlist} provides a
list of the configurable options and the corresponding entries in the
mountlist.
\smallskip{}

In some situations, however, the FFS will override the parameters found in
the above sources, and therefore parameters from the mountlist. In case the
device name is either ``{\tt trackdisk.device}'' or ``{\tt
  carddisk.device}'', the FFS will instead request the disk geometry from
the underlying exec device by a {\tt TD\_GETGEOMETRY} when validating an
available medium. The same logic can also be enabled for all other devices
by the mountlist parameter {\tt SUPERFLOPPY}, which corresponds to the
{ENVF\_SUPERFLOPPY} flag in the {\tt de\_Interleave} element of the
environment vector. This flag, along with the environment vector is defined
in the file {\tt dos/filehandler.h} and also introduced in
section~\ref{sec:envec}.
\smallskip{}

Upon detecting device parameters, data from the device provided {\tt
  DriveGeometry} structure documented in {\tt devices/trackdisk.h} are
copied into the environment vector of the file system. The following
algorithm is used to adjust the data in the environment vector:


\begin{verbatim}
void AdjustEnv(struct DosEnvec *env, 
               const struct DriveGeometry *dg) {
     env->de_SizeBlock      = dg->SectorSize >> 2;
     env->de_HighCyl        = dg->dg_Cylinders - 1;
     env->de_Surfaces       = dg->dg_Heads;
     env->de_BlocksPerTrack = dg->dg_TrackSectors;
}
\end{verbatim}

All other entries of the environment vector remain untouched. The
right-shift for the sector size is necessary because the environment vector
measures it in long-words rather than bytes as provided by the drive
geometry, and {\tt dg\_Cylinders} is a count, whereas {\tt de\_HighCyl} is
an inclusive upper bound. In particular, {\tt dg\_BufMemType} is not copied
over, and therefore {\tt de\_BufMemType} shall be setup though the mountlist
or the rigid disk block. Ideally, of course, any memory type should be
supported and this workaround should not be necessary.
\smallskip{}

The number of blocks kept in the file system cache is read from {\tt
  de\_NumBuffers} in the environment vector, but {\tt ACTION\_MORE\_CACHE}\key{ACTION\_MORE\_CACHE}
can be used to adjust this parameter anytime.

\subsection{The Boot Block}

The FFS flavour is initially read from {\tt de\_DosType} element of the
environment vector, see section~\ref{sec:envec}. However, the initial choice
is overridden either by formatting (initializing) a volume, or during the
(quick) validation that is triggered if a volume becomes available to the FFS.
\smallskip{}

During formatting, the flavour is taken from {\tt dp\_Arg2} of the {\tt
  ACTION\_FORMAT}\key{ACTION\_FORMAT} packet. If {\tt dp\_Arg2} is none of known FFS flavours
from table~\ref{table:ffsflavours}, the currently active flavour remains in
force and is used to initialize the disk structure. If the FFS did not adjust its
flavour from accessing a previous volume, this remains the value from
{\tt de\_DosType}.
\smallskip{}

During disk insertion, or if a volume becomes accessible to the FFS by other
means such as mounting it or uninhibiting a volume through
{\tt ACTION\_INHIBIT}\key{ACTION\_INHIBIT}, the FFS reads the flavour from
the first long-word of the \emph{boot block}, even if this block is placed
on a hard-disk and not actually used for booting. It is found at sector

\[
\mbox{\tt BootBlock} = \mbox{\tt de\_LowCyl} \times \mbox{\tt de\_Surfaces} \times
     \mbox{\tt de\_BlocksPerTrack}
\]

of the device. Note that this is not necessarily the sector~0 if the volume
is a partition of a hard-disk. The remaining data of the boot block is not
used by the FFS but, at least for floppy disks, for bootblock booting which
is described in mored detail in~\cite{rkrmdev}.

\subsection{Disk Keys and Sectors}

Except for the boot block, the FFS does not address sectors through their
physical sector number, but due to their \emph{key}, which addresses data on
disk relative to the start of the partition in blocks, and not sectors. The
relation between the physical sector~$S$ and the key~$K$ is given by the following
equation:

\[
S = \mbox{\tt de\_LowCyl} \times \mbox{\tt de\_Surfaces} \times
     \mbox{\tt de\_BlocksPerTrack} + K \times \mbox{\tt
       de\_SectorPerBlock}
\]

In particular, the boot block has therefore the key~0. The sector number is
used directly for the ``direct SCSI'' transfer which is enabled by the {\tt
  ENVF\_SCSIDIRECT} flag in the {\tt de\_Interleave} element of the
environment vector.
\smallskip{}

For the default trackdisk-like transfer, exec device drivers expect a byte
offset instead of a sector, which is computed by multiplying $S$ by
$\mbox{\tt de\_SizeBlock} \times 4$. The additional factor of~4 is because
{\tt de\_SizeBlock} is in units of long-words and not a byte count.
\smallskip{}

Even though {\tt de\_SizeBlock} and {\tt de\_SectorPerBlock} could be any
number, the FFS, and likely many other file systems, only accept powers of
two here. Thus, any multiplication or division by these numbers are easily
implementable as shifts.

\subsection{The Root Block}

The Root Block represents the root directory of a volume and contains the
creation date and the volume name. It is placed in the middle of the volume
at key

\[
\left\lfloor \frac{\mbox{\tt de\_Reserved} + 
\left\lfloor \frac{(\mbox{\tt \small de\_HighCyl} - \mbox{\tt \small de\_LowCyl} +
  1) \times \mbox{\tt \small de\_Surfaces} \times
        \mbox{\tt de\_BlocksPerTrack}}{\mbox{\tt de\_SectorPerBlock}}\right\rfloor - 1}{2} \right\rfloor
\]

Note that the element name {\tt de\_BlocksPerTrack} is actually misleading
as this the size of a track in (physical) sectors and not in (logical)
blocks or keys. The division by {\tt de\_SectorPerBlock} computes from the
sector index a key. The brackets $\lfloor \cdot \rfloor$ indiciate rounding
down to the next integer.
\smallskip{}

The structure of the root block is as follows:

\begin{rkrmtabular}{FFS Root Block} \label{table:rootblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt 0       & header key, always 0 in root \\ \hline
2          & \tt 0       & highest sequence number, always 0 in root \\ \hline
3          & \tt HTSize  & entries in the hash table = Block size - 56 \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Hash    & hash chains for objects in the root \\ \hline
L-50       & \tt BMFlag  & -1 if Bitmap is valid \\ \hline
L-49\ldots & \tt BMKeys  & keys of the bitmap \\ \hline
L-24       & \tt BMExt   & key of the bitmap extension block \\ \hline
L-23       & \tt Days    & \multirow{3}{*}{timestamp of last directory change} \\ \cline{1-2}
L-22       & \tt Mins    & \\ \cline{1-2}
L-21       & \tt Ticks   & \\ \hline
L-20\ldots & \tt Name    & volume name as BSTR \\ \hline
L-12       & \tt 0       & reserved for future use \\ \hline
L-11       & \tt 0       & reserved for future use \\ \hline
L-10       & \tt Days    & \multirow{3}{*}{timestamp of last volume change} \\ \cline{1-2}
L-9        & \tt Mins    & \\ \cline{1-2}
L-8        & \tt Ticks   & \\ \hline
L-7        & \tt Days    & \multirow{3}{*}{volume creation time} \\ \cline{1-2}
L-6        & \tt Mins    & \\ \cline{1-2}
L-5        & \tt Ticks   & \\ \hline
L-4        & \tt 0       & reserved for future use \\ \hline
L-3        & \tt 0       & reserved for future use \\ \hline
L-2        & \tt DCache  & key of directory cache block if used \\ \hline
L-1        & \tt SecType & shall be 1, this is the BPCL constant ST.ROOT \\ \hline
\end{longtable}
\end{rkrmtabular}

Each entry in the above table is 4 bytes, i.e. one long-word large. As the
FFS supports multiple block sizes, some elements of this structure are
placed relative to the end of the block. Such element are indicated in the
above table as $L-x$ where $L$ is the block size in long works, i.e.

\[
L = \mbox{\tt de\_SizeBlock} \times \mbox{\tt de\_SectorPerBlock}
\]

The notation $\ldots$ indicates that the corresponding element extends over
multiple long-words. In particular, the list of hash-keys is a variably
sized number of long-words large, it always extends over $L-56$ longs.
\medskip{}

The block type is indicated by {\tt Type} and {\tt SecType}. For the root
block, these elements shall be $2$ and $1$, respectively.
\smallskip{}

{\tt HTSize} is the number of hash keys stored in the root block. The FFS
stores in the root block $L-56$ hash keys, from offset $6$ to $L-51$.
\smallskip{}

{\tt Chksum} is a checksum over the block. Its value is chosen such that the
long-word sum over all long-words, including the checksum, is zero.
\smallskip{}

{\tt Hash} stores the hash-chain of all objects in the root directory. The
FFS computes for each file system object a \emph{hash key} that is derived
from its name. As multiple objects can have the same hash and thus hash
conflicts may arise, all objects of the same hash are kept in a singly
linked list. The head of each list is kept in the {\tt Hash} array.
\smallskip{}

How the FFS computes the hash key from the name depends on the FFS
flavour. The following algorithm computes the hash key from the object name,
represented as a BSTR, i.e. the first character is the length of the string:

\begin{verbatim}
ULONG ComputeHash(UBYTE *name)
{
ULONG size = *name++; /* String size, this is a BSTR */
ULONG hash = size;    /* Initial hash is string length */

  while(size) {
   ULONG c = *name++;
   /* Is this an international flavour? */
   if (isInternational) {
    if (c != 0xf7 && ((c >= 0xe0 && c<= 0xfe) || 
                      (c >= 0x61 && c <= 0x7a))) {
     c -= 0x20; /* make upper case */
    }
   } else if (c >= 0x61 && c <= 0x7a) {
     c -= 0x20; /* make upper case */
   }
   hash = (hash * 13 + c) & 0x7ff;
  }
  return hash % HTSize;
}
\end{verbatim}

In the above, {\tt HTSize} is the value of the element of the same name in
the disk root block. As seen from the code, the non-international versions
of the FFS only convert the ASCII characters between 'a' and 'z' to upper
case, whereas the international version performs this conversion also for
all characters in the latin-1 character set. The FFS \emph{does not} use the
\emph{utility.library} for the upper-case conversion and thus hashing does
not depend on the selected locale. However, it depends on the latin-1
encoding and will not map characters correctly for many other
encodings. Latin-15 only replaces the international currency symbol with the
Euro-sign which is outside the range of characters that are converted to
upper case. It therefore also works correctly for this encoding.
\medskip{}

{\tt BMFlag} is {\tt DOSTRUE} in case the bitmap is valid. If the quick
validation on disk insertion finds that this element is~0, then the disk
status is set to non-validated and the bitmap is recomputed through a
complete disk scan. The bitmap keeps information on which blocks of the
volume are allocated and which are free.
\smallskip{}

{\tt BMKeys} is an array containing the keys of the bitmap blocks. How many
bitmap blocks are required to represent the bitmap depends on the size of
the volume and the size of a bitmap block. Unused keys remain~0.
\smallskip{}

{\tt BMExt} is the key of a bitmap extension block if the above bitmap array
is not sufficient to represent all blocks of the volume.
\smallskip{}

The elements at offsets $L-23$ to $L-21$ form a {\tt DateStamp} structure as
specified in section~\ref{sec:dates}. The date and time there indicate the
last change within the root directory.
\smallskip{}

{\tt Name} is the volume name, encoded as BSTR; the first character is
therefore the size of the name. This element is 8 long-words large and thus
limits the volume name to 30 characters (one extra character is reserved,
even though there would be sufficient space for 31 characters).
\smallskip{}

The elements at offsets $L-10$ to $L-8$ form a {\tt DateStamp} structure
that is updated on every change of the volume.
\smallskip{}

The elements at offsets $L-7$ to $L-5$ are also a {\tt DateStamp} structure
that represent the time and date at which the volume was initialized. The
packet {\tt ACTION\_SERIALIZE\_DISK} updates this date, too, but it remains
otherwise unchanged.
\smallskip{}

{\tt DCache} is the key of the directory cache list of blocks. It is only
used for the flavours of the FFS that utilize such a cache.
\smallskip{}

Unlike user directories, the root block lacks a list of hard-links that
points to it. This has the consequence that the FFS does not allow to create
hard-links to the root directory of a volume.

\subsection{The User Directory Block}

The user header block represents a sub-directory of the
volume root, or another user directory. It is enqueued in one of the
hash-chains of the root block or its parent user directory block. This block
exists in multiple variants, depending on the flavour of the
FFS. Table~\ref{table:userdirblock} applies to all FFS variants except the
long-file variants {\tt DOS\textbackslash{}06} and {\tt
  DOS\textbackslash{}07}.

\begin{rkrmtabular}{FFS User Header Block} \label{table:userdirlock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt 0       & reserved for future use \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Hash    & hash chains for objects in the directory \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt 0       & reserved for future use \\ \hline
L-46\ldots & \tt Comment & directory comment as BSTR \\ \hline
L-26\ldots & \tt 0       & reserved for future use \\ \hline
L-23       & \tt Days    & \multirow{3}{*}{timestamp of last directory change} \\ \cline{1-2}
L-22       & \tt Mins    & \\ \cline{1-2}
L-21       & \tt Ticks   & \\ \hline
L-20\ldots & \tt Name    & directory name as BSTR \\ \hline
L-12       & \tt NameX1  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-11       & \tt 0       & reserved for future use \\ \hline
L-10       & \tt BckLink & key of first hard-link to this object \\ \hline
L-9\ldots  & \tt NameX2  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt DCache  & key of directory cache block if used \\ \hline
L-1        & \tt SecType & shall be 2, setthis is the BCPL constant ST.USERDIR \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} is the primary type of this block. It is always~2, which is the
BCPL constant {\tt T.SHORT}
\smallskip{}

{\tt OwnKey} is the key of this object, i.e. it is the block number of this
block itself.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Hash} contains for user directories all the hash keys of the file
system objects contained within.
\smallskip{}

{\tt OwnerID} is reserved for the owner ID of this directory that can be set
with {\tt ACTION\_SET\_OWNER}. As the FFS has no means to validate the
directory owner, this element does not bear any practical meaning.
\smallskip{}

{\tt PrtBits} are the protection bits of this directory. The FFS actually
ignores the protection bits on the directory, but stores the value here anyhow.
\smallskip{}

{\tt Comment} contains a potential comment for this directory. The comment
is represented as a BSTR with the comment length in the first
character. There is room for 80 bytes, i.e. the maximum comment size is
79 characters.
\smallskip{}

The elements at offset $L-23$ to $L-21$ form a {\tt DateStamp} structure
that identifies the timestamp of the last change of this directory.
\smallskip{}

{\tt Name} is the name of this directory encoded as BSTR with the name
length in the first byte; even though~32 bytes are available here, the FFS
reserves one character, thus limiting the maximal directory name size to~30.
\smallskip{}

{\tt NameX1} and {\tt NameX2} are name extensions that are used by the {\tt
  DOS\textbackslash{}08} flavour of the FFS. They add additional~24 bytes of
storage for the directory name. Again, one character is reserved, limiting
the maximum directory name size for this variant to~54. The directory name
extends from {\tt Name}, then overflows into {\tt NameX1} and from there to
{\tt NameX2}.
\smallskip{}

{\tt BckLink} is the key of the first hard link to this directory. The link
of this key replaces the original directory header block in case the
directory itself is deleted, and then is converted from a link to a
directory.
\smallskip{}

{\tt NxtHash} is the key of the next object using the same hash key as this
directory itself.
\smallskip{}

{\tt Parent} is the key of the parent directory, or the key of the root
block in case this directory is directly in the volume root.
\smallskip{}

{\tt DCache} is the key of the first directory cache block. This key is only
used for FFS flavours with directory caching enabled. Otherwise, it stays~0.
\smallskip{}

{\tt SecType} along with {\tt Type} identifies the type of this block. The
value of this element shall be~2, identifying this as a user directory
block.
\medskip{}

For the long file-name enabled flavours of the FFS, namely {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07}, this block looks
somewhat different:

\begin{rkrmtabular}{Long-Filename FFS Directory User Header Block} \label{table:userdirblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt 0       & reserved for future use \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Hash    & hash chains for objects in the directory \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt 0       & reserved for future use \\ \hline
L-46\ldots & \tt NaC     & name and comment BSTR \\ \hline
L-18       & \tt CmtBlk  & key of comment block if necessary \\ \hline
L-17       & \tt 0       & reserved for future use \\ \hline
L-16       & \tt 0       & reserved for future use \\ \hline
L-15       & \tt Days    & \multirow{3}{*}{timestamp of last directory change} \\ \cline{1-2}
L-14       & \tt Mins    & \\ \cline{1-2}
L-13       & \tt Ticks   & \\ \hline
L-12       & \tt 0       & reserved for future use \\ \hline
L-11       & \tt 0       & reserved for future use \\ \hline
L-10       & \tt BckLink & key of first hard-link to this object \\ \hline
L-9\ldots  & \tt 0       & reserved for future use \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt DCache  & key of directory cache block if used \\ \hline
L-1        & \tt SecType & shall be 2, setthis is the BCPL constant ST.USERDIR \\ \hline
\end{longtable}
\end{rkrmtabular}

Compared to the regular directory header block, the time stamp of the last
modification date is relocated to offsets $L-15$ and following, and the name
and comment field is replaced by a new field at offset $L-46$.
\smallskip{}

{\tt NaC} contains both the file name and file comment as two BSTRs,
directly placed next to each other. The file name comes first, followed by
the comment. This element is capable of storing 112 bytes, but the FFS
reserves one byte making in total 110 bytes available. In case the comment
is too long and cannot be placed in this element, an additional comment
block is created keeping only the comment, and this element then only keeps
the file name.
\smallskip{}

{\tt CmtBlk} is the key of the comment block, keeping the file comment if
the {\tt NaC} element is too short. If no comment block is needed, this
element is~0.

\subsection{The File Header Block}

The file header block represents a file in a directory or the volume
root. It is enqueued in one of the hash-chains of the root block or its
parent user directory block. This block exists in multiple variants,
depending on the flavour of the FFS. Table~\ref{table:fileheaderblock} applies
to all FFS variants except the long-file variants {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07}.

\begin{rkrmtabular}{FFS File Header Block} \label{table:fileheaderblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt BlkCnt  & number of data block keys included \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt Data1st & first data block of the file \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt DataBlk & first $L-56$ data blocks of the file \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt Size    & size of the file in bytes \\ \hline
L-46\ldots & \tt Comment & file comment as BSTR \\ \hline
L-26\ldots & \tt 0       & reserved for future use \\ \hline
L-23       & \tt Days    & \multirow{3}{*}{timestamp of last file change} \\ \cline{1-2}
L-22       & \tt Mins    & \\ \cline{1-2}
L-21       & \tt Ticks   & \\ \hline
L-20\ldots & \tt Name    & directory name as BSTR \\ \hline
L-12       & \tt NameX1  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-11       & \tt 0       & reserved for future use \\ \hline
L-10       & \tt BckLink & key of first hard-link to this object \\ \hline
L-9\ldots  & \tt NameX2  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt FileExt & key of first file extension block \\ \hline
L-1        & \tt SecType & shall be -3, this is the BCPL constant ST.FILE \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} is the primary type of this block. It is always~2, which is the
BCPL constant {\tt T.SHORT}
\smallskip{}

{\tt OwnKey} is the key of this object, i.e. it is the block number of this
block itself.
\smallskip{}

{\tt BlkCnt} is the number of occupied data block keys included in this block. Due to
the limited number of slots, this number is smaller or equal than $L-56$.
\smallskip{}

{\tt Data1st} is the key of the first data block of the file. This data
block is actually made available twice, once here, and once again at offset
$L-49$. Probably the key at this offset was historically used for sequential
access into the file, whereas the block list at offset~$L-6$ following were
used for random access.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt DataBlk} is an array containing the first $L-56$ data blocks of the
file. The array is filled from its bottom-end, i.e. $L-49$ contains the
key of first data block, $L-50$ the second key and so on. If this array
overflows, additional blocks are in one or more file extension blocks
chained at $L-2$.
\smallskip{}

{\tt OwnerID} is reserved for the owner ID of this file that can be set
with {\tt ACTION\_SET\_OWNER}. As the FFS has no means to validate the
file owner, this element does not bear any practical meaning.
\smallskip{}

{\tt PrtBits} are the protection bits of the file, encoded as in
section~\ref{sec:fib}. The four least-significant bits corresponding to the
readable, writable, executable and deletable features are stored inverted,
i.e. a bit being~0 indicates that the corresponding feature is
available. This is the same encoding as in the {\tt FileInfoBlock}
structure.
\smallskip{}

{\tt Comment} contains a potential comment for this file. The comment
is represented as a BSTR with the comment length in the first
character. There is room for 80 bytes, i.e. the maximum comment size is
79 characters.
\smallskip{}

The elements at offset $L-23$ to $L-21$ form a {\tt DateStamp} structure
that identifies the timestamp of the last change of this file.
\smallskip{}

{\tt Name} is the name of this file encoded as BSTR with the name length in
the first byte; even though~32 bytes are available here, the FFS reserves
one character, thus limiting the maximal file name size to~30 characters.
\smallskip{}

{\tt NameX1} and {\tt NameX2} are name extensions that are used by the {\tt
  DOS\textbackslash{}08} flavour of the FFS. They add additional~24 bytes of
storage for the file name. Again, one character is reserved, limiting
the maximum file name size for this variant to~54. The file name
extends from {\tt Name}, then overflows into {\tt NameX1} and from there to
{\tt NameX2}.
\smallskip{}

{\tt BckLink} is the key of the first hard link to this file. The link
of this key replaces the original directory header block in case the
file itself is deleted, and then is converted from a link to a file.
\smallskip{}

{\tt NxtHash} is the key of the next object using the same hash key as this
directory itself.
\smallskip{}

{\tt Parent} is the key of the directory containing this file, or the key of
the root block in case this file is directly in the volume root.
\smallskip{}

{\tt FileExt} is the key of the first file extension block. This key is only
used if the file requires more than $L-56$ blocks. Otherwise, it stays~0.
\smallskip{}

{\tt SecType} along with {\tt Type} identifies the type of this block. The
value of this element shall be~-3, identifying this as file header block.
\medskip{}

For the long file-name enabled flavours of the FFS, namely {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07}, this block looks
somewhat different:

\begin{rkrmtabular}{Long-Filename FFS File Header Block} \label{table:longfileheaderblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt HighSeq & total number of blocks occupied \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt Data1st & first data block of the file \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt DataBlk & first $L-56$ keys of data blocks \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt 0       & reserved for future use \\ \hline
L-46\ldots & \tt NaC     & name and comment BSTR \\ \hline
L-18       & \tt CmtBlk  & key of comment block if necessary \\ \hline
L-17       & \tt 0       & reserved for future use \\ \hline
L-16       & \tt 0       & reserved for future use \\ \hline
L-15       & \tt Days    & \multirow{3}{*}{timestamp of last file change} \\ \cline{1-2}
L-14       & \tt Mins    & \\ \cline{1-2}
L-13       & \tt Ticks   & \\ \hline
L-12       & \tt 0       & reserved for future use \\ \hline
L-11       & \tt 0       & reserved for future use \\ \hline
L-10       & \tt BckLink & key of first hard-link to this object \\ \hline
L-9\ldots  & \tt 0       & reserved for future use \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt FileExt & key of first file extension block \\ \hline
L-1        & \tt SecType & shall be 2, setthis is the BCPL constant ST.USERDIR \\ \hline
\end{longtable}
\end{rkrmtabular}

Compared to the regular file header block, the time stamp of the last
modification date is relocated to offsets $L-15$ and following, and the name
and comment field is replaced by a new field at offset $L-46$.
\smallskip{}

{\tt NaC} contains both the file name and file comment as two BSTRs,
directly placed next to each other. The file name comes first, followed by
the comment. This element is capable of storing 112 bytes, but the FFS
reserves one byte making in total 110 bytes available. In case the comment
is too long and cannot be placed in this element, an additional comment
block is created keeping only the comment, and this element then only keeps
the file name.
\smallskip{}

{\tt CmtBlk} is the key of the comment block, keeping the file comment if
the {\tt NaC} element is too short. If no comment block is needed, this
element is~0.

\subsection{The Soft- and Hard-Link Block}

The soft- and hard-link block represent a soft-link or a hard-link to
another file system object. Similar to the file header and user directory
blocks, this block exists in two variants,
depending on the flavour of the FFS. Table~\ref{table:linkblock} applies
to all FFS variants except the long-file variants {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07}.

\begin{rkrmtabular}{FFS Link Block} \label{table:linkblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt 0       & reserved for future use \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Target  & link target for soft-links \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt 0       & reserved for future use \\ \hline
L-46\ldots & \tt Comment & link comment as BSTR \\ \hline
L-26\ldots & \tt 0       & reserved for future use \\ \hline
L-23       & \tt Days    & \multirow{3}{*}{timestamp of link creation} \\ \cline{1-2}
L-22       & \tt Mins    & \\ \cline{1-2}
L-21       & \tt Ticks   & \\ \hline
L-20\ldots & \tt Name    & link name as BSTR \\ \hline
L-12       & \tt NameX1  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-11       & \tt Link    & key of link target for hard-links \\ \hline
L-10       & \tt BckLink & key of next hard-link to the same object \\ \hline
L-9\ldots  & \tt NameX2  & name extension for {\tt DOS\textbackslash08} \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt 0       & reserved for future use \\ \hline
L-1        & \tt SecType & identifies the type of the link \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} is the primary type of this block. It is always~2, which is the
BCPL constant {\tt T.SHORT}
\smallskip{}

{\tt OwnKey} is the key of this object, i.e. it is the block number of this
block itself.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Target} is the path of the link target for soft-links. This is stored
as {\tt NUL}-terminated C-string, not as BSTR\footnote{The information
in~\cite{Bantam} that this is a BSTR is incorrect}. The maximum path name
that can be stored here is $(L-56)\times 4 - 1$ characters
long. Unfortunately, all versions of the FFS currently do not check the
maximum link name and damage the file system structure if this path is too
long, though in a default floppy with 512 bytes per sector, this element
leaves room for paths up to 287 characters.
\smallskip{}

{\tt OwnerID} is reserved for the owner ID of this link that can be set
with {\tt ACTION\_SET\_OWNER}. As the FFS has no means to validate the
link owner, this element does not bear any practical meaning.
\smallskip{}

{\tt PrtBits} are the protection bits of the link, encoded as in
section~\ref{sec:fib}. However, the practical value of these protection bits
is zero as locking a link provides a lock to the linked object, and thus the
protection bits stored here are not actually checked and neither accessible,
except by walking a directory through {\tt ACTION\_EXAMINE\_NEXT} or
{\tt ACTION\_EXAMINE\_ALL}.
\smallskip{}

{\tt Comment} contains a potential comment for this link. The comment is
represented as a BSTR with the comment length in the first character. There
is room for 80 bytes, i.e. the maximum comment size is 79
characters. Comments of links \emph{can} be set with
{\tt ACTION\_SET\_COMMENT} as the FFS does not attempt to follow the link.
\smallskip{}

The elements at offset $L-23$ to $L-21$ form a {\tt DateStamp} structure
that identifies the timestamp of the creation of the link. For hard-links,
this element bears no practical meaning as even an {\tt ACTION\_SET\_DATE}
will update the date of the link target and not the link itself. An attempt
to change the date of a soft-link creates an {\tt ERROR\_IS\_SOFT\_LINK} and
thus instructs the client of the FFS to rather redirect the request to the
linked target. Thus, this date may potentially be seen when walking a
directory, but it cannot be changed.
\smallskip{}

{\tt Name} is the name of this file encoded as BSTR with the name
length in the first byte; even though~32 bytes are available here, the FFS
reserves one character, thus limiting the maximal file name size.
\smallskip{}

{\tt NameX1} and {\tt NameX2} are name extensions that are used by the {\tt
  DOS\textbackslash{}08} flavour of the FFS. They add additional~24 bytes of
storage for the directory name. Again, one character is reserved, limiting
the maximum name for this variant to~54. The link name
extends from {\tt Name}, then overflows into {\tt NameX1} and from there to
{\tt NameX2}.
\smallskip{}

{\tt Link} is the key of the file header or user directory key for
hard-links. For soft-links, this element is not used and set to~0.
\smallskip{}

{\tt BckLink} is the key to the next hard-link to the same link target, or~0
if there is no further hard-link to the same target. Thus, all links to the
same target are chained through {\tt BckLink}.
\smallskip{}

{\tt NxtHash} is the key of the next object using the same hash key as this
directory itself.
\smallskip{}

{\tt Parent} is the key of the directory containing this link, or the key of
the root block in case this file is directly in the volume root.
\smallskip{}

{\tt SecType} along with {\tt Type} identifies the type of this block. This
can be either~$-4$, corresponding to {\tt ST.LINKFILE} for a hard-link to a
file, or~$4$ ({\tt ST.LINKDIR}) for a hard-link to a directory, or~3,
corresponding to {\tt ST.SOFTLINK} for soft-links.
\medskip{}

For the long file-name enabled flavours of the FFS, namely {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07}, this block looks
somewhat different:

\begin{rkrmtabular}{Long-Filename FFS Link Block} \label{table:longlinkblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 2, this is the BCPL constant T.SHORT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt 0       & reserved for future use \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Target  & link target for soft-links \\ \hline
L-50       & \tt 0       & reserved for future use \\ \hline
L-49       & \tt Owner   & reserved for owner ID \\ \hline
L-48       & \tt PrtBits & protection bits as in section~\ref{sec:fib} \\ \hline
L-47       & \tt 0       & reserved for future use \\ \hline
L-46\ldots & \tt NaC     & name and comment BSTR \\ \hline
L-18       & \tt CmtBlk  & key of comment block if necessary \\ \hline
L-17       & \tt 0       & reserved for future use \\ \hline
L-16       & \tt 0       & reserved for future use \\ \hline
L-15       & \tt Days    & \multirow{3}{*}{timestamp of last directory change} \\ \cline{1-2}
L-14       & \tt Mins    & \\ \cline{1-2}
L-13       & \tt Ticks   & \\ \hline
L-12       & \tt 0       & reserved for future use \\ \hline
L-11       & \tt Link    & key of link target for hard-links \\ \hline
L-10       & \tt BckLink & key of next hard-link to the same object \\ \hline
L-9\ldots  & \tt 0       & reserved for future use \\ \hline
L-4        & \tt NxtHash & next key of the same hash \\ \hline
L-3        & \tt Parent  & key of the parent directory \\ \hline
L-2        & \tt 0       & reserved for future use \\ \hline
L-1        & \tt SecType & identifies the type of the link \\ \hline
\end{longtable}
\end{rkrmtabular}

Compared to the regular link block, the time stamp of the last modification
date is relocated to offsets $L-15$ and following, and the name and comment
field is replaced by a new field at offset $L-46$.
\smallskip{}

{\tt NaC} contains both the link name and file comment as two BSTRs,
directly placed next to each other. The link name comes first, followed by
the comment. This element is capable of storing 112 bytes, but the FFS
reserves one byte making in total 110 bytes available. In case the comment
is too long and cannot be placed in this element, an additional comment
block is created keeping only the comment, and this element then only keeps
the file name.
\smallskip{}

{\tt CmtBlk} is the key of the comment block, keeping the file comment if
the {\tt NaC} element is too short. If no comment block is needed, this
element is~0.

\subsection{The File Extension Block}

The file extension block keeps keys of additional file data blocks in case
the $L-56$ keys in the file header block are not sufficient to keep all
keys. It looks as follows:

\begin{rkrmtabular}{File Extension Block} \label{table:fileextblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 16, this is the BCPL constant T.LIST \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt BlkCnt  & number of data block keys included \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt DataBlk & next $L-56$ keys of data blocks \\ \hline
L-50\ldots & \tt 0       & reserved for future use \\ \hline
L-3        & \tt Parent  & key of the file header block \\ \hline
L-2        & \tt NextExt & key of next file extension block \\ \hline
L-1        & \tt SecType & shall be -3, this is the BPCL constant ST.FILE  \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} is the primary type of this block. It is always~16, which is the
BCPL constant {\tt T.LIST}
\smallskip{}

{\tt OwnKey} is the key of this block itself.
\smallskip{}

{\tt BlkCnt} is the number of occupied data block keys included in this block. Due to
the limited number of slots, this number is smaller or equal than $L-56$.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt DataBlk} is an array containing the next $L-56$ data blocks of the
file. The array is filled from its bottom-end, i.e. $L-49$ contains the key
of first data block referenced in this extension block, $L-50$ the second
key and so on. If this array overflows, additional blocks are in another
file extension block chained at $L-2$.
\smallskip{}

{\tt Parent} is the key of the file header block of the file whose data
block keys are extended by this block.
\smallskip{}

{\tt FileExt} is the key of the next file extension block if this block is
not sufficient to keep all data block keys. Otherwise, it is~0.
\smallskip{}

{\tt SecType} along with {\tt Type} identifies the type of this block. The
value of this element shall be~-3, identifying this block as belonging to a
file.

\subsection{The Bitmap Extension Block}

The bitmap extension block keeps the keys of additional bitmap blocks in case
the number of bitmap keys in the root block (25, namely) are not sufficient.
This block has the following structure:

\begin{rkrmtabular}{Bitmap Extension Block} \label{table:bitmapextensionblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0\ldots    & \tt BMKeys  & additional $L-1$ bitmap keys \\ \hline
L-1        & \tt BMNext  & key of another bitmap extension block \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt BMKeys} is an array of $L-1$ keys, each of contains a bitmap for the
subsequent part of the volume. The slots in this block are allocated top to
bottom, with non-used entries set to~0.
\smallskip{}

{\tt BMNext} is the key of another extension block if this extension block is
not sufficient. It is~0 in case this is the last bitmap extension block.

\subsection{The Comment Block}

This block keeps a file comment for the long filename FFS flavours {\tt
  DOS\textbackslash{}06} and {\tt DOS\textbackslash{}07} in case the file
header, user directory or link block does not provide sufficient room to
keep both the file name and the file comment.

\begin{rkrmtabular}{Comment Block} \label{table:commentblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 64, this is T.COMMENT \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt Parent  & key of the header block \\ \hline
3          & \tt 0       & reserved for future use \\ \hline
4          & \tt 0       & reserved for future use \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Comment & object comment as BSTR \\ \hline
26\ldots   & \tt 0       & reserved for future use \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} identifies the type of this block. The value placed here shall
be~64, corresponding to the constant T.COMMENT.
\smallskip{}

{\tt OwnKey} is the key of this block itself.
\smallskip{}

{\tt Parent} is the key of the file header, user directory or link block
to which the comment in this block applies and which is extended by this
block.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Comment} is the comment, stored as a BSTR with the first character
containing its size. This element is 80 bytes large, sufficient for comments
of 79 characters.
\smallskip{}

The remaining bytes of this block shall be~0 and remain available for future
extension.

\subsection{The Directory Cache Block}

This block type is only used by the directory cache flavours of the FFS,
namely {\tt DOS\textbackslash{}04} and {\tt DOS\textbackslash{}05}. It
keeps, in a more compact form, the contents of directories. This block looks
as follows:

\begin{rkrmtabular}{Directory Cache Block} \label{table:cacheblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 33, this is T.DIRLIST \\ \hline
1          & \tt OwnKey  & key of this block (self-reference) \\ \hline
2          & \tt Parent  & key of the user directory block \\ \hline
3          & \tt NumNtry & number of entries in this block \\ \hline
4          & \tt NextBlk & key of the next directory cache block \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Entries & Directory content (see below) \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} identifies the type of this block; the constant put here is
actually {\tt DIRLIST\_KEY} = 32 or'd with the version of the directory
cache data, which is currently~1.
\smallskip{}

{\tt OwnKey} is the key of this block itself.
\smallskip{}

{\tt Parent} is the key of the directory header block of the user directory
cached here, or the key of the root block if this is the cache of the volume
root directory.
\smallskip{}

{\tt NumNtry} is the number of directory entries cached in this block. Each
entry has a structure as indicated in table~\ref{table:dircachenetry}. Such
entries cannot extend over block boundaries; if a new entry does not fit
entirely into a block, another directory cache block is allocated. A
directory cache block may also contain~0 entries as these blocks are never
released. Thus, directory caches can grow very large, and they are only
rebuild when the disk requires full validation.
\smallskip{}

{\tt NextBlk} is the key of the next directory cache block for the same
directory, or~0 in case this is the last block.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Entries} contains the payload data of the directory cache. It consists
of zero or more entries of the following variably sized structure:

\begin{rkrmtabular}{Directory Cache Entry} \label{table:dircachenetry}
\begin{longtable}{|l|l|l|} \hline
{\bf Size} & {\bf Content} & {\bf Notes} \\ \hline \hline
32         & \tt Key     & key of the referenced object \\ \hline
32         & \tt Size    & size of the object in bytes \\ \hline
32         & \tt PrtBits & protection bits of the object \\ \hline
32         & \tt Owner   & owner ID of the object \\ \hline
16         & \tt Days    & \multirow{3}{*}{timestamp of last change} \\ \cline{1-2}
16         & \tt Mins    & \\ \cline{1-2}
16         & \tt Ticks   & \\ \hline
8          & \tt SecType & secondary type of the object \\ \hline
variable   & \tt Name    & object name as BSTR \\ \hline
variable   & \tt Comment & object comment as BSTR \\ \hline
pad(16)    & \tt padding & padding to 16-bit boundary \\ \hline
\end{longtable}
\end{rkrmtabular}

The elements of this structure are as follows:
\smallskip{}

{\tt Key} is the key of the file header block, the user directory block or
the link block, depending on the file system object to which this entry
belongs.
\smallskip{}

{\tt Size} is the byte size of the object, or~0 for links and directories.
\smallskip{}

{\tt PrtBits} are the protection bits as represented in the {\tt
  FileInfoBlock} structure.
\smallskip{}

{\tt Owner} is reserved for a 32-bit group and owner ID that can be set by
the {\tt ACTION\_SET\_OWNER} packet. However, as the FFS has no means to
verify access rights to an object, the purpose of this field remains opaque.
\smallskip{}

{\tt Days}, {\tt Mins} and {\tt Ticks} are the timestamp of the last time
the corresponding object was modified and a copy from the corresponding
header block provided by {\tt Key}. However, unlike there, only 16 bits are
available for each element. This is sufficient if the {\tt DateStamp()}
structure is normalized, i.e. each element is as small as possible.
\smallskip{}

{\tt SecType} is a copy from the {\tt SecType} element of the file, user
directory or link block indexed by {\tt Key}. All possible values can be
represented by a signed byte and are thus abbreviated here in an 8-bit
element.
\smallskip{}

{\tt Name} is a copy of the {\tt Name} element of the file, user directory
or link, though only the minimal number of bytes are copied, i.e. $N+1$
bytes for a file name of size~$N$. The first byte of {\tt Name} is its
length, i.e. it is a BSTR without {\tt NUL}-termination.
\smallskip{}

{\tt Comment} follows directly after the last byte of {\tt Name} and is a
copy of the {\tt Comment} element of the file, user directory or link block;
again, only the minimal amount of bytes are copied to the directory cache,
i.e. the length byte and the comment itself. This forms again a BSTR, not a
C string, and there is no {\tt NUL}-termination.
\smallskip{}

{\tt padding} is an optional padding byte to make the entire structure an
even number of bytes large such that the key of the next directory entry is
on an even address in memory.
\smallskip{}

The directory cache does not store the targets of hard-links or soft-links;
that is, if the contents of a directory of a cache-enabled file system is
listed, this information is gained from the regular directory structure.
\smallskip{}

Within a directory cache block, zero or more directory cache entries follow
each other; their count is provided by the {\tt NumNtry} element in the
directory cache block. If the FFS has to delete entries from the directory,
it moves entries within the current block upwards over the released
entry. In worst case, no entries remain in a directory cache block. Such
blocks are not released, but remain available to accept new entries.
\medskip{}

While the directory cache increases the performance of listing directory
contents, keeping the directory cache in sync with the regular directory
structure requires additional overhead as directory cache blocks need to be
allocated, filled, and entries be moved within the blocks.

\subsection{The Data Block}

Data blocks contain the payload data of files. It comes in two variants: The
``OFS'' variants of the FFS, namely {\tt DOS\textbackslash{}00}, {\tt
  DOS\textbackslash{}02}, {\tt DOS\textbackslash{}04} and {\tt
  DOS\textbackslash{}06} keep a lot of redundant information within the data
block that makes the file system structure very robust against media
corruption; however, this information needs to be stripped off before the
payload data is delivered to the FFS client, these variants are very slow.
\medskip{}

All remaining variants, including {\tt DOS\textbackslash{}08} only keep
payload data in the data blocks. This enables the FFS to directly transmit
data from the medium to the target buffer of the client if the {\tt
  de\_Mask} allows it. If the host adapter offers DMA, the CPU is not even
involved in copying the data and thus these variants of the FFS are faster,
though also less robust. However, modern media rarely corrupt data, unlike
floppy disks, and therefore are generally recommended. The OFS flavours are
therefore only useful for slow and unreliable data carriers.
\medskip{}

The following table describes the structure of an OFS data block:

\begin{rkrmtabular}{OFS Data Block} \label{table:ofsdatablock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 8, this is T.DATA \\ \hline
1          & \tt Header  & key of the file header \\ \hline
2          & \tt SeqNum  & sequence number of this block \\ \hline
3          & \tt Size    & data bytes in this block \\ \hline
4          & \tt NxtBlk  & next data block of this file \\ \hline
5          & \tt Chksum  & LW sum over block is 0 \\ \hline
6\ldots    & \tt Data    & payload data \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Type} is the primary type of this block. It is always~8, which is the
BCPL constant {\tt T.DATA}
\smallskip{}

{\tt Header} is the key of the file header block this file belongs to.
\smallskip{}

{\tt SeqNum} is the sequential number of this block within the file. The
first data block of the file has the sequential number~1, the next one"2 and
so on.
\smallskip{}

{\tt Size} is the number of valid bytes within this data block. Valid data
does not necessarily extend to the end of the block.
\smallskip{}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Data} is the actual payload data of the block. It consists of
{\tt Size} arbitrary bytes.
\medskip{}

The FFS data block does not have any structure, it contains only payload
data. This has the consequence that a disk scan, e.g. by a disk salvage
tool, cannot safely identify whether a block carries administrational
information of the disk, or is rather a data block that, by pure
coincidence, reassembles an administration block of one of the types listed
in this section. Various disk salvage tools fell into this pitfall
identifying blocks as adminstration blocks that were, actually, data blocks
allocated for a file.

\subsection{The Bitmap Block}

Bitmap blocks keep a bitmap --- one bit per key --- which keys are already
occupied for administrational or payload data, and which keys are still
free. Depending on the size of the volume, one or many bitmap blocks exist,
sometimes even so many that bitmap extension blocks are needed as the 25
keys available in the root block.
\smallskip{}

The structure of a bitmap block is as follows:

\begin{rkrmtabular}{Bitmap Block} \label{table:bitmapblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Chksum  & LW sum over block is 0 \\ \hline
1\ldots    & \tt Bitmap  & bitmap of avaiable blocks \\ \hline
\end{longtable}
\end{rkrmtabular}

{\tt Chksum} is the checksum over the entire block. It is chosen such that
the long-word sum over the entire block, including this element, is zero.
\smallskip{}

{\tt Bitmap} holds for every available key administrated by this bitmap a
bit that indicates whether that key is available or not. If the bit is~1,
the key is free, and if~0, the key is released.
\smallskip{}

Bits are addressed in groups of long-words such that the least-significant
bit of each long-word corresponds to the lowest key and the most significant
bit of a long-word to the highest key within this long-word. The least
significant bit of the long-word at offset~1 of the first bitmap of a volume
corresponds to the key {\tt de\_Reserved}, i.e. the reserved blocks at the
start of a volume \emph{are not} represented in the bitmap. As key~0
corresponds to the boot-block and this block keeps the flavour of the FFS,
and potentially boot code, {\tt de\_Reserved} cannot be~0 as otherwise the
FFS could allocate it as key, and thus overwrite parts of its administration
information. While the FFS could, in principle, always reserve key~0 for
such purpose, no such provisions are made.
\smallskip{}

Identifying whether a particular key is allocated is demonstrated by the
following algorithm: It takes the number of long words per block (e.g. 128
for a standard floppy disk, i.e. 512 bytes per block), the number of
reserved blocks, the key to investigate and the key of the root block. It
assumes that {\tt readKey()} brings the key provided by its argument to
memory, and that this function returns a pointer to an array of {\tt ULONG}s
representing the block contents:

\begin{verbatim}
/* Bring key to memory */
ULONG *readKey(ULONG key);

/* Check whether a particular key is allocated */
LONG isKeyAllocated(ULONG longsperblock,ULONG reservedblocks,
                    ULONG key,ULONG rootkey)
{
ULONG  keysperbitmap;
ULONG  bitmap;
ULONG  keyinbitmap;
ULONG  longoffset;
ULONG *block;

  /* compute the number of keys per bitmap */
  keysperbitmap = (longsperblock - 1) * 32;
  /* compute the bitmap index in all bitmaps */
  bitmap        = (key - reservedblocks) / keysperbitmap;
  /* compute the key within the bitmap */
  keyinbitmap   = (key - reservedblocks) % keysperbitmap;
  /* compute the LW offset within the bitmap */
  longoffset    = keyinbitmap / 32 + 1;
  /* compute the bit within the long */
  bitinlong     = keyinbitmap % 32;
  /* read the root block */
  block         = readKey(rootkey);

  /* Check whether the bitmap is linked in the root 
  ** block or not. The first 25 are
  */
  if (bitmap < 25) {
    /* Bring the proper keymap into memory */
    block = readKey(block[bitmap + BMKeys]);
  } else {
     LONG extension,keyoffset;
     /* Compute the extension block required, 
     ** and key offset within the extension block
     ** to the bitmap block.
     */
     extension = (bitmap - 25) / (longsperblock - 1);
     keyoffset = (bitmap - 25) % (longsperblock - 1);
     /* read the first extension block */
     block     = readKey(block[BMExt]);
     /* Follow the link chain of extension 
     ** blocks to find the right one
     */
     while(extension > 0) {
       block   = readKey(block[BMNext]); 
       extension--;
     }
     /* Now read the right bitmap */
     block     = readKey(block[keyoffset]);
  }

  /* check the bit corresponding to the key */  
  if (block[longoffset] & (1UL << bitinlong)) {
    return DOSTRUE; /* is allocated */
  } else {
    return DOSFALSE; /* is free */
  }
}
\end{verbatim}

\subsection{The Deleted Block}

The FFS also mark unused administration blocks as deleted to ensure that a
disk scan does not confuse them with a used block. This does not happen to
data blocks.

\begin{rkrmtabular}{Deleted Block} \label{table:deletedblock}
\begin{longtable}{|l|l|l|} \hline
{\bf Long-word Offset} & {\bf Content} & {\bf Notes} \\ \hline \hline
0          & \tt Type    & shall be 1, this is T.DELETED \\ \hline
1\ldots    & \tt junk    & whatever remained here \\ \hline
\end{longtable}
\end{rkrmtabular}

This makes it particularly easy for disk salvage tools to identify which
keys are actually still in active use and which have been scratched on
purpose.

\chapter{The AmigaDOS Shell}
The Shell is the command line interpreter of AmigaDOS and is a simple
language of itself. User applications can use services of the shell by
requesting it to interpet a shell script or launching a new shell in a
user-provided console window, then interpreting commands entered by the
user. The latter is called an \emph{interactive} shell, the former is
non-interactive.
\smallskip{}

The Shell is built into the ROM of the kickstart, even though AmigaDOS
is flexible enough to allow custom shells and make them available to user
applications. The Shell is also responsible for booting up the system by
executing the {\tt Startup-Sequence} script in the {\tt S:} assign.

\section{The Shell Syntax}

The Shell reads commands along with its arguments line by line from the
console or a script. Each line consists of at least one command upfront and
its arguments, where the arguments amongst each other and the command are
are separated by spaces. The command refers to a file within the
\emph{path}, a list of directories that can be adjusted by the user. It
always contains the current directory and the {\tt C:} assign, though
additional directories can be added or removed with the {\tt path} command
any time.
\smallskip{}

The following sections describe the Shell syntax in detail. Even though it
stems from the Tripos system, AmigaDOS added over the years features such as
variable substitution, compound commands including pipes, backtick expansion
and additional redirection operators. 

\subsection{Input/Output Redirection}

Commands receive from the shell an input and output stream, and a console
handler to which commands can refer by the special file name
{\tt *}. Optionally, they can be provided with an error stream through which
diagnostic messages are printed. The shell allows redirecting or creating
these streams by operators on the command line that shall also be separated
by the spaces from the arguments and the command.
\smallskip{}

The shell supports the following redirection operators:

\begin{itemize}[leftmargin=5em]
  \item[{\tt >}{\it path}] redirects the output of a command to a
    particular file, creating the file if it does not yet exist, or
    overwriting it if does.
  \item[{\tt >{}>}{\it path}] appends the output of a command to a
    file if the file already exists, or creates a the output file if it does
    not yet exist.
  \item[{\tt <}{\it path}] redirects the input of a command from an
    already existing file which must exist; otherwise, an error is
    indicated.
  \item[{\tt <{}<}{\it ind}] uses the current console or the shell
    script itself from which the command is run as input, line by line,
    until a line starting with {\tt ind} is found. The indicator can be
    choosen arbitrarily. A typical choice is {\tt EOF}. This avoids
    creating temporary files.
  \item[{\tt <>}{\it path}] redirects both the standard input and
    the standard output of the command to a path. The file must exist
    already, otherwise an error is indicated.
  \item[{\tt *>}{\it path}] redirects the error output of the command to the
    given path. If this path identifies an interactive stream (see
    section~\ref{sec:isinteractive}), such as a console, then the console
    process of the command is set to it as well. This will also redirect
    output of commands that prints errors to the {\tt *} file that
    is contacted for this special file name.
   \item[{\tt *>{}>}{\it path}] appends the error output of a command to a
     file, or creates a new file for error output if it does not yet
     exist. If the target file is interactive, the console process of the
     command is also updated.
   \item[{\tt *<>}] creates a standard error stream and redirects it to the
     standard output. If none of the three above redirection operators are
     present, then (unlike in other operating systems) the command
     \emph{does not} receive a standard error stream. What happens in such a
     case with error output is specific to the implementation of the
     command. The system error handling functions will still provide error
     output to the standard output as if an implicit {\tt *<>} would be
     present.
\end{itemize}

Where the redirection is placed within a command line does typically not
matter, e.g. wether it is directly following the command or placed at the
end of the command line. There are, however, three exceptions the shell
makes when parsing the command line:
\smallskip{}

For the {\tt Alias} and {\tt Run} command, redirections of the command
itself shall be placed directly following the command. The same applies if
the shell variable {\tt oldredirect} is set to {\tt on}. In the above cases,
redirections placed at a later point of the command line will become part of
the command line arguments. That is, for {\tt Run}, the command run in back
will redirect its streams rather than the streams of the {\tt Run} command,
and for {\tt Alias}, the redirection will become part of the alias and will
become active when the alias is expanded. The {\tt oldredirect} variable
will do likewise for all other commands, except that they will typically not
interpret redirection requests in a useful way and will instead take the
angle brackets as regular arguments.

\subsection{Compound Commands}

The Shell allows combining multiple commands on the command line, then
forming \emph{compound} commands. The following operators go \emph{between}
commands such that the last argument of the first command is directly to the
left of such an operator, and the next argument start to the right. As for
arguments, these operators need to be separated by arguments and commands
with blank spaces:

\begin{itemize}
  \item[{\tt |}] The vertical bar creates a pipe such that the standard
    output of the command to the left becomes the standard input of the
    command to its right. As some commands require an explicit file name
    they read data from, or they write data to, the pipe itself can be
    explicitly addressed through the {\tt PIPE:} file name, both for the
    reading and the writing end. Pipes require the Queue-Handler, which is
    mounted by the Kickstart during the system startup.
  \item[{\tt ||}] Two vertical bars concatenate the output of two commands
    together into one common stream which can then redirected to a common
    output\footnote{This syntax is different from the {\tt bash} operator
    that looks similar.}.
  \item[{\tt \&\&}] Sequences two commands, first executes the one to the
    left, and if its return value is below the {\tt FailAt} value, continues
    to execute the command to its right.
\end{itemize}

The brackets ``{\tt (}'' and ``{\tt )}'' group commands and execute the
grouped command in a separate process in a sub-shell. For this, both the
opening and closing bracket shall be separated by commands and arguments by
at least a single space as otherwise the shell interprets them as part of
the command or arguments. This provides logical grouping of commands into
compound commands.

\subsection{Unary Shell Operators}

In addition, the Shell recognizes two unary operators that do not stand
between commands, but only at their end or at the end of the command line.

\begin{itemize}
\item[\&] The ampersand operator works similar to the {\tt Run} command, it starts
  the command line within which it appears in background. The command will
  receive a new logical console, and its output and error streams will be
  redirected to this console, unless of course redirected explicitly to
  other files. Unfortunately, at this time, the ROM-based Console-Handler
  does not take advantage of this information and will simply merge the
  output of the process run back with that of the regular shell, though
  extended Console-Handlers use this information for job control and hold
  the output of the background process until made explicitly active.
\item[+] The plus operator shall only appear at the end of a command line.
  If it is present, it injects a line-feed and the following line of the
  current input of the shell into the argument line of the command. It thus
  forms an argument string that consists of multiple lines. Only very few
  commands can actually process a line-feed as part of their argument line,
  most will ignore all characters behind the first line feed. One particular
  command that supports such argument lines is {\tt Run}. It feeds its
  argument line unprocessed into a new non-interactive Shell as command
  stream, building it from a string using a technique similar to that
  explained in section~\ref{sec:stringstreams}. This sub-shell will thus
  receive a shell script as input which consists of multiple lines, and will
  execute the commands one after another.
\end{itemize}

\subsection{Quoting and Escaping}

To allow spaces and the above operators as parts of command names and
arguments, e.g. to handle file names containing spaces, the Shell allows
quoting. Blank spaces within double quotes (``{\tt "}'') become part of the
argument, and are not interpreted by the shell. A quote only starts a quoted
argument or command and is thus a functional element of the Shell if it is
preceeded by a blank space, quotes \emph{within} an otherwise unquoted
argument are literals and stand for itself. A quote, however, does terminate
a quoted string even if it is \emph{not} followed by a blank
space.
\smallskip{}

Within quotes, the Shell recognizes the asterisk ``{\tt *}'' as an escape
character, and only there. That is, the asterisk is a literal outside of
double quotes; for example, it is the file name that identifies the current
console, and as isolated character outside of quotes is not interpreted as
escape character. The escape sequences supported by the Shell can be roughly
broken up into two classes:
\smallskip{}

The first class, the legacy escape sequences, are recgonized and interpreted
by the Shell, but the actual substitution of the escape sequence by the
escaped character is left to the executing program and thus happen
\emph{outside} of the Shell:

\begin{itemize}
\item[{\tt *N}] The newline character, ASCII {\tt 0x0a}.
\item[{\tt *E}] The ESC character, ASCII {\tt 0x1b}. There is no escape
  sequence for the CSI control character {\tt 0x9b}, but there is a 7-bit
  equivalent sequence all terminals support, namely {\tt *E[}. The Shell
    does not establish this equivalence, but the console does.
\item[{\tt *"}] The double quote; a double quote escaped as such does not
  terminate the quoted argument, but represents the quote itself as part of
  the argument.
\item[{\tt **}] The asterisk itself.
\end{itemize}

As the Shell does not perform substitutions for the above sequences, they
can also appear within the command line of the executed program, which is
then responsible to perform the above substitutions correctly itself.
\smallskip{}

Proper interpretation and escape sequence substitution is ensured if the
command uses the {\tt ReadArgs()}\key{ReadArgs()} or {\tt
  ReadItem()}\key{ReadItem()} functions of the \emph{dos.library}. This
distribution of responsibilities has the inconvenient side effect that some
third-party argument parsers, e.g. the ones provided by some C compilers, do
not fully support the (admittedly unorthogonal) quotation and escaping rules
of the Shell and thus do not deliver the expected results.
\medskip{}

The second class of escape sequences is transparently substituted by the
Shell, and thus no additional burden arises for the executed program to
handle them\footnote{This inconsistency can probably be only understood in
historical contents as variable expansion and backtick substitution were
later Amiga specific extensions to the original Tripos Shell.}:

\begin{itemize}
\item[{\tt *\$}] The literal dollar sign. The non-escaped dollar sign is a
  syntax element that indicates variable expansion, see
  section~\ref{sec:variableexpansion}.
\item[{\tt *`}] The literal backtick. The non-escaped backtick is a
  syntactical element for command output substitution, see
  section~\ref{sec:backtick}.
\end{itemize}

\subsection{Variables and Variable Expansion} \label{sec:variableexpansion}

The AmigaDOS shell supports variables, both local to the shell and
system-global, and expands variables as part of the regular command line
parsing. A variable is indicated by a string starting with a dollar-sign
(``{\tt \$}'') and followed by alpha-numerical characters, i.e. 0-9, A-Z and
a-z. Variable names are case-insensitive. The lst character that is outside
this range terminates the variable name. 
\smallskip{}

An equivalent but more flexible way of referring to a variable is by
enclosing the variable name after the ``{\tt \$}'' sign in braces,
i.e. ``{\tt \$ \{{\it name}\}}'' within which all other characters are
allowed as components of the name as well.
\smallskip{}

Local variables are represented as entries in the {\tt pr\_LocalVars} list
that is part of the process structure that represents the Shell, see
section~\ref{sec:process}. When expanding variables, the Shell first checks
there for a variable of a matching name. Only if that fails, the Shell tests
for global variables. They are represented as files in the {\tt ENV:}
assign, which is typically an external link within the {\tt RAM:} device
copying elements from the {\tt ENVARC:} assign. That is, local variables
take priority over global variables.
\smallskip{}

Variables are substituted by the Shell \emph{before} the resulting argument
line is provided to the command, i.e. it is not necessary to expand
variables within commands. The Shell does not attempt to generate pairs of
double quotes to ensure that an expanded variable corresponds to a single
argument. In fact, if a variable contains spaces and it is not included in
double quotes, it will be seen in the expanded command line as multiple
arguments. However, if a variable contains asterisks or double quotes, and
the variable appears within double quotes, such asterisks or double quotes
are escaped by the Shell with an (additional) asterik as escape character to
ensure the resulting argument is represented appropriately.
\smallskip{}

If the variable name is started with ``{\tt \$?}'' instead of ``{\tt \$}'',
then the Shell will check whether the variable exists or not, and instead of
inserting its value, it will substitute the name by a~1 if the variable
exists, or by a~0 if it does not exist, i.e. is undefined. If a variable
reference starts with ``{\tt \$??}'', the Shell checks whether the variable
exists as \emph{global} variable, and if so, expands the entire reference
to~1, otherwise to~0. Finally, if the variable reference starts with ``{\tt
  \$!}'', the variable may contain control characters such as line feeds
that are included in the expansion. This binary expansion is only applicable
to global variables, and as potential control characters are injected into
the Shell tokenizer, it is necessary to include such binary expanded
variables in double quotes. This ensures that the Shell escapes the control
characters properly and makes them accessible to commands and their argument
parser.

\subsection{Backtick Expansion} \label{sec:backtick}

After variable expansion, the Shell checks the command line for backticks,
(``{\tt `}''). The characters within two terminating backticks form a
command itself that is executed \emph{before} interpretation of the
containing command line continues, and the standard output of the enclosed
commands is substituted for the command line within the backticks. As this
output may include line feeds, these are furthermore substituted with blank
spaces.
\smallskip{}

Note that the result of the executed commands may even contain functional
syntax elements of the Shell, e.g. angle brackets as output of the command
in backticks will become shell stream redirection operators which are then
further interpreted by the shell. Needless to say, this can cause bad
surprises.
\smallskip{}

The backticked sequence can itself be enclosed in double quotes. While this
avoids the above surprise, it will necessarily only generate a single
logical argument. Only in that case, namely a backticked sequence contained
in another pair of double quotes, the Shell performs backwards escaping of
asterisks and double quotes --- same as for variable expansion. Each double
quote or asterisk in the output of the quoted backticked command is escaped
with (another) asterisk. This ensures that the resulting output string
within double quotes retains its original value once interpreted through
{\tt ReadItem()}\key{ReadItem()} or {\tt ReadArgs()}\key{ReadArgs()}. Note
that backwards-escaping does not take place without the additional layer of
double quotes surrounding the backticked command, same as in variable
substitution.

\subsection{Command Execution}

The Shell takes the first argument of each component of a compound command
as a command to be executed. The Shell attempts to locate this command first
on the list of resident commands, see section~\ref{sec:resident}, if the
command is not quoted. If no match is found there, or the command is quoted,
then the Shell keeps looking in the current directory, and if it is not
found there, in all elements of the \emph{path}, as set by the {\tt path}
command. If no matching file or directory is found there, the Shell finally
looks into the {\tt C:} directory\footnote{Note that unlike under unixoid
systems, the current directory is always an implicit first member of the
path and cannot be removed from it.}.
\smallskip{}

Once a matching file system object has been found, the Shell attempts to
``execute'' it and for that checks its type and contents. If this
``command'' turns out to be a directory, the Shell performs an implicit
change to this directory by inserting a {\tt CD} command upfront, and then
triggers iteratively command execution again with this replacement.
\smallskip{}

If the {\tt s} protection bit is set, see section~\ref{sec:fib}, the Shell
assumes that command is actually a script. If this script starts with the
magic character sequence ``{\tt /*}'', it is assumed to be a Rexx script and an
implicit {\tt RX} command is prepended to the command line. If the script
starts with the two-character sequence ``{\tt \#!}'' or ``{\tt ;!}'', then the
remaining first line of the script file contains the path of the command
interpreter which is injected into the Shell command line upfront the script
file, and command interpretation starts again.
\smallskip{}

If none of the above conditions hold true and the {\tt s} protection bit is
set, the Shell assumes that this file is a Shell script prepends an {\tt
  Execute} command upfront the script file name, thus interpretiing it
through the Shell itself --- more on the Execute command in
section~\ref{sec:executecmd}.
\smallskip{}

If the {\tt e} protection bit is set indicating an executable file, the
Shell attempts to load the file through {\tt LoadSeg()}\key{LoadSeg()} and,
after performing input, output and error stream redirection, transfers
program execution to this binary through {\tt
  RunCommand()}\key{RunCommand()}, passing it the remaining command line
arguments.
\smallskip{}

If the {\tt e} protection bit is \emph{not} set, but the shell
variable {\tt \$VIEWER} is set, then the Shell attempts to check whether the
system \emph{datatypes.library} knows anything about the file. If so, the
Shell prepends the contents of this variable to the command line and then
continues execution. By setting {\tt \$VIEWER} to the system program {\tt
  MultiView}, the Shell can therefore display any system-known datatype by
just typing its name.
\smallskip{}

Finally, if none of the above conditions is true, or {\tt LoadSeg()} failed,
the Shell indicates an error that the file is not executable.

\subsection{The Execute Command} \label{sec:executecmd}

Unlike its name suggests, the {\tt Execute} command does not actually
perform interpretation Shell scripts and does not ``execute'' them
directly. Instead, it performs argument substitution within an existing
shell script through a simple interpreter, and then leaves the execution of
the resulting script to the Shell itself by adjusting its command input
stream. Thus, {\tt Execute} does not actually execute anything, it rather
prepares a script for execution through the Shell.
\smallskip{}

Argument substitution through {\tt Execute} is controlled through additional
syntax elements that are only implemented within {\tt Execute} and that are
unrelated, and even partially conflicting with the syntax elements of the
Shell itself\footnote{This is probably another historical accident from
Tripos legacy}.
\smallskip{}

Argument substitution and its syntax elements are controlled through
``pseudo''-commands that are only interpreted though {\tt Execute} but
removed before the resulting script is fed back into the Shell. All these
pseudo-command start by default with a dot (``{\tt .}''), though even this
character can be changed through a pseudo-command. Such pseudo-commands
controlling the {\tt Execute} syntax elements shall be placed at the top of
scripts as the {\tt Execute} one-pass interpreter needs to see them
first. If none of these pseudo-commands are present, {\tt Execute} bypasses
argument substitution and feeds the script unaltered into the Shell, without
further processing.
\medskip{}

The following pseudo-commands are supported by the {\tt Execute}:
\smallskip{}

{\tt .dot} takes a single argument and changes the character by which all
(following) peudo-command start. This is by default a dot (``{\tt .}''), and
for the sake of simplicity, the following pseudo-commands are all shown with
this default.
\smallskip{}

{\tt .key} or {\tt .k} defines which arguments a shell script takes. The
argument is a {\tt ReadArgs()}\key{ReadArgs()} type template, defining the
type of the command line arguments the shell script takes, and also the
names of the formal parameters which will be substituted with the arguments
provided during invokation of the script. Clearly, only a single {\tt .key}
pseudo-command shall be present within a script.
\smallskip{}

{\tt .default} or {\tt .def} defines defaults for arguments that are not
present on the command line that invoked the script. It takes two arguments,
first the key --- the formal name of the parameter for which a default is to
be provided --- and the default value itself. Key and default value can be
either separated by blank spaces, or an equals-sign ``({\tt =})''. If no
default value is provided, an empty string is used. One {\tt .default}
peudo-command can be provided per formal parameter. Another mechanism to
provide default parameters is through the ``{\tt \$}'' character.
\smallskip{}

{\tt .bra} defines the character that marks the beginning of a formal
parameter that is to be substituted. A logical choice for such formal
parameters would be to place them in local variables, and let the Shell
perform the substitution\footnote{This is another historical accident,
likely.}. However, {\tt Execute} uses another syntax by which formal
parameters are enclosed in pairs of characters, one starting the parameter,
and one ending it. The initial character is by default the ``{\tt <}'' sign,
but the {\tt .bra} pseudo-command can change it. As ``{\tt <}'' also
redirects the standard input of commands, this default is probably not a
very wise choice, and it should be changed by {\tt .bra}. Suggested
alternatives are curly or square brackets.
\smallskip{}

{\tt .ket} defines the character that marks the end of a formal parameter
that is to be substituted. This is by default the ``{\tt >}'' sign,
i.e. formal parameters are enclosed in pairs of angle
brackets. Unfortunately, this default is not a very wise choice as it makes
output redirections in scripts impossible. To override this default, {\tt
  .ket} should be used. A suggested alternative is a closing curly or square
bracket.
\smallskip{}

{\tt .dollar} or {\tt .dol} defines the character that defines an
alternative mechanism for providing defaults for formal parameters. Without
this pseudo-command, this character is the dollar sign (``{\tt \$}'') An
optional ``{\tt \$}'' sign, or its replacement defined through this
pseudo-command, separates the formal parameter from its default value. The
formal name, the ``{\tt \$}'' sign, and its default are all enclosed in this
order in the angle brackets, or the characters defined by {\tt .bra} and
{\tt .ket}. Two ``{\tt \$}'' signs in angle brackets expand to the Shell
number and may be used as unique identifier, e.g. to generate a file name of
a temporary file. Even though the ``{\tt \$}'' sign as syntax element for
default value separation is only active within {\tt .bra} and {\tt .ket}, it
is still a bad choice as it conflicts with the Shell syntax which uses the
same character to indicate Shell variables.
\medskip{}

Formal argument substitution otherwise follows the same path as variable
expansion, and {\tt Execute} attempts to preserve the original command line
arguments as good as possible. That is, if a formal parameter is enclosed
within double quotes in the script, asterisks and double quotes are escaped
properly. If the formal parameter included spaces and thus was quoted on the
command line, {\tt Execute} generates suitable double quotes when
substituting the formal parameter with its value, unless the formal
parameter is already enclosed in double quotes. If a formal parameter
takes multiple arguments, as indicated by a {\tt /M} modifier in its
template (see section~\ref{sec:readargs}), then {\tt Execute} also expands
it as multiple parameter in scripts.
\medskip{}

The generated script after substitution of formal parameters is placed into
the {\tt T:} assign, its name in {\tt cli\_CommandFile} and the command
input of the invoking Shell, namely {\tt cli\_CurrentInput} (see
section~\ref{sec:clistructure}), is redirected to a \emph{file handle} to
this temporary script. Thus, the shell continues execution of commands, but
rather takes its input from the temporary file rather than its current
input. As this construction would forbid the recursive execution of another
Shell script within a Shell script, the Shell detects {\tt Execute} as a
special case for which it keeps a ``stack'' of script files and active
redirections. Through that, it provides each recursive execution a ``clean''
environment\footnote{This is a major difference compared to previous
versions of AmigaShell which instead resolved this situation by appending
recursively executed scripts to each other. This construction had a series
of bad side effects, one being that a script could not skip backwards over
an {\tt Execute} command.} that allows redirection of its input. Once {\tt
  cli\_CurrentInput} exhausted, the Shell terminates execution there, closes
the \emph{file handle} stored there, deletes the temporary file whose name
is stored in {\tt cli\_CommandFile} and continues execution from {\tt
  cli\_StandardInput}.

\section{Shell Process Control}

The functions in this section create shell processes and run commands within
them, or overlay a shell process with a command. AmigaDOS also keeps a
process table of all active shell processes and each running shell is
uniquely identified by its task number.

\subsection{Execute Shell Scripts} \label{sec:system}

The {\tt System()}\mkey{System()} function creates a new Shell, and
potentially executes a Shell script. Depending on parameters, it waits for
the script to complete, or launches an interactive Shell in a console or a
non-interactive Shell in the background. The same \emph{dos.library} entry
point exists under 3 names that only differ in how the code generator of a
compiler provides parameters for it.
\smallskip{}

The {\tt SystemTagList()}\mkey{SystemTagList()} function is equivalent to
the {\tt System()}\key{System()} function and does not differ in arguments
and call syntax. It is only present to harmonize function naming across all
library entry points. It takes a pointer to a string containing a Shell
script, possibly only a single command, and additional parameters encoded in
a {\tt TagItem} array as defined in {\tt utility/tagitem.h}.
\smallskip{}

The {\tt SystemTags()}\mkey{SystemTags()} function also receives this
string, but provides the {\tt TagItem}s explicitly as one or multiple exra
arguments to the function. Compilers typically build then the {\tt TagItem}
array on the stack and pass the pointer to the first item on the stack to
the \emph{dos.library} entry point.

\begin{verbatim}
error = SystemTagList(command, tags)
D0		        D1      D2 

LONG SystemTagList(STRPTR, struct TagItem *)

error = System(command, tags)
D0		 D1      D2 

LONG System(STRPTR, struct TagItem *)

error = SystemTags(command, Tag1, ...)

LONG SystemTags(STRPTR, ULONG, ...)
\end{verbatim}

This function is the generic Shell execution function that creates a Shell
in one or multiple modes, and executes the commands provided as first
argument in that Shell. Hence, the first argument establishes a Shell
script, encoded as a string, and multiple commands separated by newline
characters may be provided that will be executed one after another. Argument
substitutions as by the {\tt Execute} command (see
section~\ref{sec:executecmd}) are \emph{not} performed, but otherwise the
entire Shell syntax, including variables, compound commands and pipes is
available. If such mechanisms are necessary, {\tt Execute} shall be called
directly, receiving its input from a temorary file.
\smallskip{}

Depending on its arguments, this function is synchronous, i.e. waits for the
completion of the called commands, or asynchronous and then detaches from
the caller. By proper usage of arguments, this function can emulate (or is
actually even used by) the {\tt Run} and {\tt NewShell} commands, and is
also used by the system startup module to create the initial boot shell.
\smallskip{}

By default, the newly created Shell receives the input and output file
handles of the caller, i.e. {\tt pr\_CIS} and {\tt pr\_COS} are copied from
the calling process, see section~\ref{sec:process} for the documentation of
the process structure. However, with suitable tags the caller can provide
alternative input and output streams. Whether these file handles are closed
upon termination of the shell depends on further arguments, but the default
is not to close them when run synchronously, and to close them otherwise,
even if they were the streams of the caller, so beware and provide suitable
tags.
\smallskip{}

The input and output file handles provided to the Shell \emph{shall be
different}, i.e. it is not permissible to provide the same file handle as
input and as output stream. If the input and output handle should go to an
interactive stream such as the console, then only provide an input stream
and set the output stream to {\tt ZERO} by {\tt SYS\_Output}, see the list
of tags below. The \emph{dos.library} will in that case create an output
file handle by opening another stream to the console through the {\tt *}
file name.
\smallskip{}

The newly creates Shell will receive a copy of the path, the local shell
variables, the prompt, the current directory and the stack size of the shell
of the caller, if such shell exists, i.e. {\tt pr\_CLI} is non-{\tt
  ZERO}. Otherwise, a default path containing only the {\tt C:} directory
and the current directory will be created, no local variables will be
defined, the prompt will be set to ``{\tt \%N> }'' and the current directory
to ``{\tt SYS:}''.
\smallskip{}

By default, the executing shell will be the system shell, whose segment is
available as a system segment of the name ``{\tt BootShell}'' in the
list of resident modules, see section~\ref{sec:resident}. Other shells can
be provided by their name, and the list of resident segments will be scanned
for a match then. Section~\ref{sec:usershells} provides more information on
how to implement a custom shell.
\smallskip{}

The tags this function tags are documented in {\tt dos/dostags.h} and
consist of the {\tt SYS\_} tags and a subset of the {\tt NP\_} tags. 
\smallskip{}

{\tt SYS\_Input} This tag takes a BPTR to a file handle as argument which
becomes the input stream of the new shell. If this tag is not provided, the
input stream of the calling process ({\tt pr\_CIS}) will be used.
\smallskip{}

{\tt SYS\_InName} This tag takes a string as argument. This string will be
used as argument to {\tt Open()}\key{Open()} to create a stream that will be
used as input stream to the newly created shell. This stream will always be
closed when done, regardless of other tags. This tag is mutually exclusive
to {\tt SYS\_Input}.
\smallskip{}

{\tt SYS\_Output} This tag defines a BPTR to a file handle which will be
used as output stream of the new shell. This handle \emph{shall be
different} than the handle provided by {\tt SYS\_Input}. If this tag is not
present, the output stream of the calling process ({\tt pr\_COS}) will be
used for shell output. If this stream is explicitly set to {\tt ZERO}, then
AmigaDOS will attempt to re-open a console through the ``{\tt *}'' file
name. If an input stream is present and interactive, and {\tt command} is
non-{\tt NULL} or {\tt SYS\_Async} is non-zero, then the handler of the
input stream is used to open the replacement output stream. Otherwise, the
handler provided through the {\tt NP\_ConsoleTask} or the console task of
the caller if the former tag is not present is used to open ``{\tt *}''.  If
opening the console fails, AmigaDOS will instead provide a handle to {\tt
  NIL:} as output stream, thus disregarding any output. Any stream
implicitly provided by the \emph{dos.library} by the above mechanism rather
than explicitly through a non-{\tt ZERO} argument to {\tt SYS\_Output} will
also be closed transparently upon termination of the shell.
\smallskip{}

{\tt SYS\_OutName} provides an output file name that will be opened by the
\emph{dos.library} and used as output stream for the newly created
shell. This file will always be closed when the shell terminates. This tag
is mutually exclusive to {\tt SYS\_Output}.
\smallskip{}

{\tt SYS\_CmdStream} provides a BPTR to a file handle from which commands
are read, i.e. a shell script is supplied as stream, and not as a string.
This tag is only used if the {\tt command} argument is {\tt NULL} and then
provides an alternative (stream-based) source for the script to be
executed. This stream is \emph{always} closed on exit, and closure cannot be
prevented by any other tag. If {\tt SYS\_Asynch} is set and {\tt command} is
{\tt NULL}, then the Shell first reads commands from {\tt SYS\_CmdStream},
and once this stream reaches an EOF, it is closed and the shell continues
reading from {\tt SYS\_Input} until this stream also reaches an EOF, or
an {\tt EndCLI} command. Thus, the configuration of providing a
{SYS\_CmdStream} and setting {\tt SYS\_Asynch} is equivalent to the {\tt
  newshell} command.
\smallskip{}

{\tt SYS\_CmdName} provides a file name of a shell script whose contents is
interpreted. This tag is mutually exclusive to {\tt SYS\_CmdStream} and only
used if the {\tt command} argument is {\tt NULL}. This stream will always be
closed on exit.
\smallskip{}

{\tt SYS\_Asynch} If the argument to this tag is non-zero, the shell is
detached from the calling process and executes concurrently with the calling
process; setting this tag also implies that the streams provided by {\tt
  SYS\_Input} and {\tt SYS\_Output} are always closed. It is thus necessary
to explicitly provide {\tt SYS\_Input} or {\tt SYS\_InName} and {\tt
  SYS\_Output} or {\tt SYS\_OutName}, as otherwise the input or output
streams of the calling process will be closed. For legacy reasons, setting
the {\tt command} argument to {\tt NULL} also enforces asynchronous
execution, independent of the value of tag.
\smallskip{}

{\tt SYS\_UserShell} If this boolean tag is set to non-zero, then the ``user
shell'' is launched. This corresponds to the segment ``Shell'' on the
resident list of AmigaDOS. The default of this tag is {\tt DOSFALSE},
indicating that the boot shell is to be used. This corresponds to the
``BootShell' segment on the resident list. Upon system startup, and in all
typical configurations of AmigaDOS, both correspond to the AmigaDOS shell.
Users can, however, replace both shells with custom segments, see
section~\ref{ec:usershells}.
\smallskip{}

{\tt SYS\_CustomShell} this tag provides the name of a custom shell to be
used instead. The AmigaDOS list of resident segments is scanned for a
fitting name, and the fitting segment is then used as shell.
\medskip{}

The following tags defined for {\tt CreateNewProc()}\key{CreateNewProc()},
see section~\ref{sec:createnewproc}, are also recognized:
\smallskip{}

{\tt NP\_StackSize} defines the stack size in bytes for the shell to be
created and the stack size the shell will allocate for its clients. The
default is 4096 bytes for the shell itself; for the shell clients, the stack
size is taken by default from the shell of the calling process, or 4096
bytes if the caller is not a shell process.
\smallskip{}

{\tt NP\_Name} is the name of the shell process to be created. The default
is ``{\tt Background CLI}''.
\smallskip{}

{\tt NP\_Priority} is the priority of the shell process to be created. The
default priority is~0.
\smallskip{}

{\tt NP\_ConsoleTask} provides a pointer to the {\tt MsgPort} of the console
handler that is used for opening the {\tt *} and {\tt CONSOLE:} files, which
will be copied to {\tt pr\_ConsoleTask}. This tag is only used if the input
stream of the new shell is not interactive, and otherwise overridden by the
process {\tt MsgPort} port of the input file handle.
\smallskip{}

{\tt NP\_CopyVars} is a boolean tag that specifies whether local shell
variables are copied into the new shell. The default is to copy the
variables.
\smallskip{}

{\tt NP\_Path} contains a linked list of directory locks that establish the
path of the newly created shell. The structure of this path is specified in
section~\ref{sec:clistruct}. The path provided by this tag \emph{is not}
copied for the new shell, but directly used \emph{and released} by it when
it exits. Thus, callers should make a copy of the path upfront as it will be
released by the created shell.
\smallskip{}

{\tt NP\_ExitCode} and {\tt NP\_ExitData} define a function that is called
when the shell process exits. This mechanism is described in more detail in
section~\ref{sec:createnewproc}.
\medskip{}

The return code of the {\tt System()}\key{System()} and related functions
is~$-1$ in case creating the shell failed. In such a case {\tt
  IoErr()}\key{IoErr()} delivers an error code providing more details on the
cause of the failure. Otherwise, if the commands were executed
synchronously, the return code is the result code of the last command in the
shell executed, and {\tt IoErr()} is set to the error code set by the last
command executed. If an asynchronous shell was created, the result code is~0
on success, and {\tt IoErr()} will be set to~0.
\medskip{}

This function is used to implement a couple of essential system
functionalities, and all Shell commands and system functions that create a
Shell go through this function. This includes the {\tt NewShell} and {\tt
  Run} shell commands and the {\tt Shell} icon on the workbench. The initial
CLI interpreting {\tt S:Startup-Sequence} is also created through the {\tt
  System()} function.
\smallskip{}

The {\tt Run} command creates a new shell process by the following:
\begin{verbatim}
System(NULL,SYS_Input,instream,SYS_Output,Output(),
       SYS_UserShell,TRUE,TAG_DONE);
\end{verbatim}
where the input stream {\tt instream} is a string stream (see
section~\ref{sec:stringstreams}) containing the commands to be executed;
they are taken from the input arguments of the command.
\smallskip{}

Even though {\tt SYS\_Asynch} is not set, the {\tt System()}\key{System()}
function detaches the created shell because its first argument is {\tt
  NULL}, see above. Surprisingly, it is the {\tt System()} call and not the
{\tt Run} command that prints the CLI number of the created shell on the
console in this particular case.
\medskip{}

The {\tt NewShell} command uses {\tt System()} as follows:
\begin{verbatim}
System(NULL,SYS_InName,window_arg,
       SYS_CmdStream,Open(from_arg,MODE_OLDFILE),
       SYS_Asynch,TRUE,SYS_UserShell,TRUE,
       NP_Name,"Shell Process",TAG_DONE);
\end{verbatim}
where the {\tt window} argument and the {\tt from} argument are coming from
the command line arguments of {\tt NewShell} of the same names. That is,
{\tt System()} receives a console as new input file handle, and a command
stream which is by default ``{\tt S:Shell-Startup}''. Setting {\tt
  SYS\_Asynch} to {\tt TRUE} ensures that the shell continues to read
commands from its input file handle as soon as the command file depletes.
\medskip{}

The {\tt Execute()}\key{Execute()} function described in
section~\ref{sec:execute} is equivalent to
\begin{verbatim}
System(NULL,SYS_CmdStream,cmd,
       SYS_Input,in,SYS_Output,out,SYS_UserShell,FALSE,
       NP_Priority,0,TAG_DONE)?DOSTRUE:DOSFALSE;
\end{verbatim}
where {\tt cmd} is a string stream (see section~\ref{sec:stringstream})
containing the commands to be executed, constructed from the first argument
of {\tt Execute()}, and {\tt in} and {\tt out} are its second and third
argument. The difference of {\tt System()} and {\tt Execute()} is only the
result code, but internally run into the same code.

\subsection{Execute Shell Scripts (Legacy)} \label{sec:execute}

The {\tt Execute()}\mkey{Execute()} function creates a new AmigaDOS shell,
which then executes commands from a string, and continues executing commands
from an input stream. This function is obsolete, and should be replaced by
{\tt System()} which is more flexible.

\begin{verbatim}
success = Execute( commandString, input, output )
D0		    D1		  D2	 D3

BOOL Execute(STRPTR, BPTR, BPTR)
\end{verbatim}

This function is a deprecated function to create AmigaDOS shells and
interpret shell scripts that has been superceeded by {\tt
  System()}\key{System()}, see section~\ref{sec:system}.
\smallskip{}

The first argument is a string containing a shell script. If this argument
is {\tt NULL} and thus no command string is present, a new shell is created
and run asynchronously in the background, i.e. {\tt Execute()} returns then
immediately. The new shell receives its input, and thus its commands from
the file handle provided as second argument. The output of the commands go
to the stream provided as third argument if non-{\tt ZERO}, or to a console
cloned by opening ``{\tt *}'' from the console task of caller if possible,
or to a {\tt NIL:} handle if this fails.
\smallskip{}

If the first argument is non-{\tt NULL}, the {\tt Execute()} command is synchronous
and will not return until the shell completed its job. It first reads
commands from the the command string, and once this depletes, switches over
to the stream provided by {\tt input}. If this does not exist, it returns at
that point. Otherwise, it continues reading from {\tt input} until this
stream reaches its EOF, or an {\tt EndCLI} command. The output of the shell
goes through the {\tt output} stream provided as third argument. If the
third argument is {\tt ZERO}, and the input stream is interactive, AmigaDOS
opens ``{\tt *}'' from the input stream handler if it is interactive, or
otherwise disregards all output by providing a {\tt NIL:} handle as output.
\smallskip{}

Unlike {\tt System()}\key{System()}, this function returns {\tt DOSTRUE} on
success and {\tt DOSFALSE} in case creating the shell failed. It also always
executes commands through the boot shell, and not through a custom or user
shell.

\subsection{Run a Command Overloading the Calling Process} \label{sec:runcommand}

The {\tt RunCommand()}\mkey{RunCommand()} runs a shell command from a
process, and overloads the process with the command.

\begin{verbatim}
rc = RunCommand(seglist, stacksize, argptr, argsize)
D0                D1         D2       D3      D4

LONG RunCommand(BPTR, ULONG, STRPTR, ULONG)
\end{verbatim}

This function runs a command from the calling process, and provides for this
command its own stack, and its own arguments. It does not create a new
process nor a new shell, but executes the command as part of the caller. The
AmigaDOS Shell uses this function to execute loaded commands within its
context.
\smallskip{}

The {\tt seglist} argument is a BPTR to the first segment of the executable
to start, for example as returned by {\tt LoadSeg()}\key{LoadSeg()} for
disk-based commands, or {\tt FindSegment()}\key{FindSegment()} for resident
commands.
\smallskip{}

The {\tt stacksize} argument is the size of the stack in bytes to be
provided to the command; this has to be provided by the caller as this
function does not attempt to identify the minimum stack size necessary.
The Shell takes the stack size from {\tt cli\_DefaultStack}, see
section~\ref{sec:clistruct}, and multiplies it by~4. It additionally
searches the {\tt seglist} for the stack cookie, see
section~\ref{sec:stackcookie}, and from that potentially increases the size.
\smallskip{}

The {\tt argptr} and {\tt argsize} arguments provide command line arguments
that are passed to the command. They are provided through several
mechanisms: First, the CPU register {\tt a0} is loaded with {\tt argptr} and
register {\tt d0} is filled with {\tt argsize}. Second, the {\tt
  pr\_Arguments} element of the process is temporarly replaced by {\tt
  argptr}, see also section~\ref{sec:process}, and thus the arguments are
made available to~{\tt GetArgStr()}\key{GetArgStr()}. Third, a buffer for
the input file handle {\tt pr\_CIS} of the caller is allocated and filled
with a copy of the argument line; more on the file handle structure is in
section~\ref{sec:filehandle}. Thus, buffered I/O operations as those listed
in section~\ref{sec:bufferedio} will retrieve the arguments. This step is
necessary to make the arguments available to {\tt
  ReadArgs()}\key{ReadArgs()}, the AmigaDOS argument parser.
\smallskip{}

The {\tt ReadArgs()}\key{ReadArgs()} function, and probably many other
parsers require that the argument is terminated by a newline, hex {\tt
  0x0a}. While it is possible to provide an argument string containing more
than one newline character, {\tt ReadArgs()}\key{ReadArgs()} will ignore all
arguments behind the first newline. However, some commands such as {\tt Run}
will make use of the entire string.
\medskip{}

All changes performed by {\tt RunCommand()} on the caller and its resources,
namely the stack, the modifications of the input file handle and storage of
the arguments and the modified stack are reverted when the called command
returns.
\smallskip{}

As the program name \emph{is not} part of the command line arguments, it is
advisable to set the path and file name of the loaded program {\tt
  SetProgramName()}\key{SetProgramName()} upfront, more on this function in
section~\ref{sec:setprogramname}. The startup code of many C compilers will
construct {\tt argv[0]} from it.
\smallskip{}

This function returns the result code of the called command, or~$-1$ if
it failed to allocate resources such as the input file handle buffer or the
stack. {\tt IoErr()}\key{IoErr()} remains its value from the called command,
or is set to {\tt ERROR\_NO\_FREE\_STORE} if resources could not be
allocated.

\subsection{Request a Function of the Shell} \label{sec:doshellmethod}

The {\tt DoShellMethod}\mkey{DoShellMethod()} function requests from the
shell of the calling process a specific function. The {\tt
  DoShellMethodTagList()}\mkey{DoShellMethodTagList()} function belongs to
the same entry point of the \emph{dos.library}, though uses a different
calling convention that receives the tag list as an explicit pointer instead
of a variably sized argument list.

\begin{verbatim}
ptr = DoShellMethodTagList(method, tags)
D0                           D0     A0

APTR DoShellMethodTagList(ULONG, struct TagItem *)

ptr = DoShellMethod(method, Tag1, ...)

APTR DoShellMethod(ULONG, ULONG, ...)
\end{verbatim}

This function requests the from the shell of the calling process the
execution of a function identified by {\tt method}. The arguments to the
shell are provided in the tag list, or by a list of tags terminated by {\tt
  TAG\_DONE}. The return value of the shell is provided in {\tt ptr}, a
secondary return code is provided in {\tt IoErr()}.
\medskip{}

The AmigaDOS Shell supports the following methods defined in {\tt
  dos/shell.h}:
\smallskip{}

{\tt SHELL\_METH\_METHODS} returns a {\tt const} array of methods the shell
supports. This is an array of {\tt ULONG}s that is terminated by a {\tt 0L},
each containing a method ID that may be provided to {\tt
  DoShellMethod()}\key{DoShellMethod()}. Every shell shall support this
method.
\smallskip{}

{\tt SHELL\_METH\_GETHIST} is a method of the AmigaDOS Shell that provides
read-only access to the history. It does not take any arguments. The
returned pointer is a {\tt MinList} structure, see {\tt exec/lists.h}. Each
node in this list consists of a {\tt HistoryNode} structure, defined in {\tt
  dos/shell.c}:

\begin{verbatim}
struct HistoryNode {
  struct MinNode  hn_Node;
  UBYTE          *hn_Line;
};
\end{verbatim}

The {\tt hn\_Line} is a pointer to a command in the history of the
shell. This command is \emph{not} terminated by a newline, but only by a
{\tt NUL}. The caller \emph{shall not} alter this list. 
\smallskip{}

{\tt SHELL\_METH\_CLRHIST} erases the entire history of the AmigaDOS
Shell. This method does not take any arguments.
\smallskip{}

{\tt SHELL\_METH\_ADDHIST} adds an entry to the newest end of the AmigaDOS
Shell history and make it accessible to the user through the cursor
keys. This method takes a single tag, namely {\tt SHELL\_ADDH\_LINE}. The
argument of this tag is a {\tt UBYTE *} to a {\tt NUL}-terminated string,
namely the entry to add to the history. The Shell copies the provided
string, and may initial or trailing spaces. It may also limit the size of
the history buffer by releasing the oldest entry or entries. This method
returns a non-zero result on success, or {\tt NULL} on error.
\smallskip{}

{\tt SHELL\_METH\_FGETS} retrieves a single line from the console the shell
runs in, while offering access to TAB expansion and access to the
history. The difference between this method and the {\tt
  FGets()}\key{FGets()} function is that the latter provides elementary line
editing functions of the console, but does not have access to Shell internal
states such as the path of the caller requird for TAB
expansion\footnote{Readers beware: TAB expansion and the history are
\emph{not} console features, but Shell features.}.
\smallskip{}

This method takes a single optional boolean tag, {\tt SHELL\_FGETS\_FULL},
defined in {\tt dos/shell.h}. If this tag is {\tt DOSFALSE}, which is the
default, then the Shell is instructed to read a string from the console that
corresponds to a path or multiple paths relatively to the current directory
of the caller. TAB expansion will only scan the current directory for
matches. This mode is useful for requesting a file or multiple files from
the user, and it is for example used by the AmigaDOS argument parser, {\tt
  ReadArgs()}\key{ReadArgs()}, when the input is a quesion mark (``{\tt
  ?}'') and more input is required from the user.
\smallskip{}

If {\tt SHELL\_FGETS\_FULL} is non-zero, then a full command line is
requested from the shell. This implies that the first argument of the input
requested from the console is a command, and is thus located somewhere on
the \emph{path} of the caller. Thus, when performing TAB expansion within
the first argument, the entire path is scanned, and not just the current
directory.
\smallskip{}

This method returns a pointer to a {\tt NUL}-terminated string as result; as
this string is kept within Shell internal buffers, the caller shall make a
copy of the string before calling another method of the Shell.
\medskip{}

If {\tt DoShellMethod}\key{DoShellMethod()} is called from a process that is
not part of a shell, it returns {\tt NULL} and sets {\tt
  IoErr()}\key{IoErr()} to {\tt ERROR\_OBJECT\_WRONG\_TYPE}.

\subsection{Find a Shell Process by Task Number}

The {\tt FindCliProc()}\mkey{FindCliProc()} function finds a process by its
task number.

\begin{verbatim}
proc = FindCliProc(num)
D0             D1

struct Process *FindCliProc(ULONG)
\end{verbatim}

This function returns a process given its task number. Note, however, that
AmigaDOS only assigns task numbers to shells and commands run within or from
shells and not to other processes, such as those started from the workbench,
handlers, file systems or device drivers. Thus, this function is not quite
as useful as it seems.
\smallskip{}

The {\tt num} is the task number that identifies the process to locate. It
is stored in the {\tt pr\_TaskNum} element of the process structure, see
section~\ref{sec:process}.
\smallskip{}

This function returns a pointer to the process structure, see
section~\ref{sec:process} whose task number is {\tt num}. If no such process
exists, this function returns {\tt NULL}. However, even if it returns a
non-{\tt NULL} result code, it is possible that the process has already
exited and no longer exists when the function returns or an attempt is made
to access its process structure. Furthermore, the \emph{dos.library} does
not attempt to protect its process table within this function, and there is no
semaphore protecting it. Therefore, this function \emph{shall only be called}
while task switching is disabled with {\tt Forbid()} and its return value is
only valid as long as task switching is disabled.
\smallskip{}

This function does not alter {\tt IoErr()}\key{IoErr()}, even if no process
is found.

\subsection{Retrieve the Size of the Process Table}

The {\tt MaxCli()}\mkey{MaxCli()} function returns the size of the process
table.

\begin{verbatim}
number = MaxCli()
D0

LONG MaxCli(void)
\end{verbatim}

This function returns the number of entries the process table may
hold. However, this information is of limited value for various reasons:
First, this information does \emph{not} correspond to the number of running
processes, but only describes the number of entries the process table is
able to hold. Second, only shells and commands run within or from shells
are recorded in the process table, and other processes as those started from
the workbench, or handlers, file systems or device drivers do not enter this
table. Third, the size of this table changes dynamically depending on how
many shell processes are active, even under the feed of the caller. Thus,
this function should be avoided.
\smallskip{}

As the \emph{dos.library} does not protect the process table from
modifications, this function \emph{shall only be called} while task
switching is disabled with {\tt Forbid()}, and its value is only valid as
long as the task switching remains disabled.

\section{The CLI Structure} \label{sec:clistruct}

The {\tt CommandLineInterface}\key{CommandLineInterface} structure is the
public interface of an AmigaDOS shell. Every command started from a shell
has access to this structure through the {\tt pr\_CLI} BPTR in its process
structure, see section~\ref{sec:process}, which is actually the process
structure of the shell calling the program, see
section~\ref{sec:runcommand}.
\smallskip{}

The functions listed in this section provide accessor functions to this
structure which should be preferred to access and alter properties of the
calling shell.

\subsection{Obtaining the Name of the Current Directory}

The {\tt GetCurrentDirName()}\mkey{GetCurrentDirName()} function copies the
current directory of the shell into the provided buffer if such a shell
exists, or retrieves the current directory of the calling process instead.

\begin{verbatim}
success = GetCurrentDirName(buf, len)
D0                          D1   D2

BOOL GetCurrentDirName(STRPTR, LONG)
\end{verbatim}

This function checks whether the caller is a shell command. If so, it copies
what the shell believes to be its current directory into the supplied
buffer. That is, the function then copies {\tt cli\_SetName} into {\tt buf},
see section~\ref{sec:clistruct}. If the current directory path fits into
{\tt len} bytes including a terminating {\tt NUL} byte, then this function
returns {\tt DOSTRUE} and sets {\tt IoErr()}\key{IoErr()} to~0. Otherwise,
it truncates the name, returns {\tt DOSFALSE} and sets {\tt
  IoErr()}\key{IoErr()} to {\tt ERROR\_LINE\_TOO\_LONG}, but still returns
{\tt DOSTRUE}.
\smallskip{}

The shell itself does not update {\tt cli\_SetName}, namely the field this
function depends upon, itself. Rather, the {\tt CD}, {\tt SwapCD}, {\tt
  PushCD} and {\tt PopCD} commands attempt to keep it consistent. However,
if a command changes {\tt pr\_CurrentDir} without updating {\tt
  cli\_SetName}, or calls {\tt SetCurrentDirName()}\key{SetCurrentDirName()}
without updating the current directory of its processes, then the string
supplied by this function may not correspond to the current directory the
shell actually uses.
\smallskip{}

If the caller is not a shell command, then the function uses the lock
representing the current directory of the calling process, namely {\tt
  pr\_CurrentDir}, and converts it to a string by {\tt
  NameFromLock()}\key{\tt NameFromLock()}. This function, see
section~\ref{sec:namefromlock}, also truncates its result to {\tt len} bytes
and, if truncation was performed, sets {\tt IoErr()}\key{IoErr()} to {\tt
  ERROR\_LINE\_TOO\_LONG} and returns {\tt DOSFALSE} if the directory name
does not fit into {\tt len} bytes. On success, the function returns a
non-zero result code, but it does not set {\tt IoErr()} consistently then.

\subsection{Set the Current Directory Name}

The {\tt SetCurrentDirName()}\mkey{SetCurrentDirName()} sets the buffer
within which the shell keeps the string representing the current
directory. It does not update the current directory itself.

\begin{verbatim}
success = SetCurrentDirName(name)
D0                        D1

BOOL SetCurrentDirName(STRPTR)
\end{verbatim}

This function updates {\tt cli\_SetName} of the shell the caller is part of,
if such a shell exists. In such a case, it copies the supplied string into
{\tt cli\_SetName} and potentially truncates it to the size of the
shell-internal buffer. Even if the string is truncated, the function returns
{\tt DOSTRUE}. It does not update {\tt IoErr()} in either case. For some
legacy reasons, the size of this buffer is rather small, and thus may not
reflect the full directory name supplied.
\smallskip{}

If the caller is not a shell command, this function returns {\tt DOSFALSE}
without setting an error code.
\smallskip{}

This function does not attempt to synchronize {\tt pr\_CurrentDir} of the
calling process to the supplied directory, If the two are not consistent,
the path the shell could print as part of the prompt would be
incorrect. Thus, any attempt to change {\tt cli\_SetName} through this
function \emph{shall also} call {\tt CurrentDir()}\key{CurrentDir()} to make
this change consistent to the Shell.

\subsection{Obtaining the Current Program Name}

The {\tt GetProgramName()}\mkey{GetProgramName()} function copies the name of
the currently executed program into a buffer.

\begin{verbatim}
success = GetProgramName(buf, len)
D0                       D1   D2

BOOL GetProgramName(STRPTR, LONG)
\end{verbatim}

This function fills {\tt buf} with the what the Shell assumes to be the name
of the currently executed command. This name is taken from {\tt
  cli\_CommandName}, see section~\ref{sec:clistruct}, where the shell
deposits it before executing a program. If the program name including {\tt
  NUL} termination requires more than {\tt len} bytes, this function first
truncates it and sets {\tt IoErr()}\key{IoErr()} to {\tt
  ERROR\_LINE\_TOO\_LONG}. If the name including
a terminating {\tt NUL} byte fits into {\tt len} bytes, the name is copied
and the function sets {\tt IoErr()}\key{IoErr()} to~0. In either case, even
if the program name is truncated, the function returns {\tt DOSTRUE}.
\smallskip{}

If this function is not called from a shell command, the function installs
an empty string in {\tt buf} if {\tt len} is at least~1 and returns {\tt
  DOSFALSE} and sets {\tt IoErr()} to {\tt ERROR\_OBJECT\_WRONG\_TYPE}.
\smallskip{}

The Shell buffer that keeps the current command name is unfortunately due to
legacy reasons quite limited in size, and at present shorter than the 106
character limit imposed by the {\tt FileInfoBlock} structure, see
section~\ref{sec:fib}. Even though the Shell uses internally a longer buffer
and thus is not limited in the file name size of commands it executes, the
ability of the Shell to communicate such long command names to the caller is
restricted, and thus the command name retrieved from this function may not
reflect the correct file name.

\subsection{Set the Current Program Name} \label{sec:setprogramname}

The {\tt SetProgramName()}\mkey{SetProgramName()} sets the name the shell
assumes the currently executing program has.

\begin{verbatim}
success = SetProgramName(name)
D0                        D1

BOOL SetProgramName(STRPTR)
\end{verbatim}

If this function is called from a shell command, it installs the supplied
string as program name into {\tt cli\_CommandName},
section~\ref{sec:clistruct}, and returns {\tt DOSTRUE}. If the supplied
string does not fit into the Shell internal buffer, it is truncated without
this function indicating failure.
\smallskip{}

If this function is not called from a shell command, it returns {\tt
  DOSFALSE}. This function does not change {\tt IoErr()}\key{Ioerr()} in any
case.

\subsection{Obtaining the Shell Prompt}

The {\tt GetPrompt()}\mkey{GetPrompt()} function copies the prompt format
string with all formatting instructions into a caller supplied function.

\begin{verbatim}
success = GetPrompt(buf, len)
D0                  D1   D2

BOOL GetPrompt(STRPTR, LONG)
\end{verbatim}

If this function is called from a shell command, it copies the prompt format
string including a terminating {\tt NUL} into {\tt buf} if it fits into {\tt
  len} bytes, potentially truncating it if it does not. If truncation was
performed, {\tt IoErr()} is set to {\tt ERROR\_LINE\_TOO\_LONG}, otherwise
to~0. In either case, even if the string was truncated, the function returns
{\tt DOSTRUE}.
\smallskip{}

If this function is not called from a shell command, an empty string is
copied into {\tt buf} if {\tt len} is at least~1, and {\tt
  IoErr()}\key{IoErr()} is set to {\tt ERROR\_OBJECT\_WRONG\_TYPE} and the
function returns {\tt DOSFALSE}.
\smallskip{}

The shell prompt provided by this function is the unexpanded prompt
including format strings as it is provided by the {\tt Prompt} command, and
not the expanded prompt currently printed by the shell.

\subsection{Setting the Shell Prompt}

The {\tt SetPrompt()}\mkey{SetPrompt()} sets the Shell prompt format string.

\begin{verbatim}
success = SetPrompt(name)
D0                D1

BOOL SetPrompt(STRPTR)
\end{verbatim}

If called from a shell command, this function updates the shell prompt
format string to {\tt name}, potentially truncating it to the size of the
Shell internal buffer. It returns {\tt DOSTRUE} even if the prompt is
truncated.
\smallskip{}

If this function is not called from a shell command, it returns {\tt
  DOSFALSE}. In does not change {\tt IoErr()}\key{IoErr()} in any case.
\smallskip{}

The Shell prompt provided to this function may contain all format strings
described in~\ref{sec:clistruct}, such as {\tt \%S} for the current path, or
Shell variables and backticks to construct a prompt dynamically. The
shell-internal buffer size for the prompt is unfortunately quite limited. If
longer prompts are required, they could be placed in a local shell variable
which is expanded in the prompt.

\subsection{Retrieving the CLI Structure}

The {\tt Cli()}\mkey{Cli()} function returns a pointer to the {\tt
  CommandLineInterface} structure describing the shell within which the
calling process is executing, or {\tt NULL} in case the process is not run
from a shell.

\begin{verbatim}
cli_ptr = Cli()
D0

struct CommandLineInterface *Cli(void)
\end{verbatim}

This function returns a pointer to the {\tt
  CommandLineInterface}\mkey{CommandLineInterface} structure that describes
properties of the shell the calling process runs within. The function
returns {\tt NULL} if the caller is not part of a shell process.
This structure, defined in {\tt dos/dos.h}, looks as follows:

\begin{verbatim}
struct CommandLineInterface {
    LONG   cli_Result2;
    BSTR   cli_SetName;
    BPTR   cli_CommandDir;
    LONG   cli_ReturnCode;
    BSTR   cli_CommandName;
    LONG   cli_FailLevel;
    BSTR   cli_Prompt;
    BPTR   cli_StandardInput;
    BPTR   cli_CurrentInput;
    BSTR   cli_CommandFile;
    LONG   cli_Interactive;
    LONG   cli_Background;
    BPTR   cli_CurrentOutput; 
    LONG   cli_DefaultStack;
    BPTR   cli_StandardOutput;
    BPTR   cli_Module;
};
\end{verbatim}

The elements of this structure are as follows:
\smallskip{}

{\tt cli\_Result2} is the {\tt IoErr()}\key{IoErr()} the last executed
command of the shell left, or the Shell created itself when failing to
interpret or execute a command line. This element is for example used by the
{\tt why} command to print a textual description of the error. The shell
also copies this value into the {\tt \$Result2} Shell variable.
\smallskip{}

{\tt cli\_SetName} is a BPTR to a BSTR containing the path of the current
directory. This string is used to generate a shell prompt; the AmigaDOS
shell substitutes the ``{\tt \%S}'' format directive of the prompt by the
string stored here. The {\tt CD} command and its {\tt PushCD}, {\tt
  PopCD} and {\tt SwapCD} variants update this element.
\smallskip{}

{\tt cli\_CommandDir} contains a linked list of directories that are scanned
for commands. It is a BPTR to the following (undocumented) structure:

\begin{verbatim}
struct PathComponent {
    BPTR pc_Next;
    BPTR pc_Lock;
};
\end{verbatim}
where {\tt pc\_Next} is the BPTR to the next directory in the path or {\tt
  ZERO} for the end of the list, and {\tt pc\_Lock} is a lock of the
directory that will be scanned for a matching command file.
\smallskip{}

The current directory is always the first component of the
path and thus checked first for matching files, even if
{\tt cli\_CommandDir} is {\tt ZERO}. The {\tt C:} directory
is always the last component of a path and neither explicitly included in
the linked list.
\smallskip{}

The {\tt Path} command is used to print and adjust the path stored in this
list.
\medskip{}

{\tt cli\_ReturnCode} is the return code of the last executed command,
i.e. the value the command left in the {\tt d0} CPU register when existing
to the Shell. The shell also copies this value to the {\tt \$RC} Shell
variable.
\smallskip{}

{\tt cli\_CommandName} is a BPTR to a BSTR containing the name of the
currently executing command. It is placed here by the shell before calling
in.
\smallskip{}

{\tt cli\_FailLevel} contains the threshold at which executed commands will
cause an abortion of its containing shell script. The value is deposited
here by the {\tt FailAt} command. If a command exits with return code larger
or equal than the {\tt cli\_FailLevel}, this will cause termination of the
currently executing script.
\smallskip{}

{\tt cli\_Prompt} contains a BPTR to BSTR that is used by the shell to print
the command prompt on interactive shells. The AmigaDOS Shell recognizes the
following strings:

\begin{itemize}
  \item[{\tt \%S}] Replaced by the path of the current directory, namely the
    contents of {\tt cli\_SetName}.
  \item[{\tt \%N}] Substituted with the CLI number, which is the closest
    analogon of a process ID AmigaDOS has to offer. This is taken from {\tt
      pr\_TaskNum} of the process running the shell, see also
    section~\ref{sec:process}.
  \item[{\tt \%R}] Represents the return code of the last executed command
    as contained in {\tt cli\_ReturnCode}.
  \item[{\tt \%\%}] The percent (``{\tt \%}'') sign itself.
\end{itemize}

The AmigaDOS Shell also expands variables as described in
section~\ref{sec:variableexpansion} in the prompt, executes commands
backticks, see section~\ref{sec:backtick}, and inejcts its output into the
printed prompt. Any ``{\tt \%}'' sign included in expanded variables or backticks
is \emph{not} a formatting command but stands for itself.
\medskip{}

{\tt cli\_StandardInput} is a BPTR to a file handle that represents the primary
source of commands. This file handle typically corresponds to a console
window within which the shell is executed. The {\tt Run} command will deposit
here a string stream (see section~\ref{sec:stringstreams}) containing the
command or commands to be run in background. The file handle provided
through the {\tt SYS\_Input} or {\tt SYS\_InName} tags of the {\tt
  System()}\key{System()} function will be placed here. Once this stream is
exhaused, the Shell terminates.
\smallskip{}

{\tt cli\_CurrentInput} is a BPTR to a file handle from which the shell is
currently executing commands. This stream is either comming from the {\tt
  SYS\_CmdStream} or {\tt SYS\_CmdIn} tags of the {\tt
  System()}\key{System()} function, or a string stream constructed from its
first argument. Also, the {\tt Execute} command, see
section~\ref{sec:executecmd}, places here the file handle of the original or
processed shell script that is to be executed. Once this file is exhaused,
the Shell will close it, and set this BPTR to {\tt cli\_StandardInput}. This
happens, for example, if a script reaches its end of file or is aborted by
the {\tt Exit} command.
\smallskip{}

{\tt cli\_CommandFile} is a BPTR to the BSTR of a temporary shell script
that is currently being executed. The only reason why its path is stored
here is to allow the Shell to clean up such temporary scripts. Whenever the
{\tt Execute} command requires processing a script for argument
substitution, it creates a temporary script in {\tt T:} whose name is stored
in {\tt cli\_CommandFile}. Once its execution completes, the Shell ensures
that this temporary script is deleted again. For details on how {\tt
  Execute} actually works see section~\ref{sec:executecmd}.
\smallskip{}

{\tt cli\_Interactive} is a boolean flag that indicates whether the Shell is
interactive, i.e. requesting data from the console. If this boolean is
non-zero and {\tt cli\_Background} is {\tt DOSFALSE}, a prompt is printed
before attempting to read a command from {\tt cli\_CurrentInput}. If the
shell is executing a script, this element becomes {\tt DOSFALSE} and the
Shell then checks for a Ctrl-D signal to potentially abort a running script.
\smallskip{}

{\tt cli\_Background} is a boolean that indicates whether the Shell runs in
background. This flag is set for shells that are started asynchronously or
are equipped with a non-interactive (non-console) output stream. If this
flag is cleared, then the shell also prints a message when its input stream
reaches its EOF, indicating that the shell terminates.
\smallskip{}

{\tt cli\_CurrentOutput} is currently not used by the Shell. It is currently
initialized with the same file handle as {\tt cli\_StandardOutput}.
\smallskip{}

{\tt cli\_DefaultStack} is the minimum stack in long-words the Shell
allocates for commands before executing them. The Shell also checks the
command for a stack cookie, see section~\ref{sec:stackcookie}, that may
enlarge the stack further. This element is set by the {\tt
  Stack} command. Note that this element is \emph{not} the stack size of the
shell process itself, but a lower limit of the stack size for its clients.
\smallskip{}

{\tt cli\_StandardOutput} is the file handle the shell provides as default
output handle to its clients, and to which it prints output. This handle is
copied from the {\tt SYS\_Output} or {\tt SYS\_OutName} tags of the {\tt
  System()}\key{System()} function if they are provided.
\smallskip{}

{\tt cli\_Module} is a BPTR to the first segment of the command currently
executed. The Shell also uses this BPTR to release loaded, non-resident
commands. This BPTR is either filled with the segment provided by {\tt
  LoadSeg()}\key{LoadSeg()} in section~\ref{sec:loadseg}, or an element of
the list of resident segments, see section~\ref{sec:resident}. A common
technique for load and stay resident commands is to set this BPTR to {\tt
  ZERO} to prevent the shell from releasing the loaded program and thus keep
it in memory.
\medskip{}

Even though the {\tt CommandLineInterface} function is typically constructed
by AmigaDOS, e.g. through the {\tt System()}\key{System()} function, it is
sometimes necessary to create it manually. Allocation of this structure
shall happen only through {\tt AllocDosObject()}\key{AllocDosObject()} as
this structure contains some Shell-internal fields for extended Shell
features. These extended features are instead accessible through the {\tt
  DoShellMethod()}\key{DoShellMethod()} function specified in
section~\ref{sec:doshellmethod}.
\medskip{}

This function does not change {\tt IoErr()}\key{IoErr()}.

\section{Access Shell Variables}

The functions in this section provide access to local and global shell
variables, get and set them, or check whether a particular variable is
defined.

\subsection{Read a Shell Variable}

The {\tt GetVar()}\mkey{GetVar()} function reads the contents of a global or
local shell variable and copies its contents to a buffer.

\begin{verbatim}
len = GetVar( name, buffer, size, flags ) 
D0	       D1     D2     D3    D4

LONG GetVar( STRPTR, STRPTR, LONG, ULONG ) 
\end{verbatim}

The {\tt name} argument is the name of the variable to retrieve; this name
may contain one or multiple forward slashes (``({\tt /})'') which structure
variables hierarchically. For global variables, this hierarchy is mapped to
subdirectories of a file in the {\tt ENV:} assign where variables are
represented as files that may also be accessed through the file system
functions of the \emph{dos.library}. Unless specified otherwise, this
function first checks for local shell variables, but if no matching variable
is found, it checks for a global variable of the name provided.
\smallskip{}

The {\tt buffer} and {\tt size} arguments specify a buffer and its length
into which the contents of the variable, if it exists, is copied. It is
advisable to store only printable characters in variables, in which case any
{\tt NUL} or line feed character truncates the contents of the
variable. However, variables may also contain binary data; such binary data
is, however, only copied if it is requested explicitly. If a variable does
not fit into the buffer, it is truncated without setting an error code, but
non-binary variables are always {\tt NUL}-terminated. The {\tt size}
argument includes the byte necessary for termination.
\medskip{}

The {\tt flags} argument determines the type of variable to access, and
whether binary contents of the variable is made accessible. The following
flags are defined in {\tt dos/var.h}:
\smallskip{}

The lowest 8 bits of {\tt flags} identify the nature of the variable. If set
to {\tt LV\_VAR}, this function reads variables, if set to {\tt LV\_ALIAS},
it reads aliases. Aliases are always local to the shell and cannot be
global.

If the {\tt GVF\_GLOBAL\_ONLY} flag is set, then this function only returns
contents of global variables, and local variables are ignored. Aliases are
never global.
\smallskip{}

If the {\tt GVF\_LOCAL\_ONLY} flag is set, then this function only returns
contents of local variables and ignores any global variables.
\smallskip{}

If the {\tt GVF\_BINARY\_VAR} flag is set, then copying the contents of
variables into the supplied {\tt buffer} does not stop at newline ({\tt
  0x0a}) or {\tt NUL} characters, but attempts to transfer the entire
variable into the buffer, potentially truncating it if necessary. It is,
however, {\tt NUL} terminated, unless {\tt GVF\_DONT\_NULL\_TERM} is set.
\smallskip{}

If the {\tt GVF\_DONT\_NULL\_TERM} flag is set along with {\tt
  GVF\_BINARY\_VAR}, then this function does not attempt to {\tt
  NUL}-terminate the supplied buffer. Rather the entire variable, if
possible, is copied into {\tt buffer}.
\smallskip{}

On success, this function returns the size of the supplied variable after
truncation is applied if necessary. The size does not include the
terminating {\tt NUL}, if one is included. On success, this function sets
{\tt IoErr()}\key{IoErr()} to the entire size of the variable in the
database, including any bytes beyond a terminating newline or {\tt NUL}.
\smallskip{}

On error, $-1$ is returned and {\tt IoErr()}\key{IoErr()} is set to an error
code; it is set to {\tt ERROR\_BAD\_NUMBER} if {\tt len} is~0,
or {\tt ERROR\_OBJECT\_NOT\_FOUND} if the variable could not be found. Any
other error code resulting from reading from {\tt ENV:} is also forwarded to
the caller through {\tt IoErr()}\key{IoErr()}.

\subsection{Setting a Shell Variable}

The {\tt SetVar()}\mkey{SetVar()} assigns a value to a local or global shell
variable, potentially creating a new variable, or potentially deleting it.

\begin{verbatim}
success = SetVar( name, buffer, size, flags ) 
D0                 D1     D2     D3    D4

BOOL SetVar(STRPTR, STRPTR, LONG, ULONG ) 
\end{verbatim}

This function assigns the value in {\tt buffer} to the variable named {\tt
  name}, possibly creating it if it does not exist, or deleting it if {\tt
  buffer} is {\tt NULL}.
\smallskip{}

The {\tt name} argument is the name of the variable to create, update or
delete. The {\tt name} may contain one or multiple slashes (``{\tt /}'')
which corresponds to a hierarchy of variables; this hierarchy is represented
by directories in {\tt ENV:} for global variables, and this function
potentially creates the hierarchy, i.e. subdirectories for global variables,
if necessary.
\smallskip{}

The {\tt buffer} and {\tt size} arguments are the contents of the variable
and the size of the contents. It is generally advisable to only include
printable characters in variables, even though they may include also binary
data which can be retrieved by setting the {\tt LVF\_BINARY\_VAR} for {\tt
  GetVar()}\key{GetVar()}. If {\tt size} is $-1$, then the {\tt buffer}
contains a {\tt NUL}-terminated string and this function determines the
string size internally. The terminating {\tt NUL} of such a string
\emph{does not} become part of the variable value.
\smallskip{}

If {\tt buffer} is {\tt NULL}, then a matching variable is deleted. It is
then equivalent to {\tt DeleteVar()}\key{DeleteVar()}.
\medskip{}

The {\tt flags} argument determines the type of the variable to be set or
created. The following flags are defined in {\tt dos/var.h}:
\smallskip{}

{\tt LV\_VAR} sets or creates a regular shell variable, local or global.
\smallskip{}

{\tt LV\_ALIAS} sets or creates an alias. Aliases can only be local. This is
mutually exclusive to the above.
\smallskip{}

If {\tt GVF\_GLOBAL\_ONLY} is set, then a global variable is created, deleted
or updated. This flag \emph{shall not} be combined with {\tt
  LV\_ALIAS}. If this flag is \emph{not} set, and {\tt buffer} is not {\tt
  NULL}, this function only updates or creates local variables; it even
creates a local variable if a global variable of the same name already
exists. If this flag is \emph{not} set, and {\tt buffer} is {\tt NULL}, it
first attempts to delete a local variable, and if none is found, attempts to
delete a global variable of the matching name.
\smallskip{}

If {\tt GVF\_LOCAL\_ONLY} is set, then only a local variable is created,
deleted or updated. This flag only makes a difference if {\tt buffer} is
{\tt NULL} as all other operations default to local variables anyhow.
\medskip{}

This function returns a non-zero return value in case of success. {\tt
  IoErr()}\key{IoErr()} is then not set consistently. On error, this
function returns {\tt DOSFALSE} and {\tt IoErr()}\key{IoErr()} is set to an
error code. If a variable is to be deleted by setting {\tt buffer} to {\tt
  NULL}, and this variable does not exist, this function will set {\tt
  IoErr()} to {\tt ERROR\_OBJECT\_NOT\_FOUND}.

\subsection{Finding a Shell Variable}

\begin{verbatim}
var = FindVar( name, type ) 
D0		D1    D2

struct LocalVar * FindVar(STRPTR, ULONG ) 
\end{verbatim}

\subsection{Deleting a Shell Variable}

\begin{verbatim}
success = DeleteVar( name, flags ) 
D0		      D1    D2

BOOL DeleteVar(STRPTR, ULONG ) 
\end{verbatim}

\section{Parsing Arguments}

\subsection{Parsing Command Line Arguments}

\begin{verbatim}
result = ReadArgs(template, array, rdargs)
D0                   D1      D2      D3

struct RDArgs * ReadArgs(STRPTR, LONG *, struct RDArgs *)
\end{verbatim}

\subsection{Reading a Single Argument from the Command Line}

\begin{verbatim}
value = ReadItem(buffer, maxchars, input)
D0                D1        D2      D3

LONG ReadItem(STRPTR, LONG, struct CSource *)
\end{verbatim}

\subsection{Finding an Argument}

\begin{verbatim}
index = FindArg(template, keyword)
D0                D1        D2

LONG FindArg(STRPTR, STRPTR)
\end{verbatim}

\subsection{Releasing the Argument Parser}

\begin{verbatim}
FreeArgs(rdargs)
           D1

void FreeArgs(struct RDArgs *)
\end{verbatim}


\subsection{Initializing a new Shell}

\begin{verbatim}
flags = CliInitRun( packet )
D0		      A0

LONG CliInitRun( struct DosPacket * )
\end{verbatim}

\subsection{Finding a Resident Command}

\begin{verbatim}
segment = FindSegment(name, start, system)
D0		       D1     D2     D3

struct Segment *FindSegment(STRPTR, struct Segment *, LONG)
\end{verbatim}

\subsection{Adding a Resident Command}

\begin{verbatim}
success = AddSegment(name, seglist, type)
D0		      D1     D2      D3

BOOL AddSegment(STRPTR, BPTR, LONG)
\end{verbatim}

\subsection{Removing a Resident Command}

\begin{verbatim}
success = RemSegment(segment)
D0		        D1

BOOL RemSegment(struct Segment *)
\end{verbatim}

\section{Miscellaneous Functions}

% TODO

\subsection{Allocating a DOS Object}

\begin{verbatim}
ptr = AllocDosObject(type, tags)
D0                    D1    D2

void *AllocDosObject(ULONG, struct TagItem *)

ptr = AllocDosObjectTagList(type, tags)
D0                 	     D1    D2

void *AllocDosObjectTagList(ULONG, struct TagItem *)

ptr = AllocDosObjectTags(type, Tag1, ...)

void *AllocDosObjectTags(ULONG, ULONG, ...)
\end{verbatim}

\subsection{Releasing a DOS Object}

\begin{verbatim}
FreeDosObject(type, ptr)
	       D1   D2

void FreeDosObject(ULONG, void *)
\end{verbatim}

\subsection{Checking for Signals}

\begin{verbatim}
signals = CheckSignal(mask)
D0		      D1

ULONG CheckSignal(ULONG)
\end{verbatim}



\subsection{Display an Error Requester}

\begin{verbatim}
status = ErrorReport(code, type, arg1, device)
D0                    D1    D2    D3     D4

BOOL ErrorReport(LONG, LONG, ULONG, struct MsgPort *)
\end{verbatim}

\subsection{Generating an Error Message}

\begin{verbatim}
len = Fault(code, header, buffer, len)
D0           D1     D2      D3    D4

LONG Fault(LONG, STRPTR, STRPTR, LONG)
\end{verbatim}

\subsection{Printing an Error Message}

\begin{verbatim}
success = PrintFault(code, header)
D0                    D1     D2   

BOOL PrintFault(LONG, STRPTR)
\end{verbatim}

\subsection{Printing a String to the Error Stream}

\begin{verbatim}
error = PutErrStr(str)
D0                D1

LONG PutErrStr(STRPTR)
\end{verbatim}

\subsection{Receive Information when a Volume is Request}

\begin{verbatim}
res = VolumeRequestHook(volume)
D0			  D1

LONG VolumeRequestHook(UBYTE *volume)
\end{verbatim}

\begin{thebibliography}{99}
\bibitem{Bantam} Commodore-Amiga Inc:
{\sl AmigaDOS Manual, $3^{\mbox{\tiny rd}}$ Edition}
Random House Information Group (1991)  
\bibitem{mc030} Motorola MC68030UM/AD Rev. 2:
{\sl MC68030 Enhanced 32-Bit Microprocessor User's Manual, 3rd ed.}
Prentice Hall, Englewood Cliffs, N.J. 07632 (1990)
\bibitem{mc040} Motorola MC68040UM/AD Rev. 1:
{\sl MC68040 Microprocessor User's Manual, revised ed.}
Motorola (1992,1993)
\bibitem{mc060} Motorola MC68060UM/AD Rev. 1:
{\sl MC68060 Microprocessor User's Manual.}
Motorola (1994)
\bibitem{mcfam} Motorola MC68000PM/AD Rev. 1:
{\sl Programmer's Reference Manual.}
Motorola (1992)
\bibitem{yuchen} Yu-Cheng Liu:
{\sl The M68000 Microprocessor Family.}
Prentice-Hall Intl., Inc. (1991)
\bibitem{rkrmlib} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Libraries. 3rd. ed.}
Addison-Wesley Publishing Company (1992)
\bibitem{rkrmdev} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Devices. 3rd. ed.}
Addison-Wesley Publishing Company (1992)
\bibitem{rkrmiia} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Includes and Autodocs. 3rd. ed.}
Addison-Wesley Publishing Company (1991)
\bibitem{guru} Ralph Babel:
{\sl The Amiga Guru Book.}
Ralph Babel, Taunusstein (1993)
\end{thebibliography}
%\begin{theindex}
\printindex
%\end{theindex}
\end{document}
