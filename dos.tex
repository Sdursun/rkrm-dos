\documentclass[10pt,twoside]{book}
\usepackage{a4}
\usepackage{times}
\usepackage{longtable}
\usepackage{forest}
%
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\textwidth}{15.2cm}
\setlength{\footskip}{1.6cm}
%\setlength{\footheight}{0.5cm}
\setlength{\topmargin}{0.0cm}
\setlength{\headheight}{0.5cm}
\setlength{\headsep}{1.5cm}
\setlength{\topskip}{0.5cm}
\setlength{\textheight}{21.8cm}
%
\usepackage{fancyhdr}
%\nonfrenchspacing
\usepackage{latexsym}
\usepackage{t1enc}
\usepackage[latin1]{inputenc}
\usepackage{index}
\pagestyle{headings}
\pagestyle{fancy}
%
\renewcommand{\labelitemi}{\raisebox{0.3ex}{\tiny $\Box$}}
%
%
\renewcommand{\sectionmark}[1]{%
\markboth{#1}{}}
\fancyhead{}
\fancyfoot{}
\fancyfoot[LE]{{\sf \thepage} \hspace{1em} {\sfi Rom Kernel Reference Manual: DOS}}
\fancyfoot[RO]{{\sfi \leftmark} \hspace{1em} {\sf \thepage}}
% Redefine the plain page style
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyfoot[LE]{{\sf \thepage} \hspace{1em} {\sfi Rom Kernel Reference Manual: DOS}}
  \fancyfoot[RO]{{\sfi \leftmark} \hspace{1em} {\sf \thepage}}
  \renewcommand{\headrulewidth}{2.0mm}
  \renewcommand{\footrulewidth}{0.0mm}
}
\renewcommand{\headrulewidth}{2.0mm}
\renewcommand{\footrulewidth}{0.0mm}
%
\newcommand{\sfi}{\sffamily\slshape}
\newcommand{\sfb}{\sffamily\bfseries}
\newcommand{\cnot}{\symbol{126}}
\setcounter{secnumdepth}{4}
\setlength{\LTpre}{0pt}
\setlength{\LTpost}{0pt}
%
%
\newcounter{rkrmtablecount}
%
\newenvironment{rkrmtable}[1]%
{%
\nopagebreak[5]%
\begin{center}%
\begin{minipage}{15.2cm}%
\begin{center}%
\refstepcounter{rkrmtablecount}
{\sfb Table \arabic{rkrmtablecount}: #1} \\[1ex]
\begin{tabular}{|ll|} \hline
}{%
\end{tabular}%
\end{center}%
\end{minipage}%
\end{center}%
}
%
\newenvironment{rkrmtabular}[1]%
{%
\nopagebreak[5]%
\begin{center}%
\refstepcounter{rkrmtablecount}
{\sfb Table \arabic{rkrmtablecount}: #1} \\[1ex]
}{%
\end{center}%
}
%
\newlength{\punchlinewidth}
\setlength{\punchlinewidth}{\textwidth}
\addtolength{\punchlinewidth}{-\rightmargin}
\addtolength{\punchlinewidth}{-\leftmargin}
\addtolength{\punchlinewidth}{-4.2pt}
%
\newlength{\jpgtablewidth}
\setlength{\jpgtablewidth}{\textwidth}
\addtolength{\jpgtablewidth}{-\rightmargin}
\addtolength{\jpgtablewidth}{-\leftmargin}
\addtolength{\jpgtablewidth}{-4.2pt}
%
%
\newcommand{\punchline}[2]{%
\bigskip{\setlength{\arrayrulewidth}{1mm}
\begin{tabular}{|p{\punchlinewidth}}
{\sfi #1}$\quad$#2
\end{tabular}
}\bigskip}

%
% Insert the page under the given key into the index.
\newcommand{\key}[1]{\index{#1@{\scriptsize{} #1}}}
% The same again, but make this the main entry.
\newcommand{\mkey}[1]{\index{#1@{\scriptsize{} #1}|emph}}
% An entry defining a library function call
\newcommand{\call}[1]{{\bf J2K::#1()\key{#1()}}}
%
\makeindex
%
%
\begin{document}
\thispagestyle{empty}
\pagenumbering{roman}
\begin{center}
\vspace*{\fill}
{\Huge Amiga ROM Kernel Reference Manual\\}
\bigskip
{\Huge DOS\\}
\bigskip
{\huge\sc
Thomas Richter\\}
\bigskip
\end{center}
\bigskip
\vspace*{\fill}
\bigskip
{\small Copyright © 2023 by Thomas Richter, all rights reserved. This
publication is freely distributable under the restrictions stated below, but is
also Copyright © Thomas Richter.

Distribution of the publication by a commercial organization without written
permission from the author to any third party is prohibited if any payment is
made in connection with such distribution, whether directly (as in payment for a
copy of the publication) or indirectly (as in payment for some service related
to the Publication, or payment for some product or service that includes a
copy of the publication ``without charge''; these are only examples, and
not an exhaustive enumeration of prohibited activities).

However, the following methods of distribution involving payment shall not in
and of themselves be a violation of this restriction:
\begin{enumerate}
\item Distributing the Program on a physical data carrier (e.g. CD-ROM,
  DVD, USB-Stick, Disk...) provided that:
  \begin{enumerate}
  \item the Archive is reproduced entirely and verbatim on such data carrier,
    including especially this licence agreement;
  \item the data carrier is made available to the public for a nominal
    fee only, i.e. for a fee that covers the costs of the data carrier,
    and shipment of the data carrier;
  \item a data carrier with the Program installed is made available to the
    author for free except for shipment costs, and
  \item provided further that all information on said data carrier is
    redistributable for non-commercial purposes without charge.
  \end{enumerate}
\end{enumerate}

Redistribution of a modified version of the publication is prohibited in any
way, by any organization, regardless whether commercial or non-commercial.
Everything must be kept together, in original and unmodified form. }

\bigskip

{\small \sc Disclaimer: This publication is provided ``as is'' without any
warranty of any kind, either expressed or implied, including, but not limited
to, the implied warranties of merchantability and fitness for any particular
purpose. Further, the author does not warrant, guarantee, or make any
representation regarding the use of, or the results of the use of, the
information contained herein in term of correctness, accuracy, reliability,
currentness, or otherwise; the entire risk as to its quality and accuracy is
assumed solely by the user. Should the information prove inaccurate, the user
(and not the author) assumes the either cost of all necessary correction. In no
event will the author be liable for direct, indirect, incidental, or
consequential damages resulting from any defect or inaccuracy in this
publication, even if advised of the possibility of such damages. Some laws do
not allow the exclusion or limitation of implied warranties or liabilities for
incidental or consequential damages, so the above limitation or exclusion may
not apply.}

\bigskip

{\small {\it Amiga} is a registered trademark, {\it Amiga-DOS}, {\it Exec} and
{\it Kickstart} are registered trademarks of Amiga Intl. {\it Motorola} is a
registered trademark of Motorola, inc. {\it Unix} is a trademark of
the Open Group.}
\newpage
\vspace*{\fill}
\newpage
\tableofcontents
\pagenumbering{arabic}
%
%
\chapter{Introduction}
\section{Purpose}
The purpose of this manual is to provide a comprehensive documentation
of the AmigaDOS subsystem of the Amiga Operation System. This
subsystem is represented by the \emph{dos.library}, and it provides
services around files, file systems and stream-based input and
output. While the Amiga ROM Kernel Reference Manuals~\cite{rkrmlib}
document major parts of the AmigaOs, they do not include a volume on
AmigaDOS itself. This is due to the history of AmigaDOS which is
nothing but a port of the TRIPOS to the Amiga, and thus its
documentation became available as the AmigaDOS manual\cite{Bantam}
separately. This book itself is, similar to AmigaDOS, based on the
TRIPOS manual which has been augmented and updated to reflect the
changes that were necessary to fit TRIPOS into AmigaOs. Unfortunately,
the book is hard to obtain, and also leaves a lot to deserve.
\smallskip{}

Good third party documentation is available in the form of the Guru
Book\cite{guru}, though this source is out of print and even harder to
obtain. It covers also other aspects of AmigaOs that go beyond
AmigaDOS such that its focus is a bit different than this work.
\smallskip{}

This work attempts to fill this gap by providing a comprehensive and
complete documentation of the AmigaDOS library and its subsystems in
the style of the ROM Kernel Reference Manuals.

\section{Language and Type Setting Conventions}
The words \emph{shall} and \emph{shall not} indicate normative
requirements software shall or shall not follow or in order to satisfy the
interface requirements of AmigaOs. The words \emph{should} and
\emph{should not} indicate best practise and recommendations that are
advisable, but not strictly necessary to satisfy a particular
interface. The word \emph{may} provides a hint to a possible
implementation strategy.
\smallskip{}

The word \emph{must} indicates a logical consequence from existing
requirements or conditions that follows necessarily without
introducing a new restriction, such as in ``if $a$ is 2, $a+a$
\emph{must} be 4''.

\punchline{Worth to remember!}{Important aspects of the text are
  indicated with a bold vertical bar like this.}

Terms are indicated in \emph{italics}, e.g. the \emph{dos.library}
implements interface of \emph{AmigaDOS}. Data structures and
components of source code are printed {\tt in courier} in fixed-width
font, reassembling the output of a terminal, e.g.

\begin{verbatim}
typedef unsigned char UBYTE; /* an 8-bit unsigned integer */
typedef long LONG;           /* a 32-bit integer          */
\end{verbatim}

\chapter{Elementary Data Types}
\section{The dos.library}
\emph{AmigaDOS} as part of the \emph{Amiga Operating System} or short
\emph{AmigaOs} is represented by the ROM-based
\emph{dos.library}. This library is typically opened by the startup
code of most compilers anyhow, and its base pointer is placed into
{\tt DOSBase} by this startup code:
\begin{verbatim}
struct DosLibrary *DOSBase;
\end{verbatim}
Hence, in general, there is no need to open this library manually.
\smallskip{}

The structure \emph{\mkey{DosLibrary}struct DosLibrary} is defined in
{\tt dos/dosextens.h}, but its layout and its members are usually not
required and should rather not be accessed directly. Instead, the
library provides accessor functions to read many objects contained
within it.
\smallskip{}

If you do not link with compiler startup code, the base pointer of the
\emph{dos.library} can be obtained similar to that of any other library:
\begin{verbatim}
#include <proto/exec.h>
#include <proto/dos.h>
#include <exec/libraries.h>
#include <dos/dos.h>

...
if ((DOSBase = (struct DosLibrary *)(OpenLibrary(DOSNAME,47))) {
  ...
  CloseLibrary((struct Library *)DOSBase);
}
\end{verbatim}

Unlike many other operating system, the \emph{dos.library} does not
manage disks or files itself, neither does it provide access to
hardware interface components. It rather implements a \emph{virtual
  file system} which forwards requests to its subsystems, called
\emph{handlers} or \emph{file systems}, see~\ref{sec:handlerovv}.

\section{Booleans}

AmigaDOS uses a somewhat different convention for booleans, i.e. truth
values defined in the file {\tt dos/dos.h}:

\begin{rkrmtable}{DOS Truth Values} \label{table:dosbool}
{\bf Define} & {\bf Value}\\ \hline \hline
DOSFALSE & 0  \\ \hline
DOSTRUE  & -1 \\ \hline
\end{rkrmtable}

Note that the C language instead uses the value $1$ for
{\tt TRUE}. Code that checks for zero or non-zero return codes will
function normally, however code shall not compare to {\tt TRUE} in
boolean tests.

\section{Pointers and BPTRs} \label{sec:bptrs}
AmigaDOS is a descendent of the \emph{TRIPOS system} and as such
originally implemented in the BCPL language. As of Kickstart 2.0,
AmigaDOS was re-implemented in C and assembler, but this
implementation had to preserve the existing interface based on BCPL
conventions.
\smallskip{}

BCPL is a typeless language that structures the memory of its host
system as an array of 32-bit elements enumerated contiguously from
zero up. Rather than pointers, BCPL communicates the position of its
data structures in the form of indices of the first 32-bit element of
such structures. As each 32-bit group is assigned its own index, one
can obtain this index by dividing the byte-address of an element by 4,
or equivalently, by right-shifting the address by two bits. This has
the consequence that (most) data structures passed into and out of the
dos.library shall be aligned to 32-bit boundaries. Similarly, in order
to obtain the byte-address of a BPCL structure, the index is
multiplied by 4, or left-shifted by 2 bits.

\punchline{Not on the Stack!}{Since BPCL structures must have an
  address that is divisible by 4, you should not keep such structures
  on the stack as the average compiler will not ensure long word
  alignment for automatic objects. In the absense of a dedicated
  constructor function such as
  \emph{\key{AllocDosObject()}AllocDosObject()}, a safe strategy is
  use the exec.library memory allocation functions such as
  \emph{\key{AllocMem()}AllocMem()} or
  \emph{\key{AllocVec()}AllocVec()} to obtain memory for holding
  them.}

These indices are called \emph{BCPL pointers} or short \emph{\key{BPTR}BPTR}s,
even though they are not pointers in the sense of the C language, but
rather integer numbers as indices to an array of {\tt LONG}
(i.e. 32-bit) integers. In order to communicate this fact more
clearly, the {\tt dos/dos.h} include file defines the following data
type:

\mkey{BPTR}
\begin{verbatim}
typedef long  BPTR;                 /* Long word pointer */
\end{verbatim}

Conversion from BCPL pointers to conventional C pointers and back are
formed by the following macros, also defined in {\tt dos/dos.h}:

\mkey{BADDR()} \mkey{MKBADDR()}
\begin{verbatim} 
/* Convert BPTR to typical C pointer */
#define BADDR(x)        ((APTR)((ULONG)(x) << 2))
/* Convert address into a BPTR */
#define MKBADDR(x)      (((LONG)(x)) >> 2)
\end{verbatim}

Luckely, in most cases callers of the \emph{dos.library} do not need
to convert from and to BPTRs but can rather use such ``pointers'' as
\emph{opaque values} or \emph{handles} representing some AmigaDOS
objects.
\smallskip{}

It is certainly a burden to always allocate temporary BCPL objects
from the heap, and doing so may also fragment the AmigaOs memory
unnecessarily. However, allocation of automatic objects from the stack
does not ensure long-word aligment in general. To work around this
burden, one can use a trick and instead request from the compiler a
somewhat longer object of automatic lifetime and align the requested
object manually within the memory obtained this way. The following
macro performs this trick:

\begin{verbatim}
#define D_S(type,name) char a_##name[sizeof(type)+3]; \
                       type *name = (type *)((ULONG)(a_##name+3) & ~3UL)
\end{verbatim}

It is used as follows:
\begin{verbatim}
D_S (struct FileInfoBlock, fib); 
\end{verbatim}

At this point, fib is pointer to a properly aligned {\tt struct
FileInfoBlock}, e.g. this is equivalent to
\begin{verbatim}
struct FileInfoBlock _tmp;
struct FileInfoBlock *fib = &tmp;
\end{verbatim}
except that the created pointer is properly aligned and can safely be
passed into the \emph{dos.library}.
\smallskip{}

Similar to the C language, a pointer to a non-existing element is
expressed by the special pointer value $0$. While this is called the
{\tt NULL} pointer in C, it is better to reserve another name for it
in BPCL as its pointers are rather indices. The following convention
is suggested to express an invalid \emph{BPTR}:

\begin{verbatim}
#define ZERO 0L
\end{verbatim}

Clearly, with the above convention, the BCPL {\tt \mkey{ZERO}ZERO} pointer
converts to the C {\tt \mkey{NULL}NULL} pointer and back, even though the two are
conceptionally something different: The first being the index to the
first element of the host memory array, the later the pointer to the
first address.

\section{C strings and BSTRs}
While the C language defines \emph{\mkey{String}strings} as
0-terminated arrays of {\tt char}, and AmigaOs in particular to
0-terminated arrays of {\tt UBYTE}s, that is, unsigned characters, the
BPCL language uses a different convention, namely that of a {\tt
  UBYTE} array whose first element contains the size of the string to
follow. They are not necessarily 0-terminated either. If BCPL strings
are passed into BCPL functions, or are part of BCPL data structures,
then typically in the form of a \emph{\key{BPTR}BPTR} to the 32-bit
element containing the size of the string its 8 most significant
bits. The include file {\tt dos/dos.h} provides its own data type for
such strings:

\mkey{BSTR}
\begin{verbatim}
typedef long  BSTR;                 /* Long word pointer to BCPL string  */
\end{verbatim}

Luckely, functions of the \emph{dos.library} take C strings as
arguments and perform the conversion from C strings to their BCPL
representation as \emph{BSTR}s internally, such that one rarely gets
in contact with this type of strings. They appear as part of some
AmigaDOS structures to be discussed, and as part of the interface
between the \emph{dos.library} and its handlers, e.g. file systems.
However, even though users of the \emph{dos.library} rarely come in
contact with \emph{BSTR}s themselves, the \emph{BCPL} convention has
an important consequence, namely that (most) strings handled by the
\emph{dos.library} cannot be longer than 255 characters as this is the
limit imposed by the BCPL convention.

\punchline{Lengh-Limited Strings}{Remember that most strings that are
  passed into the \emph{dos.library} are internally converted to
  \emph{BSTR}s and thus cannot exceed a length of 255 characters.}

Unfortunately, even as of the latest version of \emph{AmigaDos}, the
\emph{dos.library} is ill-prepared to take longer strings, and will
likely fail or mis-interpret the string passed in. If longer strings
are requried, e.g. as part of a \emph{\key{path}path}, it is
(unfortunately) in the responsibility of the caller to take this path
appart into components and iterate through the components manually,
see also section~\ref{sec:files}.

\section{Files}
Files\key{File} are streams of bytes together with a file pointer that
identifies the next position to be read, or the next byte position to
be filled. Files are explained in more detail in section~\ref{sec:file}.

\section{Locks}
Locks\key{Lock} are access rights to a particular object on a file
system. A locked object cannot be altered by any other
process. Section~\ref{sec:lock} provides more details on locks.

\section{Processes}
AmigaDOS is a multi-tasking system operating on top of the \emph{exec}
kernel~\cite{rkrmlib}. As such, it can operate multiple tasks at once,
where the tasks are assigned to the CPU in a round-robin fashion. A
\emph{Process}\key{Process} is an extension of an AmigaOs
\emph{Task}\mkey{Task} that includes additional state information
relevant to AmigaDOS, such as a \emph{current directory} \emph{Current
  Directory} it operates in, a \emph{default file system}\key{Default
  file system}, a \emph{console}\key{console} it is connected to, and
default input, output and error streams. Processes are explained in
more detail in section~\ref{sec:process}.

\section{Handlers and File Systems} \label{sec:handlerovv}
\emph{Handlers} are special processes that manage files on a volume, or that
input or output data to a physical device. AmigaDOS itself delegates
all operations on files to such handlers. Handlers are introduced in
section~\ref{sec:handler}.
\smallskip{}

\emph{File systems} are special handlers that organize the contents of
data carriers such as hard disks, floppies or CD-Roms in the form of
files and directories, and provides access to such objects through the
\emph{dos.library}. File systems interpret paths (see~\ref{sec:paths})
in order to locate objects such as files and directories on such data
carriers.

\chapter{Files} \label{sec:file}

\section{What are Files?}
\emph{\mkey{File}Files} are streams of sequences of bytes that can be read from
and written to, along with a file pointer that points to the next byte
to be read, or the next byte to be written or overwritten. Files may
have an \emph{End-of-File position}, beyond which the file pointer can
not advance when reading bytes from it.

\section{Interactive vs. non-Interactive Files} \label{sec:interactive}

AmigaDOS knows two types of files: \emph{Interactive} and
\emph{non-interactive} files.
\smallskip{}

\emph{Non-interactive} files are stored on some persistent data carrier;
unless modified by a process\key{Process}, the contents of such non-interactive
files does not change. They also have a defined \emph{file size}. The
file size is the number of bytes between the start of the file and the
end-of-file position, or short \emph{EOF position}\mkey{EOF}. This file size
does not change unless some process\key{Process} writes to the file, which may or
may not be the same process that reads from the file.
\smallskip{}

Examples for non-interactive files are data on a disk, such as a
floppy or a harddisk. Such files have a name, possibly a path within a
hierachical file system, and possibly multiple protection flags that
define which type of actions can be applied to a file; such flags
define whether the file can be read from, written to, and so on.
\smallskip{}

\emph{Interactive} files depend on the interaction of the computer
system with the outside world, and their contents can change due to
such interaction. Interactive files may not define a clear end-of-file
position, and an attempt to read from them or write to them may block
an indefinite amount of time until triggered by an external event.
\smallskip{}

Examples for interactive files are the console\key{Console}, where reading from it
depends on the user entering data in a console window and output
corresponds to printing to the console; or the serial port, where read
requests are satisfied by serial data arriving at the serial port and
written bytes are transmitted out of the port. The parallel port is
another example of an interactive file. Requests to read from it
result in an error condition, while writing prints data on a printer
connected to the port. Writing may block indefinitely if the printer
runs out of paper or is turned off.

\section{Paths and File Names} \label{sec:paths}
Files are identified by \emph{\mkey{Path}paths}, which are strings
from which AmigaDOS locates a process\key{Process} through which
access to the file is managed. Such a process is called the
\emph{\key{Handler}Handler} of the file, or, in case of files of on a
data carrier, also the \emph{\key{File System}File System}.  AmigaDOS
itself does not operate on files directly, but delegates such work to
its handler.
\smallskip{}

A \emph{path} is broken up into two parts: An optional device or
volume name terminated by a colon (``:''), followed by string that
identifies the file within the handler identified by the first part.
\smallskip{}

The first part, if present, is interpreted by AmigaDOS itself. It
relates to the name of a handler (or file system) of the given name,
or a known disk volume\key{Volume}, or a logical volume of the name
within the AmigaDOS \emph{device list}\key{Device List}. These concepts are
presented in further detail in section~\ref{sec:devicelist}.
\smallskip{}

The second, or only part is interpreted by the handler identfied by
the first part.

\subsection{Devices, Volumes and Assigns}
The first part of a path, up to the colon, identifies the device, the
volume or the assign a file is located in.

\subsubsection{Devices} \label{sec:deviceoverview}
A \emph{\mkey{Device name}device name} identifies the handler or file
system directly. Handlers are typically responsible for particular
hardware units within the system, for example for the first floppy
drive, or the second partition of a harddisk. For example, {\tt df0}
is the name of the handler responsible for the first floppy drive,
regardless of which disk is inserted into it.
\smallskip{}

Table~\ref{table:romdevices} lists all devices AmigaDOS mounts itself
even without a boot volume available. They can be assumed present any
time.

\begin{rkrmtable}{System defined devices} \label{table:romdevices}
{\bf Device Name} & {\bf Description}\\ \hline \hline
{\tt DF0}              & First floppy drive\\ \hline
{\tt PRT}              & Printer\\ \hline
{\tt PAR}              & Parallel port\\ \hline
{\tt SER}              & Serial port\\ \hline
{\tt CON}              & Line-interactive console\\ \hline
{\tt RAW}              & Character based console\\ \hline
{\tt PIPE}             & Pipeline between processes\\ \hline
{\tt RAM}              & RAM-based file handler\\ \hline
\end{rkrmtable}

If more than one floppy drives are connected to the system, they are
named {\tt DF1} through {\tt DF3}. If a hard disk is present, then the device
name(s) of the harddisk partitions depend on the contents of Rigid
Disk Block, see~\ref{rkrmdev}. These names can be selected upon
installation of the harddisks, e.g. through \emph{HDToolBox}.  The
general convention is to name them {\tt DH0} and following.
\medskip{}

The following device names have a special meaning and do not belong to
a particular device:

\begin{rkrmtable}{System defined devices} \label{table:specialdevices}
{\bf Name} & {\bf Description} \\ \hline \hline
{\tt *}          & the console of the current process\\ \hline  
{\tt CONSOLE}    & the console of the current process\\ \hline
{\tt NIL}        & the data sink\\ \hline
\end{rkrmtable}

The {\tt NIL}\mkey{NIL} device is a special device without a handler
that is maintained by AmigaDOS itself. Any data written into it
vanishes completely, and any attempt to read data from it results in
an end-of-file\key{EOF} condition.
\smallskip{}

The {\tt *}\mkey{* (file name)}, if used as complete path name without
a trailing colon, is the current console of the process\key{Process}, if such a
console\key{console} exists. Any data output to the file named {\tt *} will be
printed on the console. Any attempt to read from {\tt *} will wait on
the user to input data on the console, and will return such data.

\punchline{Not a wildcard!}{Unlike other operating systems, the
  asterisk {\tt *} is \emph{not} a wildcard under AmigaDOS. It rather
  identifies the current console of a process, or is used as escape
  character in AmigaDOS shell scripts}.

The {\tt CONSOLE}\mkey{CONSOLE (device)} device is the default console
of the process\key{Process}. Unlike {\tt *}, but like any other device name, it
shall be followed by a colon, and an optional job name. Such job names
form \emph{logical consoles} that are used by the shell for job
control purposes.

\punchline{Prefer the stars}{The difference between {\tt *} and {\tt
    CONSOLE} is subtle, and the former should be preferred as it
  identifies the process as part of a particular shell job. An attempt
  to output to {\tt CONSOLE:} may block the current process as it does
  not identify it properly as part of its job, but rather denotes the
  job started when creating the shell. Thus, in case of doubt, use the
  {\tt *} without any colon if you mean the console.}

Additional devices can be loaded into the system by the \emph{Mount}\key{Mount}
command, see section~\ref{sec:handlers}.

\subsubsection{Volumes} \label{sec:volumelist}
A \emph{\mkey{Volume name}volume name} identifies a particular data
carrier within a physical drive. For example, it may identify a
particular floppy disk, regardless of the drive it is inserted it. For
example, the volume name ``Workbench3.2'' relates always to the same
floppy, regardless of whether it is inserted in the first {\tt df0} or
second {\tt df1} drive.

\subsubsection{Assigns} \label{sec:assignlist}
An \emph{\mkey{Assign}assign} or \emph{logical volume} identifies a
subset of a files within a file system under a unique name. Such
assigns are created by the system or by the user helping to identify
portions of the file system containing files that are of particular
relevance for the system. For example, the assign {\tt C} contains all
commands of the boot shell, and the assign {LIBS} contains dynamically
loadable system libraries. Such assigns can be changed or redirected, and by that
the system can be instructed to take system resources from other parts of a file system,
or entirely different file systems.
\medskip{}

Assigns can be of three types: \emph{Regular assigns},
\emph{non-binding assigns} and \emph{late assigns}. \emph{Regular
  assigns} bind to a particular directory on a particular volume. If
the \emph{assign} is accessed, and the original volume the bound
directory is not available, the system will ask to insert this
particular volume, and no other volume will be accepted.
\smallskip{}

\emph{Regular assigns} can also bind to multiple directories at once,
in which case a particular file or directory within such a
\emph{multi-assign} is searched in all directories bound to the
assign. A particular use case for this is the {\tt FONTS} assign,
containing all system-available fonts. Adding another directory to
{\tt FONTS} makes additional fonts available to the system without
loosing the original ones.
\smallskip{}

\emph{Regular assigns} have the drawback that the volume remains known
to the system, and the corresponding volume icon will not vanish from
the workbench. They also require the volume to be present at the time
the assign is created.
\smallskip{}

\emph{Non-binding assigns} avoid these problems by only storing the
symbolic path the assign goes to; whenever the assign is accessed, any
volume of the particular name containing the particular path will
work. However, if this also implies that the target of the assign is
not necessarily consistent, i.e. if the assign is accessed later on,
another volume with different content will be accepted by the system.
\smallskip{}

\emph{Late assigns} are a compromize between \emph{regular assigns}
and \emph{non-binding assigns}. AmigaDOS initially only stores a
target path for the assign, but when the assign is accessed the first
time, the assign is converted to a \emph{regular assign} and thus then
binds to the particular directory of the particular volume that was
inserted at the time of the first access.
\medskip{}

Table~\ref{table:romassigns} lists the assigns made by AmigaDOS
automatically during bootstrap; except for the {\tt SYS} assign, they
all go to a directory of the same name on the boot volume. They are
all \emph{regular assigns}, except for {\tt ENVARC}, which is
\emph{late assign}.

\begin{rkrmtable}{System defined assigns} \label{table:romassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt C}           & Boot shell commands\\ \hline
{\tt L}           & AmigaDOS handlers and file systems\\ \hline
{\tt S}           & AmigaDOS Scripts \\ \hline
{\tt LIBS}        & AmigaOs libraries \\ \hline
{\tt DEVS}        & AmigaOs hardware drivers \\ \hline
{\tt FONTS}       & AmigaOs fonts \\ \hline
{\tt ENVARC}      & AmigaOs preferences (late)\\ \hline
{\tt SYS}         & The boot volume \\ \hline
\end{rkrmtable}

In addition to the above table, the following assigns are handled by
AmigaDOS internally and are not part of the \emph{device
  list}\key{Device list}, (see section \ref{sec:devicelist}):

\begin{rkrmtable}{System defined assigns} \label{table:specialassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt PROGDIR}     & Location of the executable\\ \hline
\end{rkrmtable}

Thus, {\tt PROGDIR}\mkey{PROGDIR} is the directory the currently
executed binary was loaded from. Note that {\tt PROGDIR} does not
exist in case an executable file was not loaded from disk, probably
because it was either taken from ROM or was made resident. More on
resident executables is found in section~\ref{sec:commands}.
\smallskip{}

Additional assigns can become necessary for a fully operational
system, though these assigns are created through the
\emph{Startup-sequence}\key{Startup-Sequence}, a particular AmigaDOS
script residing in the S assign which is executed by the boot shell.
Table~\ref{table:startupassigns} lists some of them.

\begin{rkrmtable}{Assigns made during bootstrap} \label{table:startupassigns}
{\bf Assign Name} & {\bf Description}\\ \hline \hline
{\tt ENV}         & Storage for active preferences and global variables\\ \hline
{\tt T}           & Storage for temporary files\\ \hline
{\tt CLIPS}       & Storage for clipboard contents\\ \hline
{\tt KEYMAPS}     & Keymap layouts\\ \hline
{\tt PRINTERS}    & Printer drivers\\ \hline
{\tt REXX}        & ARexx scripts\\ \hline
{\tt LOCALE}      & Catalogs and localization\\ \hline
\end{rkrmtable}

Additional assigns can always be made with the
\emph{Assign}\key{Assign} command, see section~\ref{sec:handlers}.

\subsection{Relative and Absolute Paths}

As introduced in section~\ref{sec:paths}, a path consists either of an
device, volume or assign name followed by a colon followed by a second
part, or the second part alone. If a device, volume or assign name is
present, such a path is said to be an \emph{absolute path} because it
identifies a location within a logical or physical volume.
\smallskip{}

If no first part is present, or if it is empty, i.e. the colon is the
first part of the path, AmigaDOS uses information from the calling
process\key{Process} to identify a suitable handler. Details on this are provided
in section~\ref{sec:process}. Such a path is called a
\emph{relative path}.
\smallskip{}

This second part is forwarded to the handler and is not interpreted by
the \emph{dos.library}. It is then within the responsibility of the
handler to interpret this path and locate a file within the data
carrier it manages, or to configure an interface to the outside world
according to this path.
\smallskip{}

In general, the \emph{dos.library} does not impose a particular syntax
on how this second part looks like. However, several support functions
of AmigaDOS implicitly define conventions file systems should follow
to make these support functions workable and it is therefore advisable
for file system implementors to follow these conventions.

\subsection{Maximum Path Length} \label{sec:pathlimit}

The \emph{dos.library} does not enforce a limit on the size of file or
directory names, except that the total length of a path including all
of its components shall not be larger than 255 characters. This is
because it is converted to a BSTR within the
\emph{dos.library}. How large a component name can be is a matter of
the file system itself. The \emph{Fast File System} includes variants
that limit file names to 30, 56 or 106 characters.
\smallskip{}

File systems typically do not report an error if the maximum file
name is exceeded; instead, the name is clamped to the maximum size
without further notice, which may lead to undesired side effects. For
example, a file system may clip or remove a trailing {\tt .info} from
a workbench icon file name without ever reporting this, resulting in
unexpected side effects. The \emph{icon.library} and
\emph{workbench.library} of AmigaOs take care to avoid such file names
and double check created objects for correct names.

\subsection{Flat vs. Hiearchical File Systems} \ref{sec:flathierarchical}
A flat file system organizes files as a single list of all files
available on a physical data carrier. For large amounts of files, such
a representation is clearly burdensome as files may be hard to find
and hard to identify.
\smallskip{}

For this reason, all file systems provided by AmigaOs are
\emph{hierarchical} and organize files in nested sets of
\emph{directories}\mkey{Directory}, where each directory contains
files or additional directories. The topmost directory of a volume forms
the \emph{root directory}\mkey{Root Directory} of this volume.
\smallskip{}

While AmigaDOS itself does not enforce a particular convention, all
file systems included in AmigaDOS follow the convention that a path
consists of a sequence of zero or more directory names separated by a
forwards slash (``/''), and a final file or directory name.

\subsubsection{Locating Files or Directories} \label{sec:locate}

When attempting to locate a particular file or directory, the
\emph{dos.library} first checks whether an absolute path name is
present. If so, it starts from the root directory on the device,
physical or logical volume identified by the device or volume name and
delegates the interpretation of the path to the handler.
\smallskip{}

Otherwise, it uses the \emph{current directory} of the calling
process\key{Process} to locate a handler responsible for the
interpretation of the path name. If this current directory is {\tt
  ZERO} (see section~\ref{sec:bptrs}), it uses the \emph{default file
  system}\key{Default file system} of the process, which by itself,
defaults to the boot file system.
\smallskip{}

The second part of the path interpretation is up to the file system
identified by the first step and is performed there, outside of the
\emph{dos.library}. If the path name includes a colon (``:''), then locating
a file starts from the root of the inserted volume. This also includes
the special case of an absent device or volume name, though a present
colon, i.e. ``:'' represents the root directory of the volume to which
the current directory belongs.
\medskip{}

The following paragraphs describe a recommended set of operations an
AmigaDOS file system should follow. A path consists of a sequence of
components separated by forward slashes (``/'').
\smallskip{}

To locate a file, the file system should work iteratively through the
path, component by component: A single isolated ``/'' without a
preceeding component indicates the parent directory of the current
directory. The parent directory of the root directory is the root
directory itself.
\smallskip{}

Otherwise, a component followed by ``/'' instructs the handler to enter
the directory of given by the component, and continue searching there.
\smallskip{}

Scanning terminates when the file system reaches the last component. The
file or directory to find is then the given by the last component
reached during the scan.
\smallskip{}

As scanning through directories starts with the current directory and
stops when the end of the path has been reached, the empty string
indicates the current directory.

\punchline{No Dots Here}{Unlike other operating systems, AmigaDOS does
  not use ``.'' and ``..'' to indicate the current directory or the
  parent directory. Rather, the current directory is represented by
  the empty string, and the parent directory is represented by an
  isolated forwards slash without a preceeding component.}

Thus, for example, ``:S'' is a file or directory named ``S'' in the
root directory of the current directory of the process, and
``//Top/Hi'' is a file or directory named ``Hi'' two directories up
from the current directory, in a directory named ``Top''.

\subsection{Case Sensitivity}

The \emph{dos.library} does not define whether file names are
case-sensitive or insensitive, except for the device or volume name
which is case-insensitive. Most if not all AmigaDOS file-systems are
also case-insensitve, or rather should. Some variants of the
\emph{Fast File System} do not handle case-insensitive comparisons
correctly on non-ASCII characters, i.e. ISO-Latin code points whose
most-significant bit is set, see section~\ref{sec:ffs} for
details. These variants should be avoided and the ``international''
variants should be preferred.

\section{Opening Files} \label{sec:open}
To read data from or write data to a file, it first needs to be opened
by the {\tt Open()}\mkey{Open()} function:

\begin{verbatim}
file = Open( name, accessMode )
D0           D1    D2

BPTR Open(STRPTR, LONG)
\end{verbatim}
The {\tt name} argument is the \emph{path} the file to be opened,
which is interpreted according to the rules given in
section~\ref{sec:paths}. The argument {\tt accessMode} identifies how
the file is opened. The function returns a {\tt BPTR} to a
\emph{file handle} on success, or {\tt ZERO} on failure. A secondary return
code can be retrieved from {\tt IoErr()} described in
section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case opening the file failed.
\smallskip{}

The access mode shall be one of the following, defined in {\tt dos/dos.h}:

\begin{rkrmtable}{Access Modes for Opening Files} \label{table:openmodes}
{\bf Access Name} & {\bf Description}\\ \hline \hline
{\tt MODE\_OLDFILE}   & Shared access to existing files\\ \hline
{\tt MODE\_READWRITE} & Shared access to new or existing files\\ \hline
{\tt MODE\_NEWFILE}   & Exclusive access to new files\\ \hline
\end{rkrmtable}

\punchline{Length Limited}{As this function needs to convert the path
  argument from a C string to a BSTR, path names longer than 255
  characters are not supported and results are unpredictable if such
  names are passed into Open(). If such long path names cannot be
  avoided, it is the responsibility of the caller to split the path
  name accordingly and potentially walk through the directories
  manually if necessary. Note that this strategy may not be suitable
  for interactive files or handlers that follow conventions for the
  path name that are different from the conventions described in
  section~\ref{sec:locate}.}

The access mode {\tt MODE\_OLDFILE}\mkey{MODE\_OLDFILE} attempts to find an existing
file. If the file does not exist, the function fails. If the file
exists, it can be read from or written from, though simultaneous
access from multiple processes is possible and does not create an
error condition. If multiple processes write to the same file
simultaneously, the result is undefined and no particular order of the
write operations is imposed.
\smallskip{}

The access mode {\tt MODE\_READWRITE}\mkey{MODE\_READWRITE} first attempts to find an
existing file, but if the file does not exist, it will be created
under the name given by the last component of the path. The function
does not attempt to create directories within the path if they do not
access. Once the file is opened, access to the file is shared, even if
it has been just created. That is, multiple processes may then access
it for reading or writing. If multiple processes write to the file
simultenously, the order in which the writes are served is undefined
and depends on the scheduling of the processes.
\smallskip{}

The access mode {\tt MODE\_NEWFILE}\mkey{MODE\_NEWFILE} creates a new file, potentially
erasing an already existing file of the same name if it already
exists. The function does not attempt to create directories within the
path if they do not exist. Access to the file is exclusive, that is,
any attempt to access the file from a second process fails with an
error condition.

\punchline{No Wildcards}{The Open() function, similar to most
  \emph{dos.library} functions, does not attempt to resolve wild cards. That
  is, any character potentially reassembling a wild card, such as
  ``?'' or ``\#'' will taken as a literal and will be used as part of
  the file name. While these characters are valid, they should be
  avoided as they make such files hard to access from the Shell.}

\section{Closing Files}

The {\tt Close()}\mkey{Close()} function writes all internally
buffered data to disk and makes an exclusively opened file accessible
to other processes again.

\begin{verbatim}
success = Close( file )
D0               D1

BOOL Close(BPTR)
\end{verbatim}

The {\tt file} is a BPTR to {\tt FileHandle} identifying the file. The
return code indicates whether the file system could successfully close
the file and write back any data. If the result code is {\tt DOSFALSE},
an error code can be obtained through {\tt IoErr()} described in
section~\ref{sec:misc}. Otherwise, {\tt IoErr()} will not be altered.
\smallskip{}

Unfortunately, not much can be done if closing a file fails and no
general advise is possible how to handle this situation.
\smallskip{}

Attempting to close the {\tt ZERO} file handle returns success
immediately.

\section{Types of Files and Handlers}

As introduced in \ref{sec:interactive}, AmigaDOS distinguishes between
non-interactive files managed by file systems and interactive files
that interact with the outside world. Typically, \emph{file
  systems}\key{File System} create non-interactive files; all other
\emph{handlers}\key{Handlers} create interactive or non-interactive
files, depending on the nature of the handler.

\subsection{Obtaining the Type from a File}

A file can be either interactive, in which case attempts to read or
write data to the file may block indefinitely, or non-interactive
where the amount of available data is determined by file itself. The
{\tt IsInteractive()} function returns the nature of an already opened
file.

\begin{verbatim}
status = IsInteractive( file )
 D0                      D1

BOOL IsInteractive(BPTR)
\end{verbatim}

The {\tt IsInteractive()}\mkey{IsInteractive()} function returns
{\tt TRUE} in case the \emph{file handle} passed in is interactive, or
{\tt FALSE} in case it corresponds to a non-interactive stream of
bytes, potentially on a file system.
This function cannot fail and does not alter {\tt IoErr()}.

\subsection{Obtaining the Type from a Path}

A \emph{handler}\key{handler} that manages physical data carriers and
allows to access named files on such data carriers is a \emph{file
  system}. The {\tt IsFileSystem()}\key{IsFileSystem()} function
determines the nature of a handler given a path (see~\ref{sec:paths})
to a candidate handler.

\begin{verbatim}
result = IsFileSystem(name)
D0                     D1

BOOL IsFileSystem(STRPTR)
\end{verbatim}
The {\tt name} argument is a path that does not need to identify a
physically existing object. Instead, it is used to identify a handler
that would be responsible to such a hypothetical object regardless
whether it exists or not.
\smallskip{}

It is of advisable to provide a path that identifies the handler
uniquely, i.e. a string that is terminated by a colon (``:''). Otherwise,
the call checks whether the \emph{handler} responsible for the current
directory of the calling process is a file system.
\smallskip{}

The returned result is {\tt DOSTRUE} in case the handler identified by
the path is a file system, and as such allows access to multiple files
on a physical data carrier. Otherwise, it returns {\tt DOSFALSE}.

\section{Unbuffered Input and Output} \label{sec:unbuffered}

The functions described in this section read bytes from or write bytes
to already opened files. These functions are \emph{unbuffered}, that
is, any request goes directly to the handler. Since a request performs
necessarily a task switch from the caller to the handler managing the
file, these functions are inefficient on small amounts of data and
should be avoided. Instead, files should be read or written in larger
chunks, either by buffering data manually, or by using the buffered
I/O functions described in section~\ref{sec:buffered}.

\subsection{Reading Data}
The following function reads data from an opened file by directly
invoking the handler for performing the read:

\begin{verbatim}
actualLength = Read( file, buffer, length )
D0                   D1    D2      D3

LONG Read(BPTR, void *, LONG)
\end{verbatim}

The {\tt Read()}\mkey{Read()} function reads {\tt length} bytes from an opened
file identified by the \emph{file handle} {\tt file} into the buffer pointed
to by {\tt buffer}. The buffer is a standard C pointer, not a BPTR.
\smallskip{}

The return code {\tt actualLength} is the amount of bytes actually
read, or -1 for an error condition. A secondary return
code can be retrieved from {\tt IoErr()} described in
section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case reading failed.
\smallskip{}

The amount of data read may be less data than requested by the {\tt
  length} argument, either because the \emph{EOF} position has been
reached (see section \ref{sec:interactive}) for non-interactive files,
or because the interactive source is depleted. Note that for
interactive files, the function may block indefinitely until data
becomes available.

\subsection{Testing for Availability of Data}

An issue of the {\tt Read}function is that it may block indefinitely
on an interactive file if the user does not enter any data. The {\tt
  WaitForChar()}\mkey{WaitForChar()} tests for the availability of a
character on an interactive file for limited amount of time and
returns if no data becomes available.

\begin{verbatim}
status = WaitForChar( file, timeout )
  D0                    D1    D2

BOOL WaitForChar(BPTR, LONG)
\end{verbatim}

This function waits for a maximum of {\tt timeout} microseconds for
the availability of input on {\tt file}. If data is already available,
or becomes available within this time, the function returns
{\tt DOSTRUE}. Otherwise, the function returns {\tt DOSFALSE}.
\smallskip{}

A secondary return code can be obtained from {\tt IoErr()}. If it is
$0$, the handler was able check the availablility of a byte from the
given file. Otherwise, an error code from {\tt dos/dos.h} indicates
failure of the function.
\smallskip{}

This function requires an interactive file to operate, file systems
will typically not implement this function as they do not block.

\subsection{Writing Data}
The following call writes an array of bytes unbuffered to a file,
interacting directly with the corresponding handler:

\begin{verbatim}
returnedLength =  Write( file, buffer, length )
 D0                       D1    D2      D3

LONG Write (BPTR, void *, LONG)
\end{verbatim}

The Write\mkey{Write} function writes {\tt length} bytes in the buffer
pointed to by {\tt buffer} to the \emph{file handle} given by the {\tt file}
argument. On success, it returns the number of bytes written as {\tt
  returnedLength}, and advances the file pointer of the file by this
amount. Note that this amount of bytes may even be 0 in case the file
cannot absorb any more bytes. On error, $-1$ is returned.
\smallskip{}

A secondary return code can be retrieved from {\tt IoErr()} described
in section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case writing failed.
\smallskip{}

For interactive files, this function may block indefinitely until the
corresponding handler is able to take additional data.

\subsection{Adjusting the File Pointer}

The {\tt Seek()}\mkey{Seek()} adjusts the file pointer of a
non-interactive file such that subsequent reading or writing is
performed from an alternative position of the file.

\begin{verbatim}
oldPosition = Seek( file, position, mode )
 D0                  D1    D2        D3

LONG Seek(BPTR, LONG, LONG)
\end{verbatim}

This function adjusts the file pointer of {\tt file} relative to the
position determined by {\tt mode} by {\tt position} bytes. The value
of {\tt mode} shall be one of the following options, defined in
{\tt dos/dos.h}:

\begin{rkrmtable}{Seek Modes} \label{table:seekmode}
{\bf Mode Name} & {\bf Description}\\ \hline \hline
{\tt OFFSET\_BEGINNING} & Seek relative to the start of the file\\ \hline
{\tt OFFSET\_CURRENT}   & Seek relative to the current file position\\ \hline
{\tt OFFSET\_END}       & Seek relative to the end of the file\\ \hline
\end{rkrmtable}

\punchline{Undefined on Interactive Files}{The {\tt Seek} function
  will typically indicate failure if applied to interactive
  files. Some handlers may assign this function, however, a particular
  meaning. See the handler definition for details.}
  
If {\tt mode} is {\tt OFFSET\_BEGINNING}, then the new file pointer is
placed {\tt position} bytes from the start of the file, i.e. the new
file pointer is equal to {\tt position}.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_CURRENT}, then {\tt position} is added
to the file pointer. That is, the file pointer is advanced if
{\tt position} is positive, or rewinded if {\tt position} is negative.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_END}, then the end-of-file
position\key{EOF} is determined, and {\tt position} is added to this
position. This, in particular, requires that {\tt position} should be
negative.
\smallskip{}

The {\tt Seek()} function returns the file pointer before its
adjustment, or $-1$ in case of an error.
\smallskip{}

A secondary return code can be retrieved from {\tt IoErr()} described
in section~\ref{sec:misc}. It is $0$ on success, or an error code from
{\tt dos/dos.h} in case adjusting the file pointer failed.

\punchline{Not 64bit safe}{Unfortunately, it is not quite clear how
  {\tt Seek} operates on files that are larger than 2GB, and it is
  file system dependent how such files could be handled. {\tt
    OFFSET\_BEGINNING} can probably only reach the first 2GB of a
  larger file as the file system may interpret negative values as an
  attempt to reach a file position upfront the start of the file and
  may return an error. Similarly, {\tt OFFSET\_END} may possibly only
  reach the last 2GB of the file. Any other position within the file
  may be reached by splitting the seek into chunks of at most 2GB and
  perform multiple {\tt OFFSET\_CURRENT} seeks. However, whether such a
  strategy suceeds is pretty much file system dependent. Note in
  particular that the return code of the function does not allow to
  distinguish between a file pointer just below the 4GB barrier and an
  error condition. A zero result code of {\tt IoErr()} should be then
  used to learn whether a result of -1 indicates a file position of
  {\tt 0xffffffff} instead. Most AmigaDOS file systems may not be able
  to handle files larger than 2GB.}

Even though {\tt Seek()} is an unbuffered function, it is aware of a
buffer and implicitly flushes the file system internal buffer. That
is, it can be safely used by buffered and unbuffered functions.

\subsection{Setting the Size of a File}

The {\tt SetFileSize()}\mkey{SetFileSize()} function truncates or
extends the size of an opened file to a given size. Not all handlers
support this function.

\begin{verbatim}
newsize = SetFileSize(fh, offset, mode)
D0                    D1    D2     D3

LONG SetFileSize(BPTR, LONG, LONG)
\end{verbatim}
This function extends or truncates the size of the file identified by
the \emph{file handle} {\tt fh}; the target size is determined by the
current file pointer, {\tt offset} and the {\tt mode}. Interpretation
of {\tt mode} and {\tt offset} is similar to {\tt Seek()}, except that
the end-of-file position\key{EOF} of the file is adjusted, and not the
file pointer.
\medskip{}

The {\tt mode} shall be selected from to
table~\ref{table:seekmode}. In particular, it is interpreted as
follows:
\smallskip{}

If {\tt mode} is {\tt OFFSET\_BEGINNING}, then the file size is set to
the value of {\tt offset}, irrespectible of the current file pointer.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_CURRENT}, then the new end-of-file position
is set {\tt offset} bytes relative to the current file pointer. That
is, the file is truncated if {\tt offset} is negative, and extended if
{\tt offset} is positive.
\smallskip{}

If {\tt mode} is {\tt OFFSET\_END}, the new file size is given by the
current file size plus {\tt offset}. That is, the file is extended by
{\tt offset} bytes if positive, or truncated otherwise. The value of the
current file pointer is irrelevant and ignored.
\smallskip{}

If the current file pointer of any \emph{file handle} opened on the
same file is, after a potential truncation, beyond the new
end-of-file, it is clamped to the end-of-file. They remain unchanged
otherwise.
\smallskip{}

If the file is enlarged, the values within the file beyond the
previous end-of-file position are undetermined.
\smallskip{}

The return value {\tt newsize} is the size of the file after the
adjustment, i.e. the position of the end-of-file location.

\punchline{Not 64bit safe}{Similar to {\tt Seek()},
  {\tt SetFileSize()} cannot be assumed to work properly if the (old or
  new) file size is larger than 2GB. What exactly happens if an
  attempt is made to adjust the file by more than 2GB depends on
  the file system performing the operation. A possible strategy to
  adjust the file size to a value above 2GB is to first seek to the
  closest position, potentially using multiple seeks of maximal size,
  and then perform one or multiple calls to {\tt SetFileSize()} with
  the {\tt mode} set to {\tt OFFSET\_CURRENT}. However, whether this
  strategy succeeds is file system dependent.}

\section{Buffered Input and Output} \label{sec:bufferedio}

AmigaDOS also offers buffered input and output functions that stores
data in an intermediate buffer. AmigaDOS then transfers data only in
larger chunks between the buffer and the handler, minimizing the task
switching overhead and offering better performance if data is to be
read or written in smaller units.

\punchline{Performance Improved}{While buffered I/O functions of
  AmigaOs 3.1.4 and below were designed around single-byte functions
  and thus caused massive overhead in the buffered functions described
  in this section, the functions in this section were redesigned in
  AmigaOs 3.2 and now offer significantly better
  performance. Unfortunately, the default buffer size AmigaDOS uses is
  quite small and should be significantly increased by
  {\tt SetVBuf()}\key{SetVBuf()}. A suggested buffer size is 4096 bytes
  which corresponds to a disk block of modern hard drives.}

\subsection{Buffered Read}

The {\tt FRead()}\mkey{FRead()} function reads multiple equally-sized
records from a file through a buffer, and returns the number of
records retrieved.

\begin{verbatim}
count = FRead(fh, buf, blocklen, blocks)
 D0           D1  D2     D3        D4

LONG FRead(BPTR, STRPTR, ULONG, ULONG)
\end{verbatim}

This function reads {\tt blocks} records each of {\tt blocklen} bytes
from the file {\tt fh} into the buffer {\tt buf}. It returns the
number of complete records retrieved from the file. If the file runs
out of data, the last record may be incomplete.
\smallskip{}

From AmigaOs 3.2 onwards, {\tt FRead()} first attempts to satisfy the
request from the file handle internal buffer, but if the number of
remaining bytes is larger than the buffer size, the handler will be
invoked directly for ``bursting'' the data into the target buffer,
bypassing the file buffer.
\smallskip{}

This function does not modify {\tt IoErr()}\key{IoErr()} in case the
request can be satisfied completely from the file handle buffer. It
neither returns $-1$ in case of an error. Callers should instead use
{\tt SetIoErr(0)} to clear the error state before calling this
function, and then use {\tt IoErr()} to learn if any error occured if
the number of records read is smaller than the number of records
requested.

\subsection{Buffered Write}

The {\tt FWrite()}\mkey{FWrite()} function writes multiple equally-sized
records to a file through a buffer, and returns the number of
records it could write.

\begin{verbatim}
count = FWrite(fh, buf, blocklen, blocks)
D0             D1  D2     D3        D4

LONG FWrite(BPTR, STRPTR, ULONG, ULONG)
\end{verbatim}

This function write {\tt blocks} records each of {\tt blocklen} bytes
from the buffer {\tt buf} to the file {\tt fh}. It returns the number
of complete records written to the file. On an error, the last record
written may be incomplete.
\smallskip{}

From AmigaOs 3.2 onwards, {\tt FWrite()} first checks whether the file
handle internal buffer is partially filled. If so, the file handle
interal buffer is filled from {\tt buf}. If any bytes remain to be
written, and the number of bytes is larger than the internal buffer
size, the handler will be invoked to write the data in a single block,
bypassing the buffer. Otherwise, the data will be copied to the
internal buffer.
\smallskip{}

This function does not modify {\tt IoErr()}\key{IoErr()} in case the
request can be satisfied completely by using the file handle
buffer. It neither returns $-1$ in case of an error. Callers should
instead use {\tt SetIoErr(0)} to clear the error state before calling
this function, and then use {\tt IoErr()} to learn if any error
occured if the number of records written is smaller than the number of
records passed in.

\subsection{Adjusting the Buffer}

The {\tt SetVBuf()}\mkey{SetVBuf()} function allows to adjust the
internal buffer size for buffered input/output functions such as {\tt
  FRead()}\key{FRead()} or {\tt FWrite()}\key{FWrite()}. It also sets
the buffer mode. The default buffer size is 204 characters, which is
too low for many applications.

\begin{verbatim}
error = SetVBuf(fh, buff, type, size)
D0              D1   D2    D3    D4

LONG SetVBuf(BPTR, STRPTR, LONG, LONG)
\end{verbatim}

This function sets the internal buffer of the \emph{file handle}
{\tt fh} to {\tt size} bytes. Sizes smaller than 204 characters will be
rounded up to 204. If {\tt buff} is non-{\tt NULL}, it is a pointer to
a user-provided buffer that will be used for buffering. This buffer
shall be aligned to a 32-bit boundary. A user provided buffer will not
be released when the file is closed.
\smallskip{}

Otherwise, if {\tt buff} is {\tt NULL} AmigaDOS will allocate the
buffer for you, and will also release it when the file is closed.
\smallskip{}

The {\tt type} argument identifies the type of buffering according to
Table~\ref{table:buffmode}; the modes there are defined in the include
file {\tt dos/stdio.h}.

\begin{rkrmtable}{Buffer Modes} \label{table:buffmode}
{\bf Buffer Name} & {\bf Description}\\ \hline \hline
{\tt BUF\_LINE} & Buffer up to end of line\\ \hline
{\tt BUF\_FULL} & Buffer everything\\ \hline
{\tt BUF\_NONE} & No buffering\\ \hline
\end{rkrmtable}

The buffer mode {\tt BUF\_LINE} automatically flushes the buffer when
writing a line feed (0x0a), carriage return (0x0c) or ASCII NUL (0x00)
character to the buffer, and the target file is
interactive. Otherwise, the characters remain in the buffer until it
either overflows or is flushed manually, see {\tt Flush()}\key{Flush()}.
\smallskip{}

The buffer mode {\tt BUF\_FULL} buffers all characters until the
buffer either overflows or is flushed.
\smallskip{}

The buffer mode {\tt BUF\_NONE} effectively disables the buffer and
writes all characters to the target file immediately.
\smallskip{}

On reading, {\tt BUF\_LINE} and {\tt BUF\_FULL} are equivalent and
fill the entire buffer from the file; {\tt BUF\_NONE} disables
buffering.
\medskip{}

The function returns non-zero on success, or $0$ on error. Error
conditions are either out-of-memory, an invalid buffer mode or an
invalid file handle. Unfortunately, {\tt IoErr()} is only set on an
out-of-memory condition and remains otherwise unchanged.

\subsection{Synchronize the File to the Buffer}

The {\tt Flush()}\mkey{Flush()} function flushes the internal buffer
of a \emph{file handle} and synchronizes the file pointer to the
buffer position.

\begin{verbatim}
success = Flush(fh)
D0              D1

LONG Flush(BPTR)
\end{verbatim}

Synchronizes the file pointer to the buffer, that is, if bytes were
written to the buffer, writes out buffer content to file. If bytes
were read from the file and non-read files remained in the buffer,
such bytes are dropped and the function attempts to seek back to the
position of the last read byte. This can fail for interactive files.
\smallskip{}

The return code is currently always {\tt DOSTRUE} and thus cannot be
used as an indication of error, even if not all bytes could be
written, or if seeking failed. If error detection is desired, the
caller should first use {\tt SetIoErr(0)}\key{SetIoErr()} to erase an
error condition, then call flush, and then use {\tt IoErr()} to
check whether an error occurred.

\punchline{Flush when switching between reading and writing}{The {\tt
    Flush()} function shall be called when switching from writing to a
  file to reading from the same file, or vice versa. The internal
  buffer logic is unfortunately not capable to handle this case
  correctly. Also, {\tt Flush()} shall be called when switching from
  buffered to unbuffered input/output.}

\subsection{Write a Character Buffered to a File}

The {\tt FPutC()}\mkey{FPutC()} function writes a single character to
a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
char = FPutC(fh, char)
D0           D1   D2

LONG FPutC(BPTR, LONG)
\end{verbatim}

This function writes the single character {\tt char} to the \emph{file
  handle} {\tt fh}.  Depending on the buffer mode, the character and
the type of file, the character may go to the buffer first, or may
cause the buffer to be emptied. See {\tt SetVBuf()}\key{SetVBuf()} for
details on buffer modes and conditions for implicit buffer flushes.
\smallskip{}

It returns the character written, or {\tt ENDSTREAMCH} on an
error. The latter constant is defined in {\tt dos/stdio.h} and equals
to $-1$.
\smallskip{}

This function does not touch {\tt IoErr()} if the character only goes
into the internal buffer. 

\subsection{Write a String Buffered to a File}

The {\tt FPuts()}\mkey{FPuts()} function writes a {\tt NUL}-terminated
string to a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
error = FPuts(fh, str)
D0            D1  D2

LONG FPuts(BPTR, STRPTR)
\end{verbatim}

This function writes the NUL-terminated (C-style) string {\tt str} to
the \emph{file handle} {\tt fh}. The terminating {\tt NUL} character
is not written.
\smallskip{}

Depending on the buffer mode, the string will first go into the
buffer, or may be written out immediately. See
{\tt SetVBuf()}\key{SetVBuf()} for details on buffer modes and conditions
for implicit buffer flushes.
\smallskip{}

This function returns $0$ on success, or {\tt ENDSTREAMCH} on an
error. The latter constant is defined in {\tt dos/stdio.h} and equals
to $-1$.

\subsection{Read a Character from a File}

The {\tt FGetC()}\mkey{FGetC()} function reads a single character from
a file through the internal buffer of the \emph{file handle}.

\begin{verbatim}
char = FGetC(fh)
D0           D1

LONG FGetC(BPTR)
\end{verbatim}

This function attempts to read a single character from the \emph{file
  handle} {\tt fh} using the buffer of the handle. If characters are
present in the buffer, the request is satisfied from the buffer first,
then the function attempts to refill the buffer from the file and
tries again.
\smallskip{}

The function returns the character read, or {\tt ENDSTREAMCH} on an
end-of-file condition or an error. The latter constant is defined in
{\tt dos/stdio.h} and equals to $-1$.
\smallskip{}

To distingish between the error and the
end-of-file case, the caller should first reset the error condition
with {\tt SetIoErr(0)}\key{SetIoErr()}, and then check {\tt IoErr()}
when the function returns with {\tt ENDSTREAMCH}.

\subsection{Read a Line from a File}

The {\tt FGets()}\mkey{FGets()} function reads a newline-terminated
string from a file, using the \emph{file handle} internal buffer.

\begin{verbatim}
buffer = FGets(fh, buf, len)
D0             D1  D2   D3

STRPTR FGets(BPTR, STRPTR, ULONG)
\end{verbatim}

This function reads a line from the \emph{file handle} into the buffer
pointed to by {\tt buf}, capable of holding {\tt len} characters.
\smallskip{}

Reading terminates either if {\tt len}-1 characters have been read, filling
up the buffer completely; or a line-feed character is found, which is
copied into the buffer; or if an end-of-file condition or an error
condition is encountered. In either event, the string is {\tt NUL}
terminated.
\smallskip{}

The function returns {\tt NULL} in case not even a single character
could be read. Otherwise, the function returns the buffer passed in.
\smallskip{}

To distinguish between the error and end-of-file condition, the caller
should first use {\tt SetIoErr(0)}\key{SetIoErr()}, and then test
{\tt IoErr()} in case the function returns {\tt NULL}.

\subsection{Revert a Single Byte Read}

The {\tt UnGetC()} function reverts a single byte read from a
stream and makes this byte available for reading again.

\begin{verbatim}
value = UnGetC(fh, ch)
D0             D1  D2

LONG UnGetC(BPTR, LONG)
\end{verbatim}

The character {\tt ch} is pushed back into the \emph{file handle} {\tt fh}
such that the next attempt to read a character from {\tt fh}
returns {\tt ch}. If {\tt ch} is $-1$, the last character read will be
pushed back. If the last read operation indicated an error or end-of-file condition,
{\tt UnGetC(fh,-1)} pushes an end-of-file condition back.
\smallskip{}

This function returns non-zero on success or $0$ if the character
could not be pushed back. At most a single character can be pushed
back after each read operation, an attempt to push back more
characters can fail.

\section{File Handle Documentation}

So far, the \emph{file handle} has been used as an opaque value bare
any meaning. However, the {\tt BPTR}, once converted to a regular
pointer, is a pointer to {\tt struct FileHandle}\mkey{FileHandle}:

\begin{verbatim}
BPTR file = Open("S:Startup-Sequence,MODE_OLDFILE);
struct FileHandle *fh = BADDR(file);
\end{verbatim}

In the following sections, this structure and its functions are documented.

\subsection{The struct FileHandle}

When opening a file via {\tt Open()}, the \emph{file handle} is allocated by
the \emph{dos.library} by going through {\tt AllocDosObject()}\key{AllocDosObject()},
and then forwarded to the file system or handler for second-level initialization. It is
documented in {\tt dos/dosextens.h} as replicated here:
\mkey{FileHandle}
\begin{verbatim}
struct FileHandle {
   struct Message *fh_Link;	 
   struct MsgPort *fh_Port;
   struct MsgPort *fh_Type;
   BPTR fh_Buf;       
   LONG fh_Pos;
   LONG fh_End;
   LONG fh_Funcs;
#define fh_Func1 fh_Funcs
   LONG fh_Func2;
   LONG fh_Func3;
   LONG fh_Args;
#define fh_Arg1 fh_Args
   LONG fh_Arg2;
};
\end{verbatim}
{\tt fh\_Link} is actually not a pointer, but an AmigaDOS internal
value that shall not be interpreted or touched, and of which one
cannot make productive use.
\smallskip{}

{\tt fh\_Port} is similarly not a pointer, but a {\tt LONG}. If it is
non-zero, the file is interactive, otherwise it is a file system.
{\tt IsInteractive()}\key{IsInteractive()} makes use of this
member. The file system or handler shall initialize this value when
opening a file and shall initialize it according to the nature of the
handler.
\smallskip{}

{\tt fh\_Type} points to the {\tt MsgPort} of the handler or file
system that implements all input and output
operations. Section~\ref{sec:handler} provides additional information
on how handlers and file systems work. If this pointer is {\tt NULL},
no handler is associated to the file handle. This is also the value
AmigaDOS will deposit here when opening a file to the {\tt NIL:}
(pseudo-)device. Attempting to {\tt Read()}\key{Read()} from this
handle results in an end-of-file situation, and calling {\tt Write()}
on such a handle does nothing, ignoring any data written.
\smallskip{}

{\tt fh\_Buf} is a {\tt BPTR} to the file handle internal buffer all
buffered I/O function documented in this section use.
\smallskip{}

{\tt fh\_Pos} is the next read or write position within this buffer.
\smallskip{}

{\tt fh\_End} is the size of the buffer in bytes.
\smallskip{}

{\tt fh\_Func1} is a function pointer that is called whenever the
buffer is to be filled through the handler. Users shall not call this
function itself, and the function prototype is intentionally not
documented.
\smallskip{}

{\tt fh\_Func2} is a second function pointer that is called whenever
the buffer is full and is to be written by the handler. Users shall
not call this function itself, and the function prototype is
intentially undocumented.
\smallskip{}

{\tt fh\_Func3} is a final function pointer that is called whenever
the file handle is closed. This function then potentially writes the
buffer content out when dirty, releases the buffer if it is
system-allocated, and finally forwards the close request to the
handler.
\smallskip{}

{\tt fh\_Arg1} is a file-system internal value the handler or file
system uses to identify the file. The interpretation of this value is
to the file system or handler, and the \emph{dos.library} does not
attempt to interpret it. The handler deposits the file identification
here when opening a file, and the \emph{dos.library} forwards it to the
handler on {\tt Read()} and {\tt Write()}. See
section~\ref{sec:handler} for details.
\smallskip{}

{\tt fh\_Arg2} is currently unused.

\subsection{String Streams}
It is sometimes useful to provide programs with (temporary) input not
coming from a file system or handler directly, even though the program
uses a file interface to access it. One solution to this problem is to
deposit the input data on the {\tt RAM} disk, then opening this file
and providing it as input to such a program. The drawback of this
approach is that additional tests are necessary to ensure that the
file name is unique, and to avoid that other than the intended program
accesses it.
\smallskip{}

AmigaDOS uses the technique documented here itself, for example to
provide the command to be executed by the {\tt Run}\key{Run}
command. There, the string stream contains the command to be run in
background, which is then provided as input file to the shell. The
{\tt System()}\key{System()} function of the \emph{dos.library} makes
use of the same trick to feed the command to be executed as input
file. Thus, even though the shell can only execute commands from a
file, AmigaDOS can generate \emph{file handles} that do not correspond
to a handler, but to a string in memory containing the commands.
\smallskip{}

The shell itself is using the same technique to pass arguments to the
commands it executes; it deposits the command arguments in the file
handle buffer of the input stream where {\tt ReadArgs()} collects them.
\medskip{}

The idea is to allocate a {\tt struct FileHandle} and initialize its
buffer to contain the string within the file. For this {\tt fh->Buf}
needs to point to the buffer containing the string, and {\tt fh->End}
needs to be its size. The function pointers in the \emph{file handle}
remain 0 such as to avoid that the \emph{dos.library} reads, writes or
flushes the buffer. The {\tt FileHandle} shall be allocated by {\tt
  AllocVec()} as the \emph{dos.library} releases the handle through
{\tt FreeVec()}.

The following program demonstrates this technique:
\begin{verbatim}
#include <exec/memory.h>
#include <dos/dos.h>
#include <dos/stdio.h>
#include <string.h>
#include <proto/dos.h>
#include <proto/exec.h>

int main(int argc,char **argv)
{
  const char *test = "Hello World!\n";
  const int len = strlen(test)+1;
  struct FileHandle *fh;
  BPTR file;

  fh   = AllocVec(sizeof(struct FileHandle) + len,MEMF_PUBLIC|MEMF_CLEAR);
  if (fh) {
    UBYTE *c = (UBYTE *)(fh + 1);
    file     = MKBADDR(fh);
    memcpy(c,test,len);
    fh->fh_Buf = MKBADDR(c);
    fh->fh_End = len;
    {
      BPTR out = Output();
      LONG ch;
      while((ch = FGetC(file)) >= 0) {
        FPutC(out,ch);
      }
    }
    Close(file);
  }
  return 0;
}
\end{verbatim}
Here the buffer is allocated along with the file handle, and thus
released along with it. Setting {\tt MEMF\_PUBLIC} is of utter
importance as it clears all function pointers, and in particular the
{\tt fh\_Link} field to zero; the latter is an indication to the
\emph{dos.library} that this structure was not allocated through
itself.

\subsection{An FSkip() Implementation}

Unlike most unbuffered functions, {\tt Seek()}\key{Seek} can be safely
mixed with buffered input and output functions. However, this function
is not very efficient, and seeking should be avoided if buffer
manipulation is sufficient. Buffer manipulation has the advantage that
small amounts of bytes can be skipped easily without going through the
file system; skipping over larger amounts of bytes can be performed by
a single function without requiring to read bytes.
\smallskip{}

The following function implements an {\tt FSkip()}\mkey{FSkip()}
function that selects the most viable option and is more efficient
that {\tt Seek()} for buffered reads.
\begin{verbatim}
LONG FSkip(BPTR file,LONG skip)
{
  LONG res;
  struct FileHandle *fh = BADDR(file);
  if (fh->fh_Pos >= 0 && fh->fh_End > 0 && fh->fh_Func3) {
    LONG newpos = fh->fh_Pos + skip;
    if (newpos >= 0 && newpos < fh->fh_End) {
      fh->fh_Pos = newpos;
      return DOSTRUE;
    }
  }
  skip += fh->fh_Pos - fh->fh_End;
  fh->fh_Pos = -1;
  fh->fh_End = -1;
  if (Seek(fh,skip,OFFSET_CURRENT) != -1)
   return DOSTRUE;
  return DOSFALSE;
}
\end{verbatim}

The first if-condition checks whether the buffer is actually
present. Then, the new buffer position is computed. If it is within
the buffer, the new buffer position is installed as the work is done.
\smallskip{}

Otherwise, the skip distance is adjusted by the buffer
position. Initializing the buffer size and position to $-1$ ensures
that the following {\tt Seek()} does not attempt to call {\tt Flush()}
internally.
\smallskip{}

There is one particular catch, namely that the {\tt file}
needs to be initialized for reading immediately after opening the
file, or the buffer will not be in the right state for the trick:
\begin{verbatim}
BPTR file = Open(filename,MODE_OLDFILE);
UnGetC(file,-1); /* initialize buffer */
\end{verbatim}
This is only necessary if the first access to the file is an
{\tt FSkip()}.

\section{Formatted Output}

The functions in this section print strings formatted to a file. Both
files use the internal buffer of the \emph{file handle}.

\subsection{Print Formatted String using C-Syntax}

The {\tt VFPrintf()}\mkey{VFPrintf()} function prints multiple
datatypes using a format string that closely reessembles the syntax of
the C syntax. {\tt FPrintf()}\mkey{FPrintf()} is based on the same
entry point of the \emph{dos.library}, though the prototype for the C
language is different and thus arguments are expected directly as function
arguments instead of requiring them to be collected in an array upfront.

\begin{verbatim}
count = VFPrintf(fh, fmt, argv)
D0               D1  D2    D3

LONG VFPrintf(BPTR, STRPTR, LONG *)

count = FPrintf(fh, fmt, ...)

LONG FPrintf(BPTR, STRPTR, ...)
\end{verbatim}

This function uses the {\tt fmt} string to format an array of
arguments pointed to by {\tt argv} and outputs the result to the file
{\tt fh}. The syntax of the format string is identical to that of the
exec function {\tt RawDoFmt()}, and shares its problems. In
particular, format strings indicating integer arguments such as
{\tt \%d} and {\tt \%u} assume 16bit integers, independent of the integer
model of the compiler. On compilers working with a 32bit integer
models, the format modifier {\tt l} should be used, e.g. {\tt \%ld}
for signed and {\tt \%lu} for unsigned integers.
\smallskip{}

As {\tt RawDoFmt()}\key{RawDoFmt()} is also patched by the
\emph{locale.library}, additional syntax elements from the
{\tt FormatString()} function of this library become available for
{\tt VFPrintf()} and {\tt FPrintf()}.
\smallskip{}

The result {\tt count} delivers the number of characters written to
the file, or $-1$ for an error. In the latter case,
{\tt IoErr}\key{IoErr()} provides an error code.

\subsection{BCPL Style Formatted Print to a File}

The {\tt VFWritef()}\mkey{VFwrite()} function formats several
arguments according to a format string similar to
{\tt VFPrintf()}\key{VFprintf()}, but uses the formatting syntax of the
BCPL language. The main purpose of this function is to offer formatted
output for legacy BCPL programs where this function appears as an
entry of the BCPL \emph{Global Vector}. New code should not use this
function but rather depend on {\tt VFPrintf()} which also gets enhanced
by the \emph{locale.library}.
\smallskip{}

The {\tt FWritef()}\mkey{FWritef()} uses the same entry point of the
\emph{dos.library}, though the compiler prototype imposes a different
calling syntax where the objects to be formatted are directly
delivered as function arguments rather requiring the caller to collect
them in an array upfront.

\begin{verbatim}
count = VFWritef(fh, fmt, argv)
D0               D1  D2    D3

LONG VFWritef(BPTR, STRPTR, LONG *)

count = FWritef(fh, fmt, ...)

LONG FWritef(BPTR, STRPTR, ...)
\end{verbatim}

This function formats the arguments from the array pointed to by
{\tt argv} according to the format string in {\tt fmt} and writes the
output to the file {\tt fh}. The format string follows the syntax of
the BCPL language. The following format identifiers are supported:

\begin{itemize}
\item[{\tt \%S }] Write a {\tt NUL} terminated string from the array to the output.
\item[{\tt \%Tx}] Writes a {\tt NUL} terminated string left justified
  in a field whose width is given by the character {\tt x}. The length
  indicator is always a single character; a digit from {\tt 0} to
  {\tt 9} indicates the field widths from $0$ to $9$ directly. Characters
  {\tt A} to {\tt Z} indicate field widths from $10$ onwards.
\item[{\tt \%C }] Writes a single character whose ISO-Latin-1 code is given
  as a 32-bit integer on the {\tt argv} array.
\item[{\tt \%Ox}] Writes an integer in octal to the output where
  {\tt x} indicates the maximal field width. The field width is a single
  character that is encoded similarly to the {\tt \%T} format string.
\item[{\tt \%Xx}] Writes an integer in hexadecimal to the output in a field
  that is at most {\tt x} characters long. {\tt x} is a single character and
  encodes the width similar to that {\tt \%T} format string.
\item[{\tt \%Ix}] Writes a (signed) integer in decimal to the output
  in field that is at most {\tt x} characters long. The field length
  is again indicated by a single character.
\item[{\tt \%N }] Writes a (signed) integer in decimal to the output
  without any length limitation.
\item[{\tt \%Ux}] Writes an unsigned integer in decimal to the output,
  limiting the field length to at most {\tt x} characters, where
  {\tt x} is encoded in a single character.
\item[{\tt \%\$ }] Ignores the next argument, i.e. skips over it.
\end{itemize}

This function is \emph{not} patched by the \emph{locale.library} and
therefore is not localized or enhanced.
\smallskip{}

While the same function can also be found in the BPCL
\emph{Global Vector}, it there takes BSTRs instead of regular C strings for the
format string and arguments of the {\tt \%S} and {\tt \%T} formats.
  
\chapter{Locks} \label{sec:locks}

\emph{Locks}\mkey{Lock} are access rights to objects, such as files or
directories, on a file system. Once an object has been locked, it can
no longer be deleted, or in case of files, it can no longer altered
either. Depending on the file system, locks may also prevent other
forms of changes of the object.
\medskip{}

Locks come in two types: \emph{Exclusive}\mkey{Lock (Exclusive)} and
\emph{shared locks}. Only a single exclusive lock can exist on a file
system object at a time, and no other locks on an exclusively locked
object can exist. An attempt to lock an exclusively locked object
results in failure, and attempting to exclusively lock an object that
is already shared locked will also fail.
\smallskip{}

Multiple \emph{shared locks}\mkey{Lock (Shared)} can be kept on the
same object at the same time, though once a shared lock has been
obtained, any attempt to lock the same object exclusively fails.
\smallskip{}

One particular use case of \emph{locks} is to serve as an identifier
of a particular directory or file on a file system. Since paths are
limited to 255 characters, see~\ref{sec:paths}, locks are the
preferred method of indicating a position within a file system. Even
though paths are length limited, there is no restriction on the depth
within the directory structure of a file system. The {\tt ZERO} lock
identifies the boot volume, also known as {\tt SYS:}, see also
section~\ref{sec:assignlist}.
\smallskip{}

\emph{Locks} are also the building stone of files; in fact, every file
is internally represented by a lock on the corresponding object, even
if the file system does not expose this lock to the caller.
\smallskip{}

As long as at least a single lock is held of an object on a particular
volume, the file system will keep the volume within the
\emph{device list} of the \emph{dos.library}, see section~\ref{sec:devicelist}.
This has, for example, the consequence that the workbench will
continue to show an icon representing the volume in its window.

\section{Obtaining and Releasing Locks}

\emph{Locks} can be obtained either explictly from a path, or can be
derived from another lock or file. As locks block altering accesses to
an object of a file system, locks need to be released as early as
possible to allow other accesses to the locked object.

\subsection{Obtaining a Lock from a Path} \label{sec:lock}.

The {\tt Lock()}\key{Lock()} function obtains a lock on an object
given a path to the object. The path can be either absolute, or
relative (see section~\ref{sec:paths}) to the current directory of the
calling process.

\begin{verbatim}
lock  = Lock( name, accessMode )
D0            D1        D2

BPTR Lock(STRPTR, LONG)
\end{verbatim}

This function locks the object identified by {\tt name}, which is the
path to the object. The type of the lock is identified by {\tt
  accessMode}. This mode shall be one of the two following modes,
defined in {\tt dos/dos.h}:

\begin{rkrmtable}{Lock Access Modes} \label{table:lockmodes}
{\bf Access Mode} & {\bf Description}\\ \hline \hline
{\tt SHARED\_LOCK} & Lock allowing shared access from multiple sources\\ \hline
{\tt ACCESS\_READ} & Synonym of the above, identical to {\tt SHARED\_LOCK} \\ \hline
{\tt EXCLUSIVE\_LOCK} & Exclusive lock, only allowing a single lock on the object \\ \hline
{\tt ACCESS\_WRITE} & Synonym of the above, identical to {\tt EXCLUSIVE\_LOCK} \\ \hline
\end{rkrmtable}

The access mode {\tt SHARED\_LOCK}\mkey{SHARED\_LOCK} or {\tt
  ACCESS\_READ}\mkey{ACCESS\_READ} allows multiple shared locks on the
same object. This type of lock should be preferred. The access mode
{\tt EXCLUSIVE\_LOCK}\mkey{EXCLUSIVE\_LOCK} or
{\tt ACCESS\_WRITE}\mkey{ACCESS\_READ} only allows a single, exclusive
lock on the same object.
\smallskip{}

The return code {\tt lock} identifies the lock. It is non-{\tt ZERO}
(see~\ref{sec:bptrs}) on success, or {\tt ZERO} on failure. In either
case, {\tt IoErr()}\key{IoErr()} is set to $0$ indicating success, or
an error code on failure.
\smallskip{}

\punchline{No Wildcards Here!}{Note that this function does not attempt to
  resolve wild cards, similar to {\tt Open()}. All characters in the
  path are literals.}

\subsection{Duplicating a Lock}

The {\tt DupLock()}\mkey{DupLock()} function replicates a given
\emph{lock}, returning a copy of the \emph{lock} given as
argument. This requires that the original \emph{lock} is a
\emph{shared lock}, and it returns a \emph{shared lock} if successful.

\begin{verbatim}
lock = DupLock( lock )
D0              D1

BPTR DupLock(BPTR)
\end{verbatim}

This function copies the (shared) lock passed in as {\tt lock} and
returns a copy of it in {\tt lock}. In case of error, it returns {\tt
  ZERO}, and then {\tt IoErr()}\key{IoErr()} returns an error code
identifying the error. On success, {\tt IoErr()} is reset. It is not
possible to copy an \emph{exclusive lock}.

\subsection{Obtaining the Parent of an Object}

The {\tt ParentDir()}\mkey{ParentDir()} function obtains a
\emph{shared lock} on the directory containing the locked object
passed in. For directories, this is the parent directory, for files,
this is the directory containing the file.

\begin{verbatim}
newlock = ParentDir( lock )
D0                   D1

BPTR ParentDir(BPTR)
\end{verbatim}

The {\tt lock} argument identifies the object whose parent is to be
found; the function returns a \emph{lock} on the directory containing
the object. If such parent does not exist, or an error occurs, the
function returns {\tt ZERO}. The former case applies to the topmost
directory of a file system, or the {\tt ZERO} lock itself.
\smallskip{}

To distinguish the two cases, the caller should check the {\tt
  IoErr()}\key{IoErr()} function; if this function returns $0$, then
no error occurred and the passed in object is topmost and no parent
exists. If it returns a non-zero error code, then the file system
failed to identify the parent directory.

\subsection{Creating a Directory}

The {\tt CreateDir()} object creates a new empty directory whose name
is given by the last component of the path passed in. It does not
create any intermediate directories between the first component of the
path and its last component, such directories need potentially be
created manually by multiple calls to this function.

\begin{verbatim}
lock = CreateDir( name )
 D0                D1

BPTR CreateDir(STRPTR)
\end{verbatim}

The {\tt name} argument is the path to the new directory to be
created; that is, the directory given by the last component of the
path (see section~\ref{sec:paths}) will be created. If successful,
the function returns an \emph{exclusive lock} in {\tt lock}, otherwise
it returns {\tt ZERO}.
\smallskip{}

In either case, {\tt IoErr()}\key{IoErr()} is set to either an error
code, or to $0$ in case the function succeeds.
\smallskip{}

Note that not all file systems support directories, i.e. flat file
systems (see section~\ref{sec:flathierarchical}) do not.

\subsection{Releasing a Lock}

Once you are done with a \emph{lock} and no part of your program is
using it anymore, you should release it to allow other processes or
functions to access or modify the locked object. Note that setting the
{\tt CurrentDir()}\key{CurrentDir()} to a particular lock implies
usage of the lock, i.e. the lock installed as {\tt CurrentDir()} shall
not be unlocked.

\begin{verbatim}
UnLock( lock )
         D1

void UnLock(BPTR)
\end{verbatim}

This function releases the \emph{lock} passed in as {\tt lock}
argument. Passing {\tt ZERO} as a lock is fine and performs no
activity.

\subsection{Changing the Type of a Lock}

Once a \emph{lock} has been granted, it is possible to change the
nature of the lock, either from
{\tt EXCLUSIVE\_LOCK}\key{EXCLUSIVE\_LOCK} to
{\tt SHARED\_LOCK}\key{SHARED\_LOCK}, or --- if this is the only \emph{lock} on
the object --- vice versa.

\begin{verbatim}
success = ChangeMode(type, object, newmode)
D0                    D1     D2      D3

BOOL ChangeMode(ULONG, BPTR, ULONG)
\end{verbatim}

This function changes the access mode of {\tt object} whose type is
identified by {\tt type} to the access mode {\tt newmode}. The
relation between {\tt type} and the nature of the object shall be as
in table~\ref{table::changemode}, where the types are defined
in {\tt dos/dos.h}:

\begin{rkrmtable}{Object Types for ChangeMode()} \label{table::changemode}
{\bf {\tt \bf type}} & {\bf {\tt \bf object} Type}\\ \hline \hline
{\tt CHANGE\_LOCK} & {\tt object} shall be a \emph{lock}\\ \hline
{\tt CHANGE\_FH} & {\tt object} shall be a \emph{file handle}\\ \hline
\end{rkrmtable}

The argument {\tt newmode} shall be one of the modes indicated in
Table~\ref{table:lockmodes}, i.e. {\tt SHARED\_LOCK}\key{SHARED\_LOCK}
to make either the file or the lock accessible for shared access, and
{\tt EXCLUSIVE\_LOCK}\key{SHARED\_LOCK} for exclusive access.

On success, the function returns a non-zero result code, and
{\tt IoErr()} is set to $0$. Otherwise, the function returns $0$ and sets
{\tt IoErr()}\key{IoErr()} to an appropriate error code.
\smallskip{}

Unfortunately, this function may not work reliable for \emph{file
  handles} under all versions of AmigaDOS. In particular, the
\emph{RAM-Handler} does not interpret {\tt newmode} correctly for {\tt
  CHANGE\_FH}.

\subsection{Comparing two Locks} \label{sec:samelock}

The {\tt SameLock()}\mkey{SameLock()} function compares two locks and
returns information whether they are identical, or at least correspond
to objects on the same volume.

\begin{verbatim}
value = SameLock(lock1, lock2)
 D0                D1     D2

LONG SameLock(BPTR, BPTR)
\end{verbatim}

This function compares {\tt lock1} with {\tt lock2}. The return code,
all of them defined in {\tt dos/dos.h}, can be one of the following:

\begin{rkrmtable}{Lock Comparison Return Code} \label{table:lockcompare}
{\bf Return Code} & {\bf Description}\\ \hline \hline
{\tt SAME\_LOCK} & Both locks are on the same object\\ \hline
{\tt SAME\_VOLUME} & Locks are on different objects, but on the same volume\\ \hline
{\tt LOCK\_DIFFERENT} & Locks are on different volumes\\ \hline
\end{rkrmtable}

This function does not set {\tt IoErr()}\key{IoErr()} consistently,
and callers cannot depend on its value. Furthermore, the function does
not compare a {\tt ZERO} lock with lock on the boot volume, e.g {\tt
  SYS:} as identical. It is recommended not to pass in the {\tt ZERO}
lock for either {\tt lock1} or {\tt lock2}.

\section{Locks and Files}

Each \emph{file handle} is associated to a lock to the file that has
been opened. The type of the \emph{lock} depends on the access mode
the file has been opened with, table~\ref{table:modelock} for how lock
types and access modes relate.

\begin{rkrmtable}{Lock and File Access Modes} \label{table:modelock}
{\bf Access Mode} & {\bf Lock Type}\\ \hline \hline
{\tt MODE\_OLDFILE} & {\tt SHARED\_LOCK} \\ \hline
{\tt MODE\_READWRITE} & {\tt SHARED\_LOCK} \\ \hline
{\tt MODE\_NEWFILE} & {\tt EXCLUSIVE\_LOCK} \\ \hline
\end{rkrmtable}

The association of {\tt MODE\_READWRITE} to {\tt SHARED\_LOCK} is
unfortunate, and due to a defect in the \emph{RAM-Handler}
implementation in AmigaDOS 2.0 which was then later copied into the
\emph{Fast File System} implementation. Exclusive access to a file
without deleting its contents can, however, be established through the
{\tt OpenFromLock()}\key{OpenFromLock()} function passing in an
\emph{exclusive lock} to the function as argument.

\subsection{Duplicate the Implicit Lock of a File}

The {\tt DupLockFromFH()}\mkey{DupLockFromFH()} function performs a copy of a lock implicit
to a \emph{file handle} of an openend file. For this to succeed, the
file must be opened in the mode {\tt MODE\_OLDFILE}\key{MODE\_OLDFILE}
or {\tt MODE\_READWRITE}\key{MODE\_READWRITE}. Files openend with {\tt
  MODE\_NEWFILE}\key{MODE\_NEWFILE} are based on an implicit \emph{exclusive
lock} that cannot be copied.

\begin{verbatim}
lock = DupLockFromFH(fh)
D0                   D1

BPTR DupLockFromFH(BPTR)
\end{verbatim}

This function returns a copy of the lock the \emph{file handle} {\tt
  fh} is based on and returns it in {\tt lock}. In case of failure,
{\tt ZERO} is returned. In either case, {\tt IoErr()} is set to either
$0$ in case of succes, or an error code on failure.

\subsection{Obtaining the Directory a File is Located in}

The {\tt ParentOfFH()}\mkey{ParentOfFH()} function obtains a
\emph{shared lock} on the parent directory of the file associated to
the \emph{file handle} passed in. That is, it is roughly equivalent to
first obtaining a lock on the file through {\tt DupLockFromFile()}
\key{DupLockFromFile()}, and then calling {\tt ParentDir()}\key{ParentDir()}
on it, except that this function also applies to files opened in
the {\tt MODE\_NEWFILE}\key{MODE\_NEWFILE} mode.

\begin{verbatim}
lock = ParentOfFH(fh)
 D0               D1

BPTR ParentOfFH(BPTR)
\end{verbatim}

This function returns in {\tt lock} a shared lock on the directory
containing the file opened through the {\tt fh} \emph{file handle}. It
returns {\tt ZERO} on failure. In either case, {\tt IoErr()}
\key{IoErr()} is set, namely to $0$ in case of success or to an error
code on failure.

\subsection{Opening a File from a Lock}

The {\tt OpenFromLock()} function uses a \emph{lock} and opens the
locked file, returning a \emph{file handle}. If the lock is associated
to a directory, the function fails. The \emph{lock} passed in is then
absorbed into the \emph{file handle} and shall not be unlocked. It
will be released by the file system upon closing the file.

\begin{verbatim}
fh = OpenFromLock(lock)
D0                 D1

BPTR OpenFromLock(BPTR)
\end{verbatim}

This function attempts to open the object locked by {\tt lock} as
file, and creates the \emph{file handle} {\tt fh} from it. It fails in
case the {\tt lock} argument belongs to a directory and not a file.
\smallskip{}

In case of success, the \emph{lock} becomes an implicit part of the
\emph{file handle} and shall not be unlocked by the caller anymore.
In case of failure, the function returns {\tt ZERO} and the
\emph{lock} remains available to the caller, and also needs to be
unlocked at a later time. In either case, {\tt IoErr()} is set, to an
error code in case of failure, or $0$ on success.
\smallskip{}

This function allows to open files in exclusive mode without deleting
its contents. For that, obtain an \emph{exclusive lock} on the file to
be opened, and then call {\tt OpenFromLock()} as second step.

\subsection{The struct FileLock} \label{sec:filelock}

\emph{Locks} have been so far been opaque identifiers; in fact, they
are \emph{BPTR}s to a {\tt struct FileLock} that is defined in {\tt
  dos/dosextens.h}.

\begin{verbatim}
#include <dos/dosextens.h>
lock = Lock("S:Startup-Sequence",SHARED_LOCK);
struct FileLock *flock = BADDR(lock);
\end{verbatim}

While this structure is defined there, it is not allocated by the
\emph{dos.library} but by the \emph{file system} itself. The file
system may therefore allocate a structure that is somewhat larger and
can have additional members that are not shown here. 

\mkey{FileLock}
\begin{verbatim}
struct FileLock {
    BPTR                fl_Link;        /* bcpl pointer to next lock */
    LONG                fl_Key;         /* disk block number */
    LONG                fl_Access;      /* exclusive or shared */
    struct MsgPort *    fl_Task;        /* handler task's port */
    BPTR                fl_Volume;      /* bptr to DLT_VOLUME DosList entry */
};
\end{verbatim}

Most of the members of this structure are of no practical value, and
they should not be interpreted in any way. What is listed here is the
information callers can depend upon.
\smallskip{}

The {\tt fl\_Link} member has no practical value for users; the
\emph{file system} can use it to keep multiple links on object on the
same volume in a list. This is particularly important if the volume is
ejected from its drive and another file system needs to take over the
\emph{locks} if the volume is later inserted into another drive.
\smallskip{}

The {\tt fl\_Key} member can be used by the file system to identify the
object that has been locked. It may not necessarily be an integer, but
can be any data type, potentially a pointer to some internal
management object. It shall not be interpreted in any particular way.
\smallskip{}

The {\tt fl\_Access} member keeps the type of the lock. It is either {\tt SHARED\_LOCK}\key{SHARED\_LOCK}
or {\tt EXCLUSIVE\_LOCK}\key{EXCLUSIVE\_LOCK}.
\smallskip{}

The {\tt fl\_Task} member points to the message port of the file
system for processing requests on the lock. Any activity on the lock
goes through this port.
\smallskip{}

The {\tt fl\_Volume} is a \emph{BPTR} to the \emph{volume node} on the
\emph{Device list}\key{Device list}. The \emph{volume node} identifies
the volume the locked object is located
on. Section~\ref{sec:devicelist} provides further information on this
list and its entries.

\chapter{Working with Directories}

As objects on a file system can be identified by a name, these names
need to be stored somewhere on the data carrier. This object is called
a \emph{directory}. While a flat file system only contains a single,
topmost directory which then contains all files, a directory of a
hierarchical file system can contain other directories, thus creating
a \emph{tree} of nested objects, see also
section~\ref{sec:flathierarchical}.
\smallskip{}

AmigaDOS provides functions to list the directory contents, to move
objects in the file system hierarchy or change their name, and to
access adjust their metadata, such as comments, protection bits, or
creation dates.
\smallskip{}

AmigaDOS also supports \emph{links}, that is, entries in the file
system that point to some other object in the same, or some other file
system. Therefore, links circumvent the hierarchy otherwise imposed by
the tree structure of the file system.

\section{Examining Objects on File Systems} \label{sec:fib}

Given a lock on a file or a directory, further information on such an
object can be requested by the {\tt Examine()}\key{Examine()} function
of the \emph{dos.library}. To read multiple directory entries at once
and minimizing the calling overhead, {\tt ExAll()}\key{ExAll()}
provides an advantage that is, however, harder to use, but also
provides options to filter entries.

\punchline{May go away while you look!}{As AmigaDOS is a multitasking operating
system, the directory may change under your feed while scanning; in
particular, entries you received through the above functions may not
be up to date, may have been deleted already when the above functions
return, or new entries may have been added the current scan will not
reach. While a \emph{Lock} on a directory prevents that this directory
goes away, it does \emph{not} prevent other processes to add or remove
objects to this directory, so beware.}

While {\tt ExAll()} seems to provide an advantage by reading multiple
directory entries in one go, the AmigaOS ROM file system does usually
not profit from this feature, at least not unless a directory cache is
used. The latter has, however, other drawbacks and should be avoided
for different reasons, see section~\ref{sec:ffs}.
Actually, {\tt ExAll()} is (even more) complex to implement, and it is
probably not surprising that multiple file systems have issues. The
{\tt dos.library} provides an {\tt ExAll()} implementation for those
file systems that do not implement it themselves, but even this
(ROM-based) implementation had issues in the past. Therefore,
{\tt ExAll()} has probably less to offer than it seems.
\smallskip{}

{\tt Examine()} and {\tt ExNext()} fill a {\tt FileInfoBlock}\mkey{FileInfoBlock}
structure that collects information on an examined object in a directory.
It is defined in {\tt dos/dos.h} and reads as follows:
\begin{verbatim}
struct FileInfoBlock {
   LONG   fib_DiskKey;
   LONG   fib_DirEntryType;  /* Type of Directory. If < 0, then a plain file.
                              * If > 0 a directory */
   char   fib_FileName[108]; /* Null terminated. Max 30 chars used for now */
   LONG   fib_Protection;    /* bit mask of protection, rwxd are 3-0.      */
   LONG   fib_EntryType;
   LONG   fib_Size;          /* Number of bytes in file */
   LONG   fib_NumBlocks;     /* Number of blocks in file */
   struct DateStamp fib_Date;/* Date file last changed */
   char   fib_Comment[80];  /* Null terminated comment associated with file */

   /* Note: the following fields are not supported by all filesystems.  */
   /* They should be initialized to 0 sending an ACTION_EXAMINE packet. */
   /* When Examine() is called, these are set to 0 for you.             */
   /* AllocDosObject() also initializes them to 0.                      */
   UWORD  fib_OwnerUID;         /* owner's UID */
   UWORD  fib_OwnerGID;         /* owner's GID */
   char   fib_Reserved[32];
}; /* FileInfoBlock */

\end{verbatim}
The meaning of the members of this structure are as follows:
\medskip{}

{\tt fib\_DiskKey} is a file system internal identifier of the
object. It shall not be used, and programs shall not make any
assumptions on its meaning.
\smallskip{}

{\tt fib\_DirEntryType} identifies the type of an object. Object types
are defined in {\tt dos/dosextens.h}, replicated in
table~\ref{table:direntrytypes}:

\begin{rkrmtable}{Directory Entry Types} \label{table:direntrytypes}
{\bf Value of {\tt \bf fib\_DirEntryType}} & {\bf Description}\\ \hline \hline
{\tt ST\_SOFTLINK} & Object is a soft link to another object \\ \hline
{\tt ST\_LINKDIR} & Object is a hard link to a directory \\ \hline
{\tt ST\_LINKFILE} & Object is a hard link to a file \\ \hline
\end{rkrmtable}
All other types $>0$ indicate directories, and all other types $<0$
indicate files. Section~\ref{sec:link} provides more details on soft
links and hard links.
\smallskip{}

{\tt fib\_FileName} is the name of the object as {\tt NUL} terminated
string.
\smallskip{}

{\tt fib\_Protection} are the protection bits of the object. It
defines which operations can be performed on it. The following
protection bits are currently defined in {\tt dos/dos.h}:
\begin{rkrmtable}{Protection Bits} \label{table:protectionbits}
{\bf Protection Bits} & {\bf Description}\\ \hline \hline
{\tt FIBB\_DELETE} & If this bit is $0$, the object can be deleted.\\ \hline
{\tt FIBB\_EXECUTE} & If this bit is $0$, the file is an executable binary.\\ \hline
{\tt FIBB\_WRITE} & If this bit is $0$, the file can be written to.\\ \hline
{\tt FIBB\_READ} & If this bit is $0$, the file content can be read. \\ \hline
{\tt FIBB\_ARCHIVE} & This bit is set to $0$ on every write access. \\ \hline
{\tt FIBB\_PURE} & If $1$, the executable is reentrant and can be made resident. \\ \hline
{\tt FIBB\_SCRIPT} & If $1$, the file is a script. \\ \hline
{\tt FIBB\_HOLD} & If $1$, the executable is made resident on first execution. \\ \hline
\end{rkrmtable}
The flags {\tt FIBB\_DELETE} to {\tt FIBB\_READ} are shown inverted in
the output of most tools, i.e. they are shown active if the
corresponding flag is $0$, i.e. a particular protection function is
\emph{not} active.
\smallskip{}

The {\tt FIBB\_EXECUTE} flag is only interpreted by the \emph{Shell} (see
section~\ref{sec.shell}) and the Workbench; if the bit is $1$, the
\emph{Shell} and the Workbench refuse to load the file as command. 
\smallskip{}

The {\tt FIBB\_ARCHIVE} flag is typically used by archival
software. Such software will set this flag upon archiving the flag,
whereas the file system will reset the flag when writing to a file, or
when creating new files. The archiving software is thus able to learn
which files had been altered since the last backup.
\smallskip{}

The {\tt FIBB\_PURE} flag inidicates an additional property of
executable binaries; if the flag is set, the binaries do not alter
their segments and their code can be loaded in \emph{RAM} and stay
there to be executed from multple processes in parallel. This avoids
loading the binary multiple times. The \emph{Shell} command
{\tt resident} can load such binaries into \emph{RAM} for future usage.
\smallskip{}

The {\tt FIBB\_SCRIPT} flag indicates whether a file is a \emph{Shell}
or an \emph{ARexx} script. If this flag is set, and the script is
given as command to the \emph{Shell}, it will forward this file to a
suitable script interpreter, such as \emph{ARexx} or {\tt Execute}.
\smallskip{}

The {\tt FIBB\_HOLD} flag indicates whether a command shall be made
resident upon loading it the first time. If the flag is $1$, and the
shell loads the file as executable binary, and the {\tt FIBB\_PURE}
bit is also set, the file is kept in \emph{RAM} and stays there for
future execution.
\medskip{}

The {\tt fib\_EntryType} member shall not be used; it can be identical
to the {\tt fib\_DirEntryType}, but its use is not documented.
\smallskip{}

The {\tt fib\_Size} member indicates the size of the file in bytes. It
should have probably be defined as an unsigned type. Its value is
undefined for directories.
\smallskip{}

The {\tt fib\_NumBlocks} member indicates now many blocks a file
occupies on the storage medium, if such a concept applies. Disks and
harddisk organize their storage into blocks of equal size, and the
file system manages these blocks to store data on the medium. The
number of blocks can be meaningless for directories.
\smallskip{}

The {\tt fib\_Date} member indicates when the file was changed last;
depending on the file system, the date may also indicate when the last
modification was made for a directory, such as creating or deleting a
file within. Which operations exactly trigger a change of a directory
is file system dependent. The {\tt DateStamp}\key{DateStamp} structure is specified
in section~\ref{sec:datestamp}.
\smallskip{}

The {\tt fib\_Comment} member contains a {\tt NUL} terminated string
to a comment on the file. Not all file systems support comments. The
comment has no particular meaning, it is only shown by some
\emph{Shell} commands or utilities and can be set by the user.
\smallskip{}

The {\tt fib\_OwnerUID} and {\tt fib\_OwnerGID} are filled in by some
multi-user aware file systems. The AmigaDOS ROM file systems do not
support these fields, and no provision is made to moderate access to a
particular file according to an owner or its group. The two concepts
are alien to AmigaDOS itself.
\smallskip{}

The {\tt fib\_Reserved} field is currently unused and shall not be
accessed.

\subsection{Retrieving Information on an Directory Entry}

The {\tt Examine()}\mkey{Examine()} function retrieves information on the object
identified by a \emph{lock} and fills a {\tt FileInfoBlock} from it.

\begin{verbatim}
success = Examine( lock, FileInfoBlock )
D0                  D1        D2

BOOL Examine(BPTR,struct FileInfoBlock *)
\end{verbatim}

This function fills out the {\tt FileInfoBlock}\key{FileInfoBlock} providing information
on the object identified by {\tt lock}. The structure is discussed in
section~\ref{sec:fib} in more detail. The function returns non-zero in
case of success, and $0$ for failure. In either case, {\tt IoErr()} is filled,
by $0$ on success, on an error code on failure.

\punchline{Keep it Aligned!}{As with most BCPL structures, the {\tt
    FileInfoBlock} shall be aligned to a long-word boundary. For that
  reason, it should be allocated from the heap. Section~\ref{sec:bptrs}
  provides some additional hints on how to allocate such structures.}

\subsection{Retrieving Information from a File Handle}

While {\tt Examine()}\key{Examine()} retrieves information a locked
object, {\tt ExamineFH()}\mkey{ExamineFH()} retrieves the same
information from a \emph{file handle}, or rather from the \emph{lock}
implicit to the handle.

\begin{verbatim}
success = ExamineFH(fh, fib)
D0                  D1  D2

BOOL ExamineFH(BPTR, struct FileInfoBlock *)
\end{verbatim}

This function examines the object accessed through the
\emph{file handle} {\tt fh}, and returns the information in the
\emph{FileInfoBlock}\key{FileInfoBlock}\key{FileInfoBlock}. Note that
the file content and thus its change can be changed any time, and thus
the information returned by this function may not be fully up-to-date,
see also the general information in section~\ref{sec:fib}.
\smallskip{}

This function returns non-zero in case of success, or $0$ on error. In
either case, {\tt IoErr()}\key{IoErr()} is set, namely to $0$ on
success and to an error code otherwise.
\smallskip{}

As for {\tt Examine()}\key{Examine()}, the \emph{FileInfoBlock} shall
be aligned to a 4-byte boundary.

\subsection{Scanning through a Directory Step by Step}

The {\tt ExNext()}\mkey{ExNext()} function iterates through entries of
a directory, retrieving information on one object after another
contained in this directory. For scanning through a directory, first
{\tt Lock()}\key{Lock()} the directory itself. Then use {\tt
  Examine()}\key{Examine()} on the \emph{lock}. This provides
information on the directory itself.
\smallskip{}

To learn about the objects in the directory, iteratively call {\tt
  ExNext()} on the same {\tt lock} and on the same {\tt FileInfoBlock}
until the function returns {\tt DOSFALSE}. Each iteration provides
then information on the subsequent element in the directory of the
{\tt lock}.

\begin{verbatim}
success = ExNext( lock, FileInfoBlock )
D0                 D1        D2

BOOL ExNext(BPTR, struct FileInfoBlock *)
\end{verbatim}

This call returns information on the subsequent entry of a directory
identified by {\tt lock} and deposits this information in the {\tt
  FileInfoBlock}\key{FileInfoBlock} described in~\ref{sec:fib}. The
{\tt lock} shall be a \emph{lock} on a directory, in particular.
\smallskip{}

On success, {\tt ExNext()} returns non-zero. If there is no further
element in the scanned directory, or on an error, it returns {\tt
  DOSFALSE}. In either event, {\tt IoErr()}\key{IoErr()} is set,
namely to $0$ in case of success, or to an error code otherwise.
\smallskip{}

At the end of the directory, the function returns {\tt DOSFALSE}, and
the error code as obtained from {\tt IoErr()} is set to {\tt
  ERROR\_NO\_MORE\_ENTRIES}.

\punchline{Same Lock, Same FIB}{To iterate through a directory, a lock
  to the same directory as passed into {\tt Examine()}\key{Examine()}
  shall be used. Actually, the same \emph{lock} should be used, and
  the same \emph{FileInfoBlock} should be used. As important state
  information is associated to the \emph{lock} and
  \emph{FileInfoBlock}, {\tt UnLock()}ing the original \emph{lock} and
  obtaining a new \emph{lock} on the same directory looses this
  information; using a different \emph{FileInfoBlock} also looses this
  state information, requiring the \emph{file system} to rebuild this
  state information, which is not only complex, but also slows down
  scanning the directory. In particular, you shall \emph{not} use the
  same \emph{FileInfoBlock} you used for scanning one directory for
  scanning a second, different directory as this can confuse the
  \emph{file system}. Also, as for {\tt Examine()}\key{Examine()}, the
       {\tt FileInfoBlock} shall be aligned to a long-word boundary.}

\subsection{Examine Multiple Entries at once}

While scanning a directory with {\tt ExNext()}\key{ExNext()} requires
one interaction with the \emph{file system} for each entry and is
therefore potentially slow, {\tt ExAll()}\mkey{ExAll()} retrieves as
many entries as possible in one go. Whether a particular file system
can take advantage of such a block transfer is a matter of its orginal
organization, however.

\begin{verbatim}
continue = ExAll(lock, buffer, size, type, control)
D0               D1     D2     D3    D4     D5

BOOL ExAll(BPTR,STRPTR,LONG,LONG,struct ExAllControl *)
\end{verbatim}

This function examines as many directory entries belonging to the
directory identified by {\tt lock} as fit into the buffer {\tt buffer}
of {\tt size} bytes. This buffer is filled by a linked list of {\tt
  ExAllData} structures, see below for their layout. {\tt type}
determines which elements of {\tt ExAllData} is filled.
\smallskip{}

The {\tt lock} shall belong to a directory for this function to
succeed. It shall not be {\tt ZERO}.
\smallskip{}

To start a directory scan with {\tt ExAll()}, first allocate a {\tt
  ExAllControl}\mkey{ExAllControl} structure through {\tt
  AllocDosObject()}\key{AllocDosObject()}, see~\ref{sec:allocdosobject}.
This structure looks as follows:

\mkey{ExAllControl}
\begin{verbatim}
struct ExAllControl {
        ULONG   eac_Entries;     /* number of entries returned in buffer      */
        ULONG   eac_LastKey;     /* Don't touch inbetween linked ExAll calls! */
        UBYTE  *eac_MatchString; /* wildcard string for pattern match or NULL */
        struct Hook *eac_MatchFunc; /* optional private wildcard function     */
};
\end{verbatim}

{\tt eac\_Entries} is provided by the \emph{file system} upon
returning from {\tt ExAll} and then contains the number of entries
that fit into the {\tt buffer}. Note that this number may well be $0$,
which does not need to indicate termination of the scan. Callers shall
instead check the return code of {\tt ExAll()} to learn on whether
scanning may continue or not.
\smallskip{}

{\tt eac\_LastKey} is a \emph{file system} internal identifier of the
current state of the directory scanner. This member shall not be
interpreted nor modified in any way.
\smallskip{}

{\tt eac\_MatchString} filters the directory entry names, and returns
only those that match the wild card pointed to by this member. This
entry shall be either {\tt NULL}, or a pre-parsed pattern as generated
by {\tt ParsePatternNoCase()}\key{ParsePatternNoCase()}.
\smallskip{}

{\tt eac\_MatchFunc} is a even more flexible option to filter
directory entries. It shall be either {\tt NULL} or point to a {\tt
  struct Hook} as defined in {\tt utility/hooks.h}. If set, then for
each directory entry the hook function {\tt h\_Entry} is called as
follows:

\begin{verbatim}
match = (hook->h_Entry)(struct Hook *hook, LONG *datap,
d0                                    a0          a2

                        struct ExAllData *buf )
                                          a1
\end{verbatim}

that is, register {\tt a0} points to the called hook, register {\tt
  a1} to the data buffer to be filled, which is part of the {\tt
  buffer} supplied by the caller of {\tt ExAll()} and which is already
filled in.  Register {\tt a2} points to a {\tt LONG}, which is a copy
of the {\tt type} argument supplied to {\tt ExAll()}. If the hook
function returns non-zero, a match is assumed and the directory entry
remains in the output buffer. Otherwise, the data is discarded.
\smallskip{}

{\tt eac\_MatchFunc} and {\tt eac\_MatchString} shall not be filled in
simultaneously, only one of the two shall be non-{\tt NULL}. If both
members are {\tt NULL}, all entries match.
\medskip{}

The {\tt buffer} supplied to {\tt ExAll()} is filled by a singly
linked list of {\tt ExAllData} structures that look as follows:
\mkey{ExAllData}
\begin{verbatim}
struct ExAllData {
        struct ExAllData *ed_Next;
        UBYTE  *ed_Name;
        LONG    ed_Type;
        ULONG   ed_Size;
        ULONG   ed_Prot;
        ULONG   ed_Days;
        ULONG   ed_Mins;
        ULONG   ed_Ticks;
        UBYTE  *ed_Comment;     /* strings will be after last used field */
        UWORD   ed_OwnerUID;    /* new for V39 */
        UWORD   ed_OwnerGID;
};
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt ed\_Next} points to the next {\tt ExAllData} structure within
{\tt buffer}, or {\tt NULL} for the last structure filled in.
\smallskip{}

{\tt ed\_Name} points to the file name of a directory entry, and
supplies the same name as {\tt fib\_FileName} as in the {\tt FileInfoBlock}.
\smallskip{}

{\tt ed\_Type} identifies the type of the entry. It identifies
directory entries according to table~\ref{table:direntrytypes} and
corresponds to {\tt fib\_DirEntryType}.
\smallskip{}

{\tt ed\_Size} is the size of the directory element for files. It is
undefined for directories. It corresponds to {\tt fib\_Size}.
\smallskip{}

{\tt ed\_Prot} collects the protection bits of the directory entry
according to table~\ref{table:protectionbits} and by that corresponds
to {\tt fib\_Protection}.
\smallskip{}

{\tt ed\_Days}, {\tt ed\_Mins} and {\tt ed\_Ticks} identifies the date
of the last change to the directory element. It corresponds to {\tt fib\_Date}.
Section~\ref{sec:setfiledate} defines these elements more rigorously.
\smallskip{}

{\tt ed\_Comment} points to a potential comment on the directory entry
and corresponds to {\tt fib\_Comment}.
\smallskip{}

{\tt ed\_ed\_OwnerUID} and {\tt ed\_OwnerGID} contain potential user
and group IDs if the file system is able to provide such
information. All the AmigaDOS native file systems do not.
\medskip{}

Which members of the {\tt ExAllData} structure are filled in is
selected by the {\tt type} argument. It shall be selected according to
table~\ref{table:exalltypes}, whose elements are defined in
{\tt dos/exall.h}:

\begin{rkrmtable}{Type Values} \label{table:exalltypes}
{\bf Type} & {\bf Filled Members}\\ \hline \hline
{\tt ED\_NAME} & Fill only {\tt ed\_Next} and {\tt ed\_Name}\\ \hline
{\tt ED\_TYPE} & Fill all members up to {\tt ed\_Type} \\ \hline
{\tt ED\_SIZE} & Fill all members up to {\tt ed\_Size} \\ \hline
{\tt ED\_PROTECTION} & Fill all members up to {\tt ed\_Prot} \\ \hline
{\tt ED\_DATE} & Fill all members up to {\tt ed\_Ticks}, i.e. up to the date \\ \hline
{\tt ED\_COMMENT} & Fill all members up to {\tt ed\_Comment} \\ \hline
{\tt ED\_OWNER} & Fill all members up to {\tt ed\_OwnerGID} \\ \hline
\end{rkrmtable}

The return code {\tt continue} is non-zero in case the directory
contents was too large to fit into the supplied {\tt buffer}
completely. In such a case, either {\tt ExAll()} shall be called again
to read additional entries, or {\tt ExAllEnd()}\key{ExAllEnd()} shall
be called to terminate the call and release all internal state information.
\smallskip{}

If {\tt ExAll()} is called again, the {\tt lock} shall be identical to
the {\tt lock} passed into the first call, and not only a copy on the
same directory as for the first call.
\smallskip{}

The return code {\tt continue} is {\tt DOSFALSE} in case the scan
result fit entirely into {\tt buffer} or in case an error occured.
\smallskip{}

Regardless of the return code, {\tt IoErr()} is set to $0$ in case
{\tt continue} is non-zero, or to an error code otherwise. If the
error code is {\tt ERROR\_NO\_MORE\_ENTRIES}, then {\tt ExAll()}
terminated because all entries have been read and scanning the
directory completed. In this case, {\tt ExAllEnd()} should not be
called.
\medskip{}

Not all file systems --- actually, none delivered with AmigaOs ---
support {\tt ED\_OWNER}. If {\tt continue} is {\tt DOSFALSE} and
{\tt IoErr()} is {\tt ERROR\_BAD\_NUMBER}, try to reduce {\tt type} and
call {\tt ExAll()} again.
\smallskip{}

Some file systems do not implement {\tt ExAll()} themselves; in such a
case, the \emph{dos.library} provides a fall-back implementation
keeping {\tt ExAll()} workable regardless of the completeness of the
target \emph{file system}.

\subsection{Aborting a Directory Scan}

To abort an {\tt ExAll()}\key{ExAll()} scan through a directory,
{\tt ExAllEnd()}\mkey{ExAllEnd()} shall be called to explicitly release
all state information associated to the scan. This is unlike an
item-by-item scan through {\tt ExNext()}\key{ExNext()} which does not
require explicit termination.

\begin{verbatim}
ExAllEnd(lock, buffer, size, type, control)
          D1     D2     D3    D4     D5

void ExAllEnd(BPTR,STRPTR,LONG,LONG,struct ExAllControl *)
\end{verbatim}

This function aborts an {\tt ExAll()} driven directory scan before it
terminates due to an error or due to the end of the directory,
i.e. whenever {\tt ExAll()} returns with a non-zero result code which
would indicate that the function should be called again.
\smallskip{}

{\tt ExAll()} may also be the fastest way to terminate a directory
scan once it is running, for example on network file systems where the
scan may proceed offline on a separate server. The arguments to
{\tt ExAllEnd()} shall be exactly those supplied to
{\tt ExAll()}\key{ExAll()} which it is supposed to terminate. Note in
particular that the {\tt lock} shall be identical to the \emph{lock}
passed into {\tt ExAll()}, and not just a \emph{lock} to the same
object.

\section{Modifying Directory Entries}

While the functions in section~\ref{sec:fib} read directory entries,
the functions listed here modify the directory and its entries.

\subsection{Deleting Objects on the File System}

The {\tt DeleteFile()}\mkey{DeleteFile()} function removes --- despite
its name --- not only files, but also directories and links from a
directory. For this to succeed, the object need to allow deletion
through its protection bits (see section~\ref{sec:fib}), and no
\emph{locks} are held on the object (see section~\ref{sec:locks}).  To
be able to delete a directory, this directory needs to be empty in
addition.

\begin{verbatim}
success = DeleteFile( name )
 D0                    D1

BOOL DeleteFile(STRPTR)
\end{verbatim}

This function deletes the object given by the last component of the
path passed in as {\tt name}. It returns non-zero in case of success,
or $0$ in case of error. In either case, {\tt IoErr()}\key{IoErr()} is
set, namely $0$ on success or an error code in case of failure.

\subsection{Rename or Relocate an Object}

The {\tt Rename()}\mkey{Rename()} function changes the name of an
object, or even relocates it from one directory to another.

\begin{verbatim}
success = Rename( oldName, newName )
  D0                D1       D2

BOOL Rename(STRPTR, STRPTR)
\end{verbatim}

This function renames and optionally relocates an object between
directories. The {\tt oldName} is the current path to the object, and
its last component is the current name of the object to relocate and
rename; {\tt newName} is the target path and its last component the
target name of the object. The target directory may be different from
the directory the object is currently located in, and the target name
may be different from the current name. However, current path and
target path shall be on the same volume, and the target directory
shall not already contain an object of the target name; otherwise,
current and target path may be either relative or absolute paths.
\smallskip{}

A third condition is that if the object to relocate is a directory,
then the target path shall not be a position within the object to
relocate, i.e. you cannot move a directory into itself.
\smallskip{}

This function returns a boolean success indicator. It is non-zero on
success, or $0$ on error. In either case, {\tt IoErr()}\key{IoErr()}
is set, to $0$ on success, or to an error code otherwise.

\subsection{Set the File Comment}

The {\tt SetComment()}\mkey{SetComment()} function sets the comment of
an directory entry, provided the \emph{file system} supports comments.

\begin{verbatim}
success = SetComment( name, comment )
D0                    D1    D2

BOOL SetComment(STRPTR, STRPTR)
\end{verbatim}

This function sets the comment of the \emph{file system} object whose
path is given by {\tt name} to {\tt comment}. It depends on the file
system whether or how long comments can grow. The maximum comment
length AmigaDOS supports is 79 characters, due to the available space
in the {\tt FileInfoBlock}\key{FileInfoBlock} structure.
\smallskip{}

This function returns non-zero on success and $0$ on error. In either
case, the function sets {\tt IoErr()}\key{IoErr()} to $0$ on success
or to an error code otherwise.

\subsection{Set the Modification Date} \label{sec:setfiledate}

The {\tt SetFileDate()}\mkey{SetFileDate()} function sets the
modification date of an object of a \emph{file system}. Despite its
name, the function can also set the modification date of directories
and links if the file system supports them.

\begin{verbatim}
success = SetFileDate(name, date)
D0                     D1    D2

BOOL SetFileDate(STRPTR, struct DateStamp *)
\end{verbatim}

This function adjusts the modification date of the \emph{file system}
object identified by path as given by {\tt name} to {\tt date}. The
{\tt DateStamp}\key{DateStamp} structure is specified in
section~\ref{sec:datestamp}.
\smallskip{}

This function returns $0$ on error or non-zero on success. In either
case, {\tt IoErr()} is set, either to $0$ on success or to an error
code otherwise.
\smallskip{}

Note that not all file systems may be able to set the date precisely
to ticks, e.g. {\tt FAT} has only a precision of 2 seconds. Some file
systems may refuse to set the modification date if an object is
exclusively locked, this is unfortunately not handled consistently.

\subsection{Set User and Group ID}

The {\tt SetOwner()}\mkey{SetOwner()} function sets the user and group
ID of an object within a \emph{file system}. Both are concatenated to
a 32-bit ID value. While this function seems to imply that the file
system or AmigaDOS seems to offer some multi-user capability, this is
not the case. User and group ID are purely metadata that is returned
by the functions discussed in section~\ref{sec:fib}, they usually
ignore them. AmigaDOS has no concept of the current user of a
\emph{file system} and thus cannot decide whether a user is
priviledged to access an object on a file system. In fact, all ROM
based file systems delivered with AmigaDOS do not support setting the
user or group ID.

\begin{verbatim}
success = SetOwner( name, owner_info )
D0                   D1       D2

BOOL SetOwner (STRPTR, LONG)
\end{verbatim}

This function sets the user and group ID of the \emph{file system}
object identified by the path in {\tt name} to the value {\tt
  owner\_info}. How exactly the {\tt owner\_info} is encoded is
\emph{file system} specific. Typically, the owner is encoded in the
topmost 16 bits, and the group in the least significant 16 bits.
\smallskip{}

This function returns a boolean success indicator which is non-zero on
success and $0$ on error. This function always sets {\tt IoErr()},
either to $0$ on success or to an error code otherwise.

\section{Working with Paths} \label{sec:workpaths}

The \emph{dos.library} contains a couple of support functions that
help working with paths, see also section~\ref{sec:paths}. What is
different from the remaining functions is that the paths are not
interpreted by the file system, but rather by the \emph{dos.library}
itself. This has several consequences: First, there is no 255
character limit as the path is never communicated into the \emph{file
  system} as it was stated in section~\ref{sec:pathlimit}. Second, as
the paths are constructed or interpreted by the library and not the
\emph{file system}, the syntax of the path is also that imposed by the
library.
\smallskip{}

That is, for these functions to work, the separator between component
must be the forwards slash ('{\tt /}') and the parent directory must
be indicated by an isolated single forward slash without a component
upfront. This implies, in particular, that the involved file systems
follow the conventions of AmigaDOS.

\subsection{Find the Path From a Lock}

The {\tt NameFromLock()}\mkey{NameFromLock()} function constructs a
path to the locked object, i.e. if the constructed path is used to
create a lock, it will refer to the same object.

\begin{verbatim}
success = NameFromLock(lock, buffer, len)
D0                      D1     D2    D3

BOOL NameFromLock(BPTR, STRPTR, LONG)
\end{verbatim}

This function constructs in {\tt buffer} an absolute path that
identifies the object locked by {\tt lock}. At most {\tt len} bytes
will be filled into {\tt buffer}, including {\tt NUL} termination of the
string. The created string is always {\tt NUL}-terminated, even if the
buffer is too short. However, in such a case the function returns~$0$,
and {\tt IoErr()}\key{IoErr()} is set to {\tt ERROR\_LINE\_TOO\_LONG}.
\smallskip{}

If the path cannot be constructed due to an error, {\tt success} is
also set to $0$ and {\tt IoErr()} is set to an error code. However, on
success, {\tt IoErr()} is not set consistently and cannot be depended
upon. Possible cases of failure are that the volume the locked object
is located on is currently not inserted in which case it will be
requested. The {\tt ZERO} lock is correctly interpreted, and resolves
into the string {\tt SYS:}. The {\tt lock} remains valid after the
call.

\subsection{Append a Component to a Path}

The {\tt AddPart()}\mkey{AddPart()} adds an absolute or relative path
to an existing path; the resulting path is constructed as if the input
path is a directory, and the attached (second) path identifies an object
relative to this given directory. The function handles special cases
such as the colon ('{\tt :}') and one or multiple leading slashes
('{\tt /}') correctly and are interpreted according to the rules
explained in section~\ref{sec:paths}: The colon identifies the root of
the volume, and a leading slash the parent directory, upon which the
trailing component of the input path is removed.

\begin{verbatim}
success = AddPart( dirname, filename, size )
D0                   D1        D2      D3

BOOL AddPart( STRPTR, STRPTR, ULONG )
\end{verbatim}

This function attaches to the existing path in {\tt dirname} another
path in {\tt filename}. The constructed path will overwrite the buffer
in {\tt dirname}, which is able to hold {\tt size} bytes, including a
terminating {\tt NUL} byte.
\smallskip{}

If the required buffer for the constructed path, including
termination, is larger than {\tt size} bytes, then the function
returns $0$ and {\tt IoErr()} is set to {\tt ERROR\_LINE\_TOO\_LONG},
and the input buffers are not altered. Otherwise, the function returns
non-zero, and {\tt IoErr()} is not altered.
\smallskip{}

This function does not interact with a \emph{file system} and does not
check whether the paths passed in correspond to accessible
objects. The output path is constructed purely based on the AmigaDOS
syntax of paths.

\subsection{Find the last Component of a Path}

The {\tt FilePart()}\mkey{FilePart()} function finds the last
component of a path; the function name is a bit misleading since the
last component does not necessarily correspond to a file, but could
also correspond to a directory once identified by a \emph{file
  system}. If there is only a single component in the path passed in,
this component is returned. If the path passed in terminates with at
least two slashes ('{\tt /}') indicating that the last component is at
least one level above, a pointer to the terminating slash is returned.

\begin{verbatim}
        fileptr = FilePart( path )
        D0                   D1

        STRPTR FilePart( STRPTR )
\end{verbatim}

This function returns in {\tt fileptr} a pointer to the last component
of the path passed in as {\tt path}, or a pointer to '{\tt /}' in case
the input path terminates with at least two slashes.
\smallskip{}

This function cannot fail, and does not touch {\tt IoErr()}.

\subsection{Find End of Next-to-Last Component in a Path}

The {\tt PathPart()}\mkey{PathPart()} identifies the end of the
next-to-last component in a path. That is, if a {\tt NUL} is injected
at the pointer returned by this function, the resulting string
starting at the passed in buffer corresponds to a path that
corresponds to the directory containing the last component of the
path. If the passed in path consists only of a single component, the
returned pointer is identical to the pointer passed in.

\begin{verbatim}
fileptr = PathPart( path )
D0                   D1

STRPTR PathPart( STRPTR )
\end{verbatim}

This function returns in {\tt fileptr} a pointer to the end of the
next-to-last component of the {\tt path} passed in. This function
cannot fail and does not alter {\tt IoErr()}.
\smallskip{}

The only difference between this function and {\tt
  FileParth()}\key{FilePart()} is that the latter advanced over a
potential trailing slash. That is, if the last character of the input
path of {\tt PathPart()} would be a slash, then {\tt PathPart()} would
return a pointer to this slash, but {\tt FilePart()} would advance
beyond this slash. That is, the ``file part'' of a path that
explicitly indicates a directory is empty, though the ``path part'' is
the same path without the trailing slash.

\section{Links} \label{sec:links}

\emph{Links} are tools to escape the tree-like hierarchy of
directories, sub-directories and files. A \emph{link} mirrors one
object of a file system to another location such that if the object is
changed using the path of one location, the changes are reflected in
another location. Put differently, creating a link is like copying an
object except that copy and original are always in sync. The storage
for the payload data of a file is only required once, the link just
points to the same data as the original directory entry. The same goes
for links between directories: Whenever a new entry is made in one
directory, the change also appears in the other.
\smallskip{}

AmigaDOS supports two (or, actually, three) types of links:
\emph{Hard-links} and \emph{Soft-links}. The \emph{RAM-Handler}
supports a third type that will be discussed below. \emph{Hard-links}
establish the relation between two \emph{file-system} objects on the
same volume at the level of the file system. That is, whenever a link
is accessed, the file system resolves the link, transparent to its
user.  While for the Amiga \emph{Fast File System} and the
\emph{RAM-Handler} a \emph{hard-link} is a distinct directory entry
type, some file systems do not distinguish between the original object
and a \emph{hard-link} to it. For such file systems, the same payload
data is just referenced by two directory entries. If the larget of a
link is deleted on the \emph{Fast File System} or the
\emph{RAM-Handler}, and (at least one) link to the object still
exists, then (one of) the link(s) takes over and becomes the object
itself. For other file systems, only a file system internal reference
counter is decreased, and the payload data is removed only if this
counter becomes zero.
\smallskip{}

\emph{Soft-Links} work differently and can also be established between
two different \emph{file systems}, or between two different
volumes. Here, the \emph{soft-link} is a type of its own that contains
the path of the referenced object. If such a \emph{soft-link} is
accessed, an error code is reported by the \emph{file-system} and it
is then up to a higher layer such as the \emph{dos.library} or an
application program to read the link destination, and use it to create
a path from the original path and the link destination. The access is
then (hopefully) retried under the updated path. As this object may
also be a \emph{soft-link}, this process can continue; in worst case,
indefinitely if one link refers to another in a circular way. To avoid
this situation, the \emph{dos.library} follows at most 15 links.
\smallskip{}

The \emph{dos.library} supports \emph{Soft-Links} through the
functions listed in Table~\ref{table:softenabled}:

\begin{rkrmtable}{Softlink aware functions} \label{table:softenabled}
{\bf Function} & {\bf Purpose}\\ \hline \hline
{\tt Open()} & Open a file\\ \hline
{\tt Lock()} & Obtain access rights to an object\\ \hline
{\tt CreateDir()} & Create a directory\\ \hline
{\tt SetProtection()} & Modify protection bits\\ \hline
{\tt SetFileDate()} & Set the modification date of a file\\ \hline
{\tt DeleteFile()} & Delete an object on a file system\\ \hline
{\tt SetComment()} & Modify object comment\\ \hline
{\tt MakeLink()} & Create a link to an object\\ \hline
{\tt SetOwner()} & Set User and Group ID\\ \hline
\end{rkrmtable}

All of the above functions take a path of its first argument. If the
path consists of multiple components, i.e. identifies an object in a
nested directory, and one of the intermediate components are, in
fact, \emph{soft-links}, the \emph{dos.library} will automatically
resolve such an intermediate link and construct internally the true
path to the link destination. Whether a soft-link at the last
component is resolved is typically \emph{file system} and function
dependent. For example, {\tt Open()} will always resolve
\emph{soft-links}, but {\tt Lock()} or {\tt SetProtection()} may not
and may instead affect the link, not the target object. {\tt
  DeleteFile()} will never resolve a link at the final component of
the path, and will therefore delete the link, not the object linked
to.
\smallskip{}

Note that {\tt Rename()}\key{Rename()} is currently not on the list
supporting softlinks as part of the path to the object to be renamed, or as
part of the target path.
\smallskip{}

If the target of a \emph{Soft-Link} is deleted (and not the link
itself), a link pointing to it becomes invalid, even though remains in the
\emph{file system}. Any attempt to resolve the link then, obviously,
fails. AmigaDOS does not attempt to identify such invalid links. The
same cannot happen for \emph{hard-links}.
\medskip{}

Finally, the \emph{RAM-Handler} supports a special type of
\emph{hard-links} that goes across volumes. These \emph{external
  links} copy the linked object on a read-access into the RAM disk,
i.e. the \emph{RAM-Handler} implements a \emph{copy on access}. This
feature is used for the {\tt ENV:} assign containing all active system
settings. This assign points to a directory in the RAM disk which
itself is externally linked to {\tt ENVARC:}. Thus, whenever a program
attempts to access its settings --- such as the preferences programs
--- the \emph{RAM-Handler} automatically copies the data from {\tt
  ENVARC:} to {\tt ENV:}, avoiding a manual copy and also saving RAM
space for settings that are currently not accessed and thus unused.
\medskip{}

The {\tt FileInfoBlock} introduced in section~\ref{sec:fib} identifies
links through the {\tt fib\_DirEntryType} member. As seen from
table~\ref{table:direntrytypes}, \emph{hard-links} to files are
indicated by {\tt ST\_LINKFILE} and \emph{hard-links} to directories
by {\tt ST\_LINKDIR}. Note, however, that not all file systems are
able to distinguish \emph{hard-links} from regular directory entries,
so this feature cannot be dependened upon. In particular,
\emph{external links} of the \emph{RAM-Handler} cannot be identified
by any particular value of the {\tt fib\_DirEntryType}.
\smallskip{}

Table~\ref{table:direntrytypes} also provides the {\tt
  fib\_DirEntryType} for \emph{soft-links}, namely {\tt
  ST\_SOFTLINK}. As the target of a \emph{soft-link} may not under
control of the \emph{file system}, it cannot know whether the link
target is a file or a directory (or maybe another link), and therefore
a single type is sufficient to identify them.

\subsection{Creating Links}

The {\tt MakeLink()}\mkey{MakeLink()} function creates a
\emph{hard-link} or a \emph{soft-link} to an existing object on a
\emph{file system}.

\begin{verbatim}
success = MakeLink( name, dest, soft )
D0                   D1    D2    D3

BOOL MakeLink( STRPTR, LONG, LONG )
\end{verbatim}

This function creates a new link at the path {\tt name} of the type
given by {\tt soft}. The destination the link points to is given by
{\tt dest}.
\smallskip{}

If {\tt soft} is {\tt FALSE}, {\tt dest} is a \emph{lock} represented
by {\tt BPTR}. For most \emph{file systems}, {\tt dest} shall be on
the same volume as the one identified by the path in {\tt name}. The
currently only exception is the \emph{RAM-Handler} for which the
destination \emph{lock} may be on a different volume. In such a case,
an \emph{external link} is created. While the target object will be
created, it may look initially like an empty file or an empty
directory, depending on the type of the link destination. Its contents
is copied, potentially recursively creating directories, by copying
the contents of the link destination into the link, or to a file or
directory within the link. Thus, the link becomes a mirror of the link
destination whenever an object within the link or the link itself is
accessed.
\smallskip{}

If {\tt soft} is non-zero, {\tt dest} is a {\tt const UBYTE *} that
shall be casted to a {\tt LONG}. Then, this function creates a
\emph{soft-link} that is relative to the path of the link, i.e.
{\tt name}. For details on \emph{soft-link} resolution, see
section~\ref{sec:readlink}.
\smallskip{}

This function returns in {\tt success} non-zero if creation of the
lock succeeded, or $0$ in case of failure. In either case,
{\tt IoErr()} is set to an error code on failure, or $0$ on success.

\subsection{Resolving Soft-Links} \label{sec:readlink}

The {\tt ReadLink()}\mkey{ReadLink()} function locates the destination
of a \emph{soft-link} and constructs from the path and directory of
the link a new path that identifies the target of the link. A typical
use case for this function is if a \emph{dos.library} function returns
with the error {\tt ERROR\_IS\_SOFT\_LINK}, indicating that the
\emph{file system} needs help from a higher layer to grant access to
the object. You then typically retry the access to the object with the
path constructed by this function. Note well that this path may be
that of yet another \emph{soft-link}, requiring recursive resolution
of the link. To avoid endless recursion, this loop should be aborted
after a maximum number of attempts, then generating an error such as
{\tt ERROR\_TOO\_MANY\_LEVELS}. A suggested maximum level of nested
\emph{soft-links}, also used by the \emph{dos.library}, is 15 links.
\smallskip{}

Note, however, that such steps would not be necessary for the
functions listed in table~\ref{table:softenabled} as they already
perform such steps internally.

\begin{verbatim}
success = ReadLink( port, lock, path, buffer, size)
D0                   D1    D2    D3     D4     D5

BOOL ReadLink( struct MsgPort *, BPTR, STRPTR, STRPTR, ULONG)
\end{verbatim}

This function creates in {\tt buffer} of {\tt size} bytes a path to
the target of a \emph{soft-link} contained in the input {\tt path}
relative to the directory represented by {\tt lock}. Typically, {\tt
  path} is the path given to some object you attempted to access, and
{\tt lock} is the \emph{lock} as given by the current
directory\key{CurrentDir()} to which the path is relative. The output
path constructed in {\tt buffer} is then an updated path relative to
the same directory, i.e. relative to {\tt lock}.
\smallskip{}

The {\tt port} is the message port of the file system that is queried
to resolve the \emph{soft-link}; this port should be obtained from
{\tt GetDeviceProc()}\key{GetDeviceProc()}, see
section~\ref{sec:getdevproc}. For relative paths, this port is
identical to the one in the {\tt fl\_Task} member of the {\tt FileLock}
structure representing {\tt lock}, see section~\ref{sec:filelock}.
\smallskip{}

If {\tt size} is too small to hold the adjusted path, the function
returns $0$ and sets {\tt IoErr()} to {\tt ERROR\_LINE\_TOO\_LONG}.
\smallskip{}

The function returns non-zero in case of success, or $0$ in case of
error. In either case, {\tt IoErr()}\key{IoErr()} is set to ether $0$
on succes, or an error code otherwise.

\chapter{Administration of Volumes, Devices and Assigns} \label{sec:devicelist}

The \emph{dos.library} is just a layer of AmigaDOS that provides a
common API for input/output operations; these operations are not
implemented by the library itself, but forwarded to
\emph{file systems} or \emph{handlers}. This forwarding is based on the
exec \emph{message} and \emph{message port} system, and to this
end, the {\tt FileLock} structure and the {\tt FileHandle} structure
contain a pointer to a {\tt MsgPort}.
\smallskip{}

However, the \emph{dos.library} also needs to obtain this port from
somewhere; for relative paths (see section~\ref{sec:paths}), the
current directory\key{CurrentDir()} (see section~\ref{sec:currentdir})
provides it. For absolute paths, i.e. paths that contain a colon
('{\tt :}'), the string upfront the colon identifies handler, directly
or indirectly. If this string is empty, i.e. the path starts with a
colon, it is again the handler of the current directory that is
contacted, but otherwise, the dos searches the \emph{device list} to
find a suitable \emph{message port}. This algorithm is also available
as a function, namely {\tt GetDeviceProc()}\key{GetDeviceProc()},
which is documented in section~\ref{sec:getdeviceproc}.
\smallskip{}

Internally, the \emph{dos.library} keeps the relation between such
names and the corresponding ports in the {\tt DosList} structure. Such
a structure is also created when \emph{mounting} a handler,
i.e. advertizing the handler to the system, or when creating an
\emph{Assign}, see section~\ref{sec:assignlist}, or when inserting a
disk into a drive, thus making a particular \emph{volume} available to
the system (see also~\ref{sec:volumelist}). Only the names from
table~\ref{table:specialdevices} in~\ref{sec:deviceoverview} are
special cases and hard-coded into the~\emph{dos.library} without
requiring an entry in the \emph{device list} in the form of a
{\tt DosList} structure.
\smallskip{}

This structure, defined in {\tt dos/dosextens.h} reads as follows:

\mkey{DosList}
\begin{verbatim}
struct DosList {
    BPTR                dol_Next;        /* bptr to next device on list */
    LONG                dol_Type;        /* see DLT below */
    struct MsgPort     *dol_Task;        /* ptr to handler task */
    BPTR                dol_Lock;
    union {
        struct {
        BSTR    dol_Handler;    /* file name to load if seglist is null */
        LONG    dol_StackSize;  /* stacksize to use when starting process */
        LONG    dol_Priority;   /* task priority when starting process */
        ULONG   dol_Startup;    /* startup msg: FileSysStartupMsg for disks */
        BPTR    dol_SegList;    /* already loaded code for new task */
        BPTR    dol_GlobVec;    /* BCPL global vector to use when starting
                                 * a process. -1 indicates a C/Assembler
                                 * program. */
        } dol_handler;

        struct {
        struct DateStamp        dol_VolumeDate;  /* creation date */
        BPTR                    dol_LockList;    /* outstanding locks */
        LONG                    dol_DiskType;    /* 'DOS', etc */
        } dol_volume;

        struct {
        UBYTE   *dol_AssignName;     /* name for non-or-late-binding assign */
        struct AssignList *dol_List; /* for multi-directory assigns (regular) */
        } dol_assign;

    } dol_misc;

    BSTR                dol_Name;        /* bptr to bcpl name */
};
\end{verbatim}

and its members have the following purpose:
\smallskip{}

{\tt dol\_Next} is a \emph{BPTR} to the corresponding next entry in a
singly linked list of {\tt DosList} structures. However, this list
should not be walked manually, but instead {\tt FindDosEntry()}\key{FindDosEntry()} should be used for
iterating through this list.
\smallskip{}

{\tt dol\_Type} identifies the type of the entry, and by that also the
layout of the structure, i.e. which members of the unions are
used. The following types are defined in {\tt dos/dosextens.h}:

\begin{rkrmtable}{\emph{DosList} Entry Types} \label{table:doslisttypes}
{\tt \bf dol\_Type} & {\bf Description}\\ \hline \hline
{\tt DLT\_DEVICE} & A \emph{file system} or \emph{handler}, see~\ref{sec:deviceoverview}\\ \hline
{\tt DLT\_DIRECTORY} & A regular assign, see~\ref{sec:assignlist}\\ \hline
{\tt DLT\_VOLUME} & A volume, see~\ref{sec:volumelist}\\ \hline
{\tt DLT\_LATE} & A late binding assign, see~\ref{sec:assignlist}\\ \hline
{\tt DLT\_NONBINDING} & A non-binding assign, see~\ref{sec:assignlist}\\ \hline
\end{rkrmtable}

{\tt dol\_Task} is the \emph{MsgPort} of the handler to contact for
the particular \emph{handler}, \emph{assign} or \emph{volume}. It may
be {\tt NULL} if the \emph{handler} is not started, or a new handler
process is supposed to be started for each file opened. This is, for
example, the case for the console which requires a process for each
window it handles. \emph{File systems} usually provide their port here
such that the same process is used for all objects on the
volume. \emph{Volumes} keep here the \emph{MsgPort} of the \emph{file
  system} that operates the volume, but it to {\tt NULL} in case the
volume goes away, e.g. is ejected. For \emph{regular assigns}, this is
also the pointer to the \emph{MsgPort} of the \emph{file system} the
assign binds to; in case the assign is a \emph{multi-assign}, this is
the \emph{MsgPort} of the first directory bound to. All additional
ports are part of the {\tt AssignList}. For \emph{late assigns} this
member is initially {\tt NULL}, but will be filled in as soon as the
assign in bound to a particular directory, and then becomes the
pointer to the \emph{MsgPort} of the handler the assign is bound
to. Finally, for \emph{non-binding assigns} this member always stays
{\tt NULL}.
\smallskip{}

{\tt dol\_Lock} is only used for \emph{assigns}, and only if it is
bound to a particular directory. That is, the member remains
{\tt ZERO} for \emph{non-binding assigns} and is initially {\tt ZERO} for
\emph{late assigns}. For all other types, this member stays {\tt ZERO}.
\smallskip{}

{\tt dol\_Name} is a \emph{BPTR} to a \emph{BSTR} is the name under
which the \emph{handler}, \emph{volume} or \emph{assign} is
accessed. That is, this string corresponds to the path component
upfront the colon. As a courtesy to C and assembler functions,
AmigaDOS ensures that this string is {\tt NUL} terminated, i.e.
{\tt dol\_Name + 1} is a regular C string whose length is available in
{\tt dol\_Name[0]}.
\medskip{}

The members within {\tt dol\_handler} are used by \emph{handlers} and
\emph{file systems}, i.e. if {\tt dol\_Type} is {\tt DLT\_DEVICE}.
\smallskip{}

{\tt dol\_Handler} is a \emph{BPTR} to a \emph{BSTR} containing the
file name from which the \emph{handler} or \emph{file system} is
loaded from. It corresponds to the {\tt Handler}, {\tt FileSystem} and
{\tt EHandler} fields of the mount list. They all deposit the file
name here.
\smallskip{}

{\tt dol\_StackSize} specifies the size of the stack for creating the
\emph{handler} or \emph{file system} process. Interestingly, the unit
of the stack size depends on the {\tt dol\_GlobVec} entry. If {\tt
  dol\_GlobVec} is negative indicating a C or assembler handler, {\tt
  dol\_StackSize} is in bytes. Otherwise, that is, for BCPL handlers,
it is in 32-bit long words. This member corresponds to the {\tt
  Stacksize} entry of the mount list.
\smallskip{}

{\tt dol\_Priority} is priority of the handler process. Even though it
is a {\tt LONG}, it shall be a number between $-128$ and $127$ because
priorities of the exec task scheduler are {\tt BYTE}s. For all
practical purposes, the priority should be a value between $0$ and
$19$. It corresponds to the {\tt Priority} entry of the mount list.
\smallskip{}

{\tt dol\_Startup} is a handler-specific startup value that is used to
commumicate a configuration to the handler during startup. While this
value may be whatever the handler requires, the {\tt mount} command
either deposits here a small integer, or a pointer to the {\tt
  FileSysStartupMsg} structure defined in {\tt
  dos/filehandler.h}. Section~\ref{sec:handler} provides more details
on mounting handlers and how the startup mechanism
works. Unfortunately, it is hard to interpret {\tt dol\_Startup}
correctly, see~\ref{sec:startup}. One way to set this member is to set
{\tt Startup} in the mount list, see~\ref{sec:startup} for details.
\smallskip{}

{\tt dol\_SegList} is a \emph{BPTR} to the chained segment list of the
handler if it is loaded. For disk-based handlers, this member is
initially {\tt ZERO}. When a program attempts to access a file on the
handler, the \emph{dos.library} first checks whether this field is
{\tt ZERO}, and if so, attempts to find a segment, i.e. a binary, for
the handler. If the {\tt FORCELOAD} entry of the mount list is
non-zero, the {\tt mount} command already performs this activity. The
process of loading a handler depends on the nature of the handler and
explained in more detail in section~\ref{sec:startup}.
\smallskip{}

{\tt dol\_GlobVec} identifies the nature of the handler as AmigaDOS
supports (still) BPCL and C/assembler handlers and defines how access
to the \emph{dos list} is secured for handler loading and startup.
BCPL handlers use a somewhat more complex loading and linking
mechanism as the language-specific \emph{global vector} needs to be
populated. This is not required for C or assembler handlers where a
simpler mechanism is sufficient, more on this in
section~\ref{startup}. Another aspect of the startup process is how
the \emph{device list} is protected from conflicting accesses from
multiple processes. Two types of access protection are possible:
Exclusive access to the list, or shared access to the list. Exclusive
access protects the \emph{device list} from any changes while the
handler is loaded and until handler startup completed. This prevents
any other modification to the list, but also read access from any
other process to the list. Shared access allows read accesses to the
list while preventing exclusive access to it.
\smallskip{}

The value in {\tt dol\_GlobVec} corresponds to the {\tt GlobVec} entry
in the mount list. It shall be one of the values in
table~\ref{table:gvvalues}.

\begin{rkrmtable}{GlobVec Values} \label{table:gvvalues}
{\tt \bf dol\_Type} & {\bf Description}\\ \hline \hline
{\tt -1} & C/assembler handler, exclusive lock on the \emph{dos list} \\ \hline
{\tt -2} & C/assembler handler, shared lock on the \emph{dos list} \\ \hline
{\tt  0} & BCPL handler using system GV, exclusive lock on the \emph{dos list} \\ \hline
{\tt -3} & BCPL handler using system GV, shared lock on the \emph{dos list} \\ \hline
{\tt >0} & BPCL handler with custom GV, exclusive lock on the \emph{dos list} \\ \hline
\end{rkrmtable}

The values $0$, $-3$ and $>0$ all setup a BCPL handler, but differ in
the access type to the \emph{device list} and how the BCPL
\emph{global vector} is populated. This vector contains all global
objects and all globally reachable functions of a BCPL program,
including functions of the \emph{dos.library}. The values $0$ and $-3$
fill this vector with the system functions first, and then use the
BPCL binding mechanism to extend or override entries in this vector
with the values found in the loaded code. Any values $>0$ defines a
\emph{BPTR} to a custom vector which is used instead for initializing
the handler. This startup mechanism has never been used in AmigaDOS
and is not quite practical as this vector needs to be communicated into
the \emph{dos.library} somehow. For new code, BCPL linkage and binding
should not be used anymore.
\medskip{}

Members of the {\tt dol\_volume} structure are used if {\tt dol\_Type}
is {\tt DLT\_VOLUME}, identifying this entry as belonging to a known
specific data carrier.
\smallskip{}

{\tt dol\_VolumeDate} is the creation date of the volume. It is a
{\tt DateStamp}\ref{sec:datestamp} structure that is specified in
section~\ref{sec:datestamp}. It is used to uniquely identify the volume,
and to distinguish this volume from any other volume of the same name.
\smallskip{}

{\tt dol\_LockList} is a pointer to a singly-linked list of
\emph{locks} on the volume. This list is created by the
\emph{file system} when the volume is ejected, and contains all locks on this
volume. It is stored here to allow a similar file system to pick up
the locks once the volume is re-inserted, even if it is re-inserted
into another device. Note that the linkage is performed with
\emph{BPTR}s and the {\tt fl\_Link} member of the {\tt FileLock}
structure.
\smallskip{}

{\tt dol\_DiskType} is an identifier of the \emph{file system type}
that operated the volume and placed here such that an alternative
process of the same file system is able to pick up or refuse the locks
stored here for non-available volumes.
\medskip{}

Members of the {\tt dol\_assign} structure are used for all other
types, i.e. all types of \emph{assigns}.
\smallskip{}

{\tt dol\_AssignName} is pointer to the target name of the assign for
\emph{non-binding} and \emph{late assigns}. The \emph{dos.library}
uses this string to locate the target of the assign. For \emph{late
  assigns}, this member is used only on the first attempt to access
the assign at which {\tt dol\_Lock} is populated.
\smallskip{}

{\tt dol\_List} contains additional locks for \emph{multi-assigns} and
is only used if {\tt dol\_Type} is {\tt DLT\_DIRECTORY}. In such a
case, {\tt dol\_Lock} is the lock to the first directory of the
\emph{multi-assign}, while {\tt dol\_List} contains all following
\emph{locks} in a singly-linked list of {\tt AssignList} structures:

\mkey{AssignList}
\begin{verbatim}
struct AssignList {
        struct AssignList *al_Next;
        BPTR               al_Lock;
};
\end{verbatim}

{\tt al\_Next} points to the next \emph{lock} that is part of the
\emph{multi-assign} and {\tt al\_Lock} is the lock itself. This
structure is also defined in {\tt dos/dosextens.h}.

\section{Finding Handler or File System Ports}

The following functions find the \emph{MsgPort} of the \emph{handler}
or \emph{file system} that is responsible for a given object. The
functions search the \emph{device list}, check whether the handler is
already loaded or load it if necessary, then check whether the handler
is already running, and if not, launch an instance of it. If
\emph{multi-assigns} are involved, it can become necessary to contact
multiple \emph{file systems} to resolve the task and thus to iterate
through multiple potential \emph{file systems} to find the right one.

\subsection{Iterate through Devices Matching a Path}

The {\tt GetDeviceProc()}\mkey{GetDeviceProc()} find a handler, or the
next handler responsible for a given path. Once the handler has been
identified, or iteration through matching handlers is to be aborted,
{\tt FreeDeviceProc()} shall be called to release temporary resources.

\begin{verbatim}
devproc = GetDeviceProc(name, devproc)
D0                      D1     D2

struct DevProc *GetDeviceProc(STRPTR, struct DevProc *)
\end{verbatim}

This function takes a path in {\tt name} and either {\tt NULL} on the
first iteration or a {\tt DevProc} structure from a previous iteration
and returns either a {\tt DevProc} structure in case a matching
handler could be identified, or {\tt NULL} if no matching handler
could be found or all possible matches have been iterated over already
already.

\punchline{Give back what you got}{To release all temporary resources,
  the {\tt DevProc} structure returned by {\tt GetDeviceProc()} shall be
  either be released through {\tt FreeDeviceProc()} then aborting the scan,
  or used as first argument for {\tt GetDeviceProc()} to continue the
  iteration. The last call to this function will return {\tt NULL} and then
  also release all resources.}

The {\tt DevProc} structure, defined in {\tt dos/dosextens.h}
looks as follows:

\key{DevProc}
\begin{verbatim}
struct DevProc {
        struct MsgPort *dvp_Port;
        BPTR            dvp_Lock;
        ULONG           dvp_Flags;
        struct DosList *dvp_DevNode;    /* DON'T TOUCH OR USE! */
};
\end{verbatim}

{\tt dvp\_Port} is a pointer to a candidate \emph{MsgPort} that should
be tried to resolve {\tt name}.
\smallskip{}

If the matching handler is a \emph{file system}, then {\tt dvp\_Lock}
is a \emph{lock} of a directory. The path in {\tt name}is a path
relative to this directory. This \emph{lock} shall not be released,
but it may be copied with {\tt DupLock}\key{DupLock()}.
\smallskip{}

{\tt dvp\_Flags} identifies the nature of the found port. If the bit
{\tt DVPB\_ASSIGN} is set, i.e {\tt dvp\_Flags \& DVPF\_ASSIGN} is
non-zero, then the found match is part of a \emph{multi-assign} and
{\tt GetDeviceProc()} may be called again with the {\tt devproc}
argument just returned as second argument. This will return another
candidate for a path. {\tt DVPB\_UNLOCK} is another bit of the flags
but shall not be interpreted and is only used internally by the function.
\smallskip{}

The member {\tt dvp\_DevNode} shall not be touched or used and is
required internally by the function.
\medskip{}

If the function returns {\tt NULL}, then {\tt IoErr()}\key{IoErr()}
provides additional information on the failure. If the error code is
{\tt ERROR\_NO\_MORE\_ENTRIES}, then the last directory of a
\emph{multi-assign} has been reached. If the error code is {\tt
  ERROR\_DEVICE\_NOT\_MOUNTED}, then no matching device could be
found. Other errors may be returned, e.g. if the function could not
allocate sufficient memory for its operation.
\smallskip{}

Unfortunately, the function does not set {\tt IoErr()} consistently if
{\tt GetDeviceProc()} is called again on an existing {\tt DevProc}
structure as second argument with {\tt DVPB\_ASSIGN} cleared. {\tt
  IoErr()} remains then unaltered and it is therefore advisable to
clear it upfront.
\smallskip{}

The function also returns {\tt NULL} if {\tt name} corresponds to the
{\tt NIL:} pseudo-device and then sets {\tt IoErr()} to {\tt
  ERROR\_DEVICE\_NOT\_MOUNTED}. This is not fully correct, and callers
need to be aware of this defect.
\smallskip{}

Also, {\tt GetDeviceProc} does not handle the path ``{\tt *}'' at all,
even though it indicates the current console and the
\emph{Console-Handler} is responsible for it.  This case also needs to
be detected by the caller, and in such a case,
{\tt GetConsoleTask()}\key{GetConsoleTask()} delivers the correct port.

\punchline{Does not like all paths}{The {\tt GetDeviceProc()} function
  unfortunately does not handle all device specifiers correctly, and some
  special cases need to be filtered out by the caller. Namely ``{\tt *}''
  indicating the current console, and {\tt NIL:} for the {\tt NIL}
  pseudo-device are not handled here.}
 
\subsection{Releasing DevProc Information}

The {\tt FreeDeviceProc()}\mkey{FreeDeviceProc()} function releases a
{\tt DevProc}\key{DevProc} structure previously returned by {\tt
  GetDeviceProc()}\key{GetDeviceProc()} and releases all temporary
resources allocated by this function. It shall be called as soon as
the {\tt DevProc} structure is no longer needed.

\begin{verbatim}
FreeDeviceProc(devproc)
                 D1

void FreeDeviceProc(struct DevProc *)
\end{verbatim}

This function releases the {\tt DevProc} structure and all its
resources from an iteration through one or multiple
{\tt GetDeviceProc()} calls. If {\tt GetDeviceProc()} returned {\tt NULL}
itself it had already released such resources itself and no further
activity is necessary.
\smallskip{}

The {\tt dvp\_Port} or {\tt dvp\_Lock} within the {\tt DevProc}
structure shall not be used after releasing it with {\tt
  FreeDeviceProc()}. If a \emph{lock} is needed afterwards, a copy of
{\tt dvp\_Lock} shall be made with {\tt DupLock()}\key{DupLock()}. If
the port of the \emph{handler} or \emph{file system} is needed
afterwards, a resource of this handler shall be obtained, e.g. by
opening a file or obtaining a lock on it. Both the {\tt
  FileHandle}\key{FileHandle} and the {\tt FileLock}\key{FileLock}
structures contain a pointer to the port of the corresponding handler.
\smallskip{}

It is safe to call {\tt FreeDeviceProc()} with a {\tt NULL} argument;
this performs no activity.
\smallskip{}

This function does not set {\tt IoErr()} consistently and no
particular value may be assumed. It may or may not alter its value.

\subsection{Legacy Handler Port Access}

The {\tt DeviceProc()}\mkey{DeviceProc()} function is a legacy variant
of {\tt GetDeviceProc()}\key{GetDeviceProc()} that should not be used
anymore. It is not able to reliably provide locks to \emph{assigns}
and will not work through all directories of a \emph{multi-assign}.

\begin{verbatim}
process = DeviceProc( name )
 D0                    D1

struct MsgPort *DeviceProc (STRPTR)
\end{verbatim}

This function returns a pointer to a port of a \emph{handler} or
\emph{file system}able to handle the path {\tt name}. It returns
{\tt NULL} on error in which case it sets {\tt IoErr()}\key{IoErr()}.
\smallskip{}

If the passed in {\tt name} is part of an \emph{assign}, the handler
port of the directory the assign binds to is returned, and {\tt
  IoErr()} is set to the \emph{lock} of the assign. Unfortunately, one
cannot safely make use of this \emph{lock} as the \emph{device list}
may be altered any time, including the time between the return from
this function and its first use by the caller. Thus, {\tt
  GetDeviceProc()} shall be used instead which locks resources such as
the \emph{device list}; they are released through {\tt
  FreeDeviceProc()}.

\punchline{Obsolete and not fully functional}{{\tt DeviceProc()} function
  does not operate properly on \emph{multi-assigns} where it only provides
  the port and \emph{lock} to the first directory participating in the
  assign. It also returns {\tt NULL} for \emph{non-binding assigns} as there
  is no way to release a temporary lock obtained on the target of the
  \emph{assign}. Same as {\tt GetDeviceProc()}, it does not properly handle
  {\tt NIL:} and ``{\tt *}''.}

\subsection{Obtaining the Current Console Handler} \label{sec:getconsoletask}

The {\tt GetConsoleTask()}\mkey{GetConsoleTask()} function returns the
\emph{MsgPort} of the handler responsible for the console of the
calling process, that is, the process that takes care of the file name
``{\tt *}'' or paths relative to {\tt CONSOLE:}.

\begin{verbatim}
port = GetConsoleTask()
 D0

struct MsgPort *GetConsoleTask(void)
\end{verbatim}

This function returns a port to the handler of the console of the
calling process, or {\tt NULL} in case there is no console associated
to the caller. The latter holds for example for programs started from
the workbench. It does not alter {\tt IoErr()}.

\subsection{Obtaining the Default File System} \label{sec:getfilesystask}

The {\tt GetFileSysTask()}\mkey{GetFileSysTask()} function returns the
\emph{MsgPort} of the default \emph{file system} of the caller. The
default \emph{file system} is used as fall-back if a
\emph{file system} is required for a path relative to the {\tt ZERO} lock, and
the path itself does not contain an indication of the responsible
handler, i.e. is a relative path itself.
\smallskip{}

The default \emph{file system} is typically the boot file system, or
the file system of the {\tt SYS:} \emph{assign}, though it can be
changed with {\tt SetFileSysTask()} at any point.

\begin{verbatim}
port = GetFileSysTask()
 D0

struct MsgPort *GetFileSysTask(void)
\end{verbatim}

This function returns the port of the default file system of this
task. It does not alter {\tt IoErr()}. Note that {\tt SYS:} itself is
an \emph{assign} and paths starting with {\tt SYS:} do therefore not
require resolution through this function, though the default
\emph{file system} and the file system handling {\tt SYS:} are
typically identical. However, as the former is returned by {\tt
  GetFileSysTask()} and the latter is part of the \emph{device list}
\emph{assign}, they can be different.

\section{Iterating and Accessing the Device List}

While {\tt GetDeviceProc()}\key{GetDeviceProc()} uses the \emph{device
  list} to locate a particular \emph{MsgPort} and \emph{Lock}, all
other members of the {\tt DosList} structure remain unavailable. For
them, the \emph{device list} containing these structures need to be
scanned manually. The \emph{dos.library} provides functions to grant
access, search and release access to this list.

\subsection{Gaining Access to the Device List}

The {\tt LockDosList()}\mkey{LockDosList()} function requests shared
or exclusive access to a subset of entries of the \emph{device list}
containing all \emph{handlers}, \emph{volumes} and \emph{assigns} and
blocks until access is granted. It requires as input multiple sets
that specify which parts of the list to access:

\begin{verbatim}
dlist = LockDosList(flags)
 D0                   D1

struct DosList *LockDosList(ULONG)
\end{verbatim}

This function grants access to a subset of entries of the \emph{device
  list} indicated by {\tt flags}, and returns an opaque handle through
which elements of the list can be accessed. For this, see
{\tt FindDosEntry()}\key{FindDosEntry()}.
\smallskip{}

The {\tt flags} value shall be combination of the following values, all
defined in {\tt dos/dosextens.h}:

\begin{rkrmtable}{LockDosList Flags} \label{table:lockdoslistflags}
{\tt Flags} & {\bf Description}\\ \hline \hline
{\tt LDF\_DEVICES} & Access \emph{handlers} and \emph{file system} entries, see~\ref{sec:deviceoverview} \\ \hline
{\tt LDF\_VOLUMES} & Access \emph{volumnes}, see~\ref{sec:volumelist} \\ \hline
{\tt LDF\_ASSIGNS} & Access \emph{assigns}, see~\ref{sec:assignlist} \\ \hline \hline
{\tt LDF\_ENTRY}  & Lock access to a {\tt DosList} entries \\ \hline
{\tt LDF\_DELETE} & Lock \emph{device list} for deletion \\ \hline \hline
{\tt LDF\_READ} & Shared access to the \emph{device list} \\ \hline
{\tt LDF\_WRITE} & Exclusive access to the \emph{device list} \\ \hline
\end{rkrmtable}

At least {\tt LDF\_READ} or {\tt LDF\_WRITE} shall be included in the
flags, they shall not be set both. The three first flags may also be
combined to access multiple types.
\smallskip{}

{\tt LDF\_ENTRY} and {\tt LDF\_DELETE} are additional flags that
moderate access to entries of the \emph{device list}. If {\tt
  LDF\_ENTRY} is set, then exclusive access to the selected entries is
requested and entries shall not be altered or removed. The {\tt
  LDF\_ENTRY} flag shall not be combined with {\tt LDF\_READ}. If
{\tt LDF\_DELETE} is set, then access is granted for removing entries
from the list.
\medskip{}

The result code {\tt dlist} is \emph{not} a pointer to a {\tt DosList}
structure, but only a handle that may be passed into {\tt
  FindDosEntry()}\key{FindDosEntry()} or {\tt
  NextDosEntry()}\key{NextDosEntry}. If {\tt dlist} is {\tt NULL},
then locking failed because the combination of {\tt flags} passed in
was invalid.
\smallskip{}

This function does not alter {\tt IoErr()}.

\subsection{Requesting Access to the Device List}

The {\tt AttemptLockDosList()}\mkey{AttemptLockDosList()} requests
access to the \emph{device list} or a subset of its entries, and, in
case it cannot gain access, returns {\tt NULL}. Unlike
{\tt LockDosList()}\key{LockDosList()}, it does not block.

\begin{verbatim}
dlist = AttemptLockDosList(flags)
D0                          D1

struct DosList *AttemptLockDosList(ULONG)
\end{verbatim}

The {\tt flags} argument specifies which elements of the \emph{device
  list} are requested for access, and which type of access is
required. The flags are a combination of the flags listed in
table~\ref{table:lockdoslistflags}, and the semantics of the flags are
exactly as specified for {\tt LockDosList()}\key{LockDosList()}, see
there for details.
\smallskip{}

The result code is either a (non-{\tt NULL}) handle that may be passed
into {\tt FindDosEntry()}\key{FindDosEntry()} or {\tt
  NextDosEntry()}\key{NextDosEntry()} in case access could be granted,
or {\tt NULL}. In the latter case, the list is either currently locked
and access cannot be granted without blocking, or flags are
invalid. These two cases of failure cannot be distinguished
unfortunately.
\smallskip{}

This function does not alter {\tt IoErr()}.

\subsection{Release Access to the Device List}

The {\tt UnLockDosList()}\mkey{UnLockDosList()} function releases
access to the \emph{device list} once obtained through {\tt
  LockDosList()}\key{LockDosList()}.

\begin{verbatim}
UnLockDosList(flags)
                D1

void UnLockDosList(ULONG)
\end{verbatim}

This function releases access to the \emph{device list} again. The
{\tt flags} argument shall be identical to the {\tt flags}argument
provided to {\tt LockDosList()}\key{LockDosList()}.

\subsection{Iterate through the Device List}

The {\tt NextDosEntry()}\mkey{NextDosEntry()} iterates to the next
entry in the \emph{device list} given the current entry or the handle
returned by {\tt LockDosList()}.

\begin{verbatim}
newdlist = NextDosEntry(dlist,flags)
 D0                       D1    D2

struct DosList *NextDosEntry(struct DosList *,ULONG)
\end{verbatim}

This function returns the next {\tt DosList}\key{DosList} structure of the
\emph{device list} which shall have been locked with {\tt LockDosList()}. The
{\tt dlist} argument shall be either the return code of a previous
{\tt NextDosEntry()} or {\tt FindDosEntry()}\key{FindDosEntry()}
call, or the handle returned by {\tt LockDosEntry()}.
\smallskip{}

The {\tt flags} argument shall be a subset of the {\tt flags} argument
into {\tt LockDosList()} and specifies the type of {\tt DosList}
structures that shall be found. Only the first 3 elements of
Table~\ref{table:lockdoslistflags} are relevant here, all other flags
are ignored but may be included.
\smallskip{}

The {\tt newdlist} result is either a pointer to a {\tt DosList}
structure of the requested type, or {\tt NULL} if the end of list has
been reached. This function does not alter {\tt IoErr()}.

\subsection{Find a Device List Entry by Name}

The {\tt FindDosEntry()}\mkey{FindDosEntry()} function finds a
{\tt DosList}\key{DosList} structure of a particular type and particular
name, from a particular entry on, or the handle returned by
{\tt LockDosList()}\key{LockDosList()}.

\begin{verbatim}
newdlist = FindDosEntry(dlist,name,flags)
D0                       D1    D2   D3

struct DosList *FindDosEntry(struct DosList *,STRPTR,ULONG)
\end{verbatim}

This function scans through the \emph{device list} starting at the
entry {\tt dlist}, or the handle returned by {\tt LockDosList()}, and
returns the next {\tt DosList} structure that is of the type indicated
by {\tt flags} and has the name {\tt name}.
\smallskip{}

The {\tt flags} shall be a subset of the {\tt flags} argument passed
into {\tt LockDosList()}. Only the first 3 elements of
Table~\ref{table:lockdoslistflags} are relevant here, all other flags
are ignored but may be included.
\smallskip{}

The {\tt name} argument is the (case-insensitive) name of the {\tt
  assign}, {\tt handler}, {\tt file system} or {\tt volume} the
function should look for. The name \emph{shall not} include the colon
('{\tt :}') that separates the name from the remaining components of a
path, see section~\ref{sec:paths}. It may be {\tt NULL} in which case
every entry of the requested type matches.
\smallskip{}

The returned {\tt newdlist} is a pointer to a {\tt DosList} structure
that matches the name (if provided) and flags passed in, or {\tt NULL}
in case no match could be found and the entire list has been
scanned. Note that the returned {\tt DosList} may be identical to the
{\tt dlist} passed in if it already fits the requirements. Thus
potentially, {\tt NextDosList()} may be called upfront to scan from
the subsequent entry.
\smallskip{}

Passing {\tt NULL} as {\tt dlist} is safe and returns {\tt NULL},
i.e. the end of the list. Note that the (pseudo-) devices from
tables~\ref{table:specialdevices} and \ref{table:specialassigns} are
not part of the \emph{device list}, i.e. {\tt NIL}, {\tt CONSOLE},
{\tt *} and {\tt PROGDIR} cannot be found and are special cases of
{\tt GetDeviceProc()}\key{GetDeviceProc()}.
\smallskip{}

This function does not alter {\tt IoErr()}.

\section{Adding or Removing Entries to the Device List}

The \emph{dos.library} provides two service functions to add or remove
{\tt DosList} structures from the \emph{device list}. They secure the
\emph{dos.library} internal state from inconsistencies as other
processes may attempt to access the \emph{device list} simultaneously,
and they also ensure proper linkage of the structures.
\smallskip{}

\punchline{Locking the device list in file systems}{There is one particular
  race condition \emph{file system} authors should be aware of. When opening
  a file, or obtaining a \emph{lock}, the \emph{dos.library} calls through
  {\tt GetDeviceProc()} to identify a \emph{handler} responsible for the
  requested path. As {\tt GetDeviceProc()}\key{LockDosList()} requires
  access to the \emph{device list}, it will secure access to it through {\tt
    LockDosList()}\key{LockDosList()}, then possibly start up the
  \emph{handler}, and then unlock the list. Thus, at the time the handler is
  initiated, it may find the \emph{device list} unaccessible. Attempting to
  lock it would result in a \emph{deadlock} situation as the
  \emph{dos.library} waits for the \emph{handler} to reply its startup
  packet, and the \emph{handler} waits for the \emph{dos.library} to grant
  access to the \emph{device list}.  The following sections provide
  workarounds how to avoid this situation, see also
  section~\ref{sec:handler} for details on the \emph{handler} and \emph{file
  system} startup mechanism.}

\subsection{Adding an Entry to the Device List}

The {\tt AddDosEntry()}\mkey{AddDosEntry()} adds an initialized {\tt
  DosList} structure to the \emph{device list}.

\begin{verbatim}
success = AddDosEntry(dlist)
D0                     D1

LONG AddDosEntry(struct DosList *)
\end{verbatim}

This function takes an initialized {\tt DosList} entry pointed to by
{\tt dlist} and attempts to add it to the \emph{device list}. For
this, it requests write access to the list, i.e. locking of the
\emph{device list} through the caller is not necessary.
The {\tt DosList} may be either created manually, by
{\tt MakeDosEntry()}\key{MakeDosEntry()} of the \emph{dos.library}
or by {\tt MakeDosNode()}\key{MakeDosNode()} of the \emph{expansion.library}.
While there the structure is called a {\tt DeviceNode}, it is still a
particular incarnation of a {\tt DosList} and may be savely used here.
\medskip{}

\emph{Assigns} \emph{shall not} be added to the \emph{device list}
through this function, but rather through the functions in
section~\ref{sec:assigns}. This avoids memory management problems when
releasing or changing assigns.
\smallskip{}

Particular care needs to be taken if this function is called from
within a \emph{handler} or \emph{file system}, e.g. to add a
\emph{volume} representing an inserted medium. As the list may be
locked by the \emph{dos.library} to secure the list from modifications
within a {\tt GetDeviceProc()}\key{GetDeviceProc()} function, a
deadlock may result where \emph{file system} and \emph{dos.library}
mutually block access. To prevent this from happening handlers should
check upfront whether the \emph{device list} is available for
modifications by {\tt AttemptLockDosList()}\key{AttemptLockDosList()}, e.g.

\begin{verbatim}
if (AttemptLockDosList(LDF_VOLUMES|LDF_WRITE)) {
  rc = AddDosEntry(volumenode);
  UnLockDosList(LDF_VOLUMES|LDF_WRITE);
}
\end{verbatim}
when adding a {\tt DosList} entry of type {\tt DLT\_VOLUME}. If
attempting to get write access failed, the handler should check for
incoming requests, handle them, and attempt adding the entry later.
\smallskip{}

The function fails if an entry is to be added and an entry of the same
name, regardless its type, is already present on the list. The only
exception is that the list may contain two \emph{volumes} of the same
name, provided provided their creation date {\tt dol\_VolumeDate}
differs, see section~\ref{sec:devicelist}.
\smallskip{}

If successful, the function returns non-zero, but then does not alter
{\tt IoErr()}. The {\tt DosList} is then enqueued in the
\emph{dos.library} database and it and its members shall then no
longer be altered or released by the caller. On failure, the function
returns $0$ and {\tt IoErr()} is set to {\tt ERROR\_OBJECT\_EXISTS}.

\subsection{Removing an Entry from the Device List}

The {\tt RemDosEntry()}\mkey{RemDosEntry()} removes a {\tt DosList}
entry from the \emph{device list}, making it unacessible for AmigaDOS.

\begin{verbatim}
success = RemDosEntry(dlist)
D0                     D1

BOOL RemDosEntry(struct DosList *)
\end{verbatim}

This function attempts to find the {\tt DosList} structure pointed to
by {\tt dlist} in the \emph{device list} and, if present, removes
it. Unlike what some other documentation says, this funciton locks the
\emph{device list} properly before attempting to remove an entry,
locking it upfront is not necessary.
\smallskip{}

The function does \emph{not} attempt to release the memory allocated
for the {\tt DosList} passed in, or any of its members, it just
removes the {\tt DosList} from the \emph{device list}. While
\emph{file systems} may know how they allocated the {\tt DosList}
structures represening their \emph{volumes} and hence should be aware
how to release the memory taken by them, there is no good solution on
how to recycle memory for {\tt DosList} structures representing
\emph{handlers}, \emph{file systems} or \emph{assigns}. Some manual
footwork is currently required, see also {\tt
  FreeDosNode()}\key{FreeDosNode()}. In particular, as entries
representing \emph{handlers} and \emph{file systems} may have been
created in multiple ways, their memory cannot be safely recycled.
\smallskip{}

Particular care needs to be taken if this function is called from
within a \emph{handler} or \emph{file system}, e.g. to remove a
\emph{volume} representing a removed medium. As the list may be
locked by the \emph{dos.library} to secure the list from modifications
within a {\tt GetDeviceProc()}\key{GetDeviceProc()} function, a
deadlock may result where \emph{file system} and \emph{dos.library}
mutually block access. To prevent this from happening handlers should
check upfront whether the \emph{device list} is available for
modifications by {\tt AttemptLockDosList()}\key{AttemptLockDosList()}, e.g.

\begin{verbatim}
if (AttemptLockDosList(LDF_DELETE|LDF_ENTRY|LDF_WRITE)) {
  rc = RemDosEntry(volumenode);
  UnLockDosList(LDF_DELETE|LDF_ENTRY|LDF_WRITE);
}
\end{verbatim}
when removing a {\tt DosList} entry. If attempting to get write access
failed, the handler should check for incoming requests, handle them,
and attempt adding the entry later.
\smallskip{}

This function returns a success indicator; it returns non-zero if the
function succeeds, and $0$ in case it fails. The only reason for
failure is that {\tt dlist} is not a member of the
\emph{device list}. This function does not touch {\tt IoErr()}.

\section{Creating and Deleting Device List Entries}

AmigaOs offers multiple functions to create {\tt DosList}
structures. The {\tt MakeDosEntry()}\key{MakeDosEntry()} function is a
low-level function that allocates a {\tt DosList} but only performs
minimal intialization of the structure. For \emph{assigns}, the
functions in section~\ref{sec:assigns} shall be used as they include
complete initialization of the {\tt DosList}, and for \emph{handlers}
and \emph{file systems}, the \emph{expansion.library} function
{\tt MakeDosNode()}\key{MakeDosNode()} is a proper alternative.
Releasing {\tt DosList}s along with all its resources is unfortunately
much harder. For \emph{assigns}, the algorithm in
section~\ref{sec:releaseentry} provides a workable function based on
{\tt FreeDosEntry()}\key{FreeDosEntry()}.
\smallskip{}

{\tt DosLists} representing \emph{Volumes} are build and released by
\emph{file systems}; it depends on them which resources need to be
released along with the {\tt DosList} structure itself. While it is
recommended that \emph{file systems} should go through
{\tt MakeDosEntry()}\key{MakeDosEntry()} and {\tt FreeDosEntry()}\key{FreeDosEntry()}, it
is not a requirement.
\smallskip{}

Releasing a {\tt DosList} representing a \emph{handler} or \emph{file
  system} is currently not possible in a completely robust way. It is
suggested just to unlink such nodes if absolutely necessary, but
tolerate the memory leak.

\subsection{Creating a Device List Entry}

The {\tt MakeDosEntry()}\mkey{MakeDosEntry()} creates an empty
{\tt DosList} structure of the given type, and makes all elementary
initializations. It does not accquire any additional resources, and neither
inserts it into the \emph{device list}.
\smallskip{}

If an \emph{assign} is to be created, the functions in
section~\ref{sec:assigns} are better alternatives and should be
preferred as they perform a more sophisticated initialization.

\begin{verbatim}
newdlist = MakeDosEntry(name, type)
D0                       D1    D2

struct DosList *MakeDosEntry(STRPTR, LONG)
\end{verbatim}

This function allocates a {\tt DosList} structure and initializes its
{\tt dol\_Type} to {\tt type}. The {\tt type} argument shall be one of
the values from table~\ref{table:doslisttypes}. The function also
makes a copy of {\tt name} and initializes the {\tt dol\_Name} to a
\emph{BSTR} copy of {\tt name}, which is a {\tt NUL} terminated C string.
\smallskip{}

Note that this function performs only minimal initialization of the
{\tt DosList} structure. All other members except {\tt dol\_Type} and
{\tt dol\_Name} are initialized to $0$.
\smallskip{}

This function either returns the allocated structure, or {\tt NULL}
for failure. In the latter case, {\tt IoErr()} is set to {\tt
  ERROR\_NO\_FREE\_STORE}. On success, {\tt IoErr()} remains
unaltered.

\subsection{Releasing a Device List Entry} \label{sec:releaseentry}

The {\tt FreeDosEntry()}\mkey{FreeDosEntry()} function releases
a {\tt DosList} structure allocated by {\tt MakeDosEntry()}\key{MakeDosEntry()}.
The {\tt DosList} shall be already removed from the \emph{device list} by
\emph{RemDosEntry()}. While this call releases the memory holding the
name of the entry, and also the {\tt DosList} structure itself, it
does not release any other resources. They shall be released by the
caller of this function. Furthermore, this function shall not be
called if the {\tt DosList} structure was allocated by any other means
than {\tt MakeDosEntry()}.

\begin{verbatim}
FreeDosEntry(dlist)
               D1

void FreeDosEntry(struct DosList *)
\end{verbatim}

This function releases the {\tt DosList} structure pointed to by
{\tt dlist} and its name, but only these two resources, and no other
resources.
\smallskip{}

If {\tt dol\_Type} is {\tt DLT\_DEVICE}, corresponding to
\emph{handlers} or \emph{file systems}, this function should better
not be called at all as the means of how the {\tt DosList} was
allocated is unclear. In such a case, a memory leak is the least
dangerous side effect.
\smallskip{}

If {\tt dol\_Type} is {\tt DLT\_DIRECTORY} or {\tt DLT\_LATE}, then
{\tt dol\_Lock} should be unlocked. If {\tt dol\_List} is non-{\tt
  NULL}, then each entry of the {\tt AssignList} structure shall be
released, along with the lock kept within. For {\tt DLT\_LATE} and
{\tt DLT\_NONBINDING}, the {\tt dol\_AssignName} function shall also
be released. The following code segment releases all resources for
\emph{assigns}:

\begin{verbatim}
    struct AssignList *al,*next;
    UnLock(dol->dol_Lock);
    al = dol->dol_misc.dol_assign.dol_List;
    while(al) {
        next = al->al_Next;
        UnLock(al->al_Lock);
        FreeVec(al);
        al = next;
    }
    FreeVec(dol->dol_misc.dol_assign.dol_AssignName);
    FreeDosEntry(dol);
\end{verbatim}

The above code reflects the way how resources were originally
allocated by the \emph{dos.library}.
\smallskip{}

If the type is {\tt DLT\_VOLUME}, it is up to the \emph{file system}
to release any resources it allocated along with the {\tt DosList}. It is file
system dependent which resources can or should be released. {\tt
  DosList} entries of this type should only be touched by the
\emph{file system} that created them.
\smallskip{}

This function cannot fail, and it does not touch {\tt IoErr()}.

\section{Creating and Updating Assigns} \label{sec:assigns}
While {\tt MakeDosEntry()}\key{MakeDosEntry()} creates a {\tt DosList}
entry for the \emph{device list}, it only performs minimal
initialization of the structure. For \emph{assigns}, specifically, the
\emph{dos.library} provides specialized functions that allocate,
initialize and enqueue {\tt DosList} structures representing assigns
in a single call and are thus easier to use.

\subsection{Create and Add a Regular Assign}

The {\tt AssignAdd()}\mkey{AssignAdd()} function creates a new assign
to a directory from a \emph{lock}, and then enqueues it into the
\emph{device list}.

\begin{verbatim}
success = AssignLock(name,lock)
D0                    D1   D2

BOOL AssignLock(STRPTR,BPTR)
\end{verbatim}
This function creates a (regular) \emph{assign} onto the directory
identified by {\tt lock}. The \emph{assign} created under the name as
given by {\tt name}. The name shall not include a trailing colon
(``{\tt :}'') that separates the \emph{assign} name from the rest of
the path. The lock shall be a \emph{shared lock}.

If the function is successful, it returns a non-zero result code. The
{\tt lock} is then absorbed into the \emph{assign} and shall no longer
be used by the calling program. On success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and the {\tt lock} remains
available to the caller. {\tt IoErr()}\key{IoErr()} is set to an error code
identifying the cause of the failure.
{\tt ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is
returned if the function run out of memory. If a {\tt DosList} of the
same name (regardless of which type) already exists, the error code is
{\tt ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Create a Non-Binding Assign}

The {\tt AssignPath()}\mkey{AssignPath()} function creates a
\emph{non-binding assign} and adds it to the \emph{device list}. This
type of assign binds to a path independent of the volume the path is
located on; that is, the \emph{assign} resolves to whatever
\emph{volume}, \emph{handler} or even other \emph{assign} matches the
path.

\begin{verbatim}
success = AssignLate(name,path)
D0                    D1   D2

BOOL AssignLate(STRPTR,STRPTR)
\end{verbatim}
This function creates a \emph{non-binding} assign whose name is given
by the first argument, and which resolves to the path given as second
argument, and then adds the \emph{assign} to the \emph{device
  list}. The {\tt name} shall not contain a trailing colon (``{\tt
  :}''). While not a formal requirement of the function or
\emph{non-binding assigns}, the {\tt path} should better be an
absolute path as otherwise resolution of the created \emph{assign} can
be very confusing --- it is then resolved relative to the current
directory of the calling process.

If the function is successful, it returns a non-zero result code. On
success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and {\tt IoErr()}\key{IoErr()} is set to an
error code identifying the cause of the failure. {\tt
  ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is returned if the function run out of
memory. If a {\tt DosList} of the same name (regardless of which type)
already exists, the error code is {\tt ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Create a Late Assign}

The {\tt AssignLate()}\mkey{AssignLate()} function creates a
\emph{late assign} whose target is initially given by a path; but
after its first resolution, the \emph{assign} reverts to a
\emph{regular assigns} such that the target of the \emph{assign} will
point to the same directory of the volume from that point on. This has
the advantage that the target of the assign does not need to be
available at creation time of the assign, yet remains unchanged after
its first usage.

\begin{verbatim}
success = AssignLate(name,path)
D0                    D1   D2

BOOL AssignLate(STRPTR,STRPTR)
\end{verbatim}
This function creates a \emph{late binding assign} of the name {\tt
  name} pointing to {\tt path} as its destination and adds it to the
\emph{device list}. The {\tt name} shall not contain a trailing colon
(``{\tt :}''). While not explicitly required by this function, the
{\tt path} should better be an absolute path as otherwise
resolving the \emph{assign} can be very confusing. The {\tt path}
is then relative to the current directory of the process using
the \emph{assign} the first time.

If the function is successful, it returns a non-zero result code. On
success, {\tt IoErr()} is not altered.

On error, the function returns $0$ and {\tt IoErr()}\key{IoErr()} is
set to an error code identifying the cause of the failure. {\tt
  ERROR\_NO\_FREE\_STORE}\key{ERROR\_NO\_FREE\_STORE} is returned if
the function run out of memory.  If a {\tt DosList} of the same name
(regardless of which type) already exists, the error code is {\tt
  ERROR\_OBJECT\_EXISTS}\key{ERROR\_OBJECT\_EXISTS}.

\subsection{Add a Directory to a Multi-Assign}

The {\tt AssignAdd()}\mkey{AssignAdd()} function adds a directory,
identified by a \emph{lock}, to an already existing \emph{regular} or
\emph{multi-assign}. On success, a \emph{regular assign} is then
converted into a \emph{multi-assign}.

\begin{verbatim}
success = AssignAdd(name,lock)
D0                   D1   D2

BOOL AssignAdd(STRPTR,BPTR)
\end{verbatim}
This function adds the {\tt lock} at the end of the target directory
list of the \emph{assign} identified by {\tt name}. The {\tt name}
does not contain a trailing colon (``{\tt :}'').

A {\tt DosList} of the given {\tt name} shall already when entering
this function, and this {\tt DosList} shall be a \emph{regular
  assign}. Attempting to add a directory to a \emph{handler},
\emph{file system}, \emph{volume} or any other type of \emph{assign}
fails.

On success, the function returns a non-zero result code. In such a
case, the {\tt lock} is absorbed into the \emph{assign} and shall no
longer be used by the caller. The \emph{assign} is converted into a
\emph{multi-assign} on access if it is not already one. The {\tt lock}
is added at the end of the directory list, i.e. the new directory is
scanned last when resolving the \emph{assign}.

On error, the function returns $0$ and the {\tt lock} remains
available to the caller. Unfortunately, this function does not set
{\tt IoErr()}\key{IoErr()} consistently, i.e. it is unclear on failure
what caused the error, i.e. whether the function run out of memory,
whether no fitting \emph{device list} entry was found, or whether the
entry found was not a \emph{regular assign}.

\subsection{Remove a Directory From a Multi-Assign}

The {\tt RemAssignList()}\mkey{RemAssignList()} function removes a
directory, represented by a {\tt lock}, from a {\tt multi-assign}. If
only a single directory remains in the \emph{multi-assign}, it is
converted into a \emph{regular assign}. If the \emph{assign} was a
regular assign, and the only directory is removed from it, the
\emph{assign} itself is removed from the \emph{device list} and
released, destroying it and releasing all resources.

\begin{verbatim}
success = RemAssignList(name,lock)
D0                       D1   D2

BOOL RemAssignList(STRPTR,BPTR)
\end{verbatim}
This function removes the directory identified by {\tt lock} from a
\emph{regular} or \emph{multi-assign} identified by {\tt name}. The
name shall not contain a trailing colon (``{\tt :}''). If only a
single directory remains in the \emph{assign}, it is converted to a
\emph{regular assign}. If no directory remains at all, the
\emph{assign} is deleted and removed from the \emph{device list}. The
{\tt lock} remains available to the caller, regardless of the
result code. Note that the {\tt lock} passed in does not need to be
identical to the \emph{lock} contained in the \emph{assign}, but it
needs to be a \emph{lock} on the same directory. This function uses
{\tt SameLock()}\key{SameLock()} function to compare the two locks.

On success, the function returns a non-zero result code in {\tt
  success}.  On error, the function returns $0$. Unfortunately, it
does not set {\tt IoErr()} consistently in all cases, and thus, the
cause of an error cannot be determined upon return. Possible causes
of error are that {\tt name} does not exist, or that it is not a
\emph{assign} or a \emph{multi-assign}.

\chapter{Pattern Matching} \label{sec:patternmatch}
Unlike other operating systems, it is neither the file system nor the shell
that expands wild cards, or patterns. Instead, separate functions exist
that, given a wildcard, scan a directory or an entire directory tree and
deliver all files, links and directories that match a given pattern.
\smallskip{}

The pattern matcher syntax is build on special characters or \emph{tokens}
that define which names to match. The following tokens are currently
defined:
\begin{itemize}
  \item[{\tt ?}] The question mark matches a single, arbitrary character
    within a component. When using the pattern matcher for scanning
    directories, the question mark does not match the component separator,
    i.e. the slash (``{\tt /}) and the colon (``{\tt :}'') that separates
    the path from the device name. Note in particular that the question mark
    also matches the dot (``{\tt .}'') which is not a special character
    under AmigaDOS.
  \item[{\tt \#}] The hash mark matches zero or more repeats of the token
    immediately following it. In particular, the combination ``{\tt \#?}''
    matches zero or more arbitrary characters. If a group of more than one
    token is required to describe which combination needs to match, this
    group needs to be enclosed in brackets.
  \item[{\tt ()}] The brackets bind tokens together forming a single
    token. This is particularly useful for the hash mark {\tt \#} as it
    allows to formulate repeats of longer character or token groups. For
    example, {\tt \#(ab)} indicates zero or more repeats of the character
    sequence {\tt ab}, such as {\tt ab}, {\tt abab} or {\tt ababab}.
  \item[{\tt \textasciitilde{} }] The ASCII tilde (``{\tt \textasciitilde{}}'') matches names that do not
    match the next token. This is particularly valuable for filtering out
    the workbench icon files that end on {\tt .info}, i.e. {\tt \textasciitilde{}(\#?.info)}
    matches all files that do not end with {\tt .info}.
  \item[{\tt[]}] The square brackets (``{\tt []}'') matches a single
    character from a range, e.g. {\tt [a-z]} matches a single alphabetic
    character and {\tt [0-9]} matches a single digit. Multiple ranges and
    individual characters can be combined, for example {\tt [ab]} matches
    the characters {\tt a} and {\tt b}, whereas {\tt [a-cx-z]} matches the
    characters from {\tt a} to {\tt c} and from {\tt x} to {\tt z}. If the
    minus sign (``{\tt -}'') is supposed to be part of the range, it shall
    appear first, directly within the bracket, e.g. {\tt [-a-c]} matches the
    dash and the characters {\tt a} to {\tt c}. If the dash is the last
    character in the range, all characters up to the end of the ASCII range,
    i.e. {\tt 0x7f} match, but none of the extended ISO Latin 1 characters
    match. If the closing square bracket (``{\tt ]}'') is to matched, it
    shall be escaped by an apostroph (``{\tt '}''), i.e. {\tt [[-']]}
    matches the opening and the closing bracket. If the pattern matcher is
    used for scanning directories, the above example does not match the
    slash (``{\tt /}'') even though its code point lies between the
    opening and closing bracket because the slash cannot be part of a
    component name and rather separates components. If the first character
    of the range is an ASCII tilde (``{\tt \textasciitilde{}}''), then the
    character class matches all characters \emph{not} in the class,
    i.e. {\tt [\textasciitilde{}a-z]} matches all characters except
    alphabetic characters. In all other places, the tilde stands for itself.
  \item[{\tt '}] The apostroph ({\tt '}) is the escape character of the
    pattern matcher and indicates that the next character is not a token of
    the matcher, but rather stands for itself. Thus, {\tt '?} matches the
    question mark, and only the question mark, and no other character.
  \item[{\tt \%}] The percent sign (``{\tt \%}'') matches the empty string.
  \item[{\tt |}] The vertical bar (``{\tt |}'') defines alternatives and
    matches the token to its left or the token to its right. The
    alternatives along with the vertical bar shall be enclosed in round
    brackets to bind them, i.e. {\tt (a|b)} is either the character {\tt a}
    or {\tt b} and therefore matches the same strings {\tt [ab]} matches. A
    particular example is {\tt \textasciitilde{}((\#?.info)|.backdrop)}
    which matches all files not used by the workbench for storing
    meta-information. 
\end{itemize}   

\punchline{The Asterisk {\tt *} is not a Wildcard}{Unlike many other
operating systems, the asterisk (``{\tt *}'') has a (two) other meanings
under AmigaDOS. It rather refers to the current console as file name, or
is the escape character for quotation and control sequences; those are
properties AmigaDOS inherits from the BCPL syntax and TRIPOS. While there
is a flag in the \emph{dos.library} that makes the asterisk \emph{also}
available as a wildcard, such usage is discouraged because it can lead to
situations where the asterisk is interpreted differently than intended ---
as it has already two other meanings.}

Pattern matching works in in two steps: In the first step, the pattern is
tokenized into an internal representation, which is then later on used to
perform the actual match of a string against a wildcard. The directory
scanning function {\tt MatchFirst()}\key{MatchFirst()} performs this
conversion internally, and thus no additional preparation is required by the
caller in this case. However, if the pattern matcher is used to search for
strings or wildcards within a text file, the pattern tokenizers {\tt
  ParsePattern()}\key{ParsePattern()} or its case-insensitive counterpart
{\tt ParsePatternNoCase()}\key{ParsePatternNoCase()} shall be called first.

\punchline{Only ISO-Latin Codepoints}{The pre-parsing step that prepares
  from the input pattern its tokenized version uses the code points {\tt
    0x80} to {\tt 0x9f} for tokenized versions of wild-cards and other
  instructions for the pattern matcher. This is identical to the extended
  ISO-Latin control sequence region, and does not represent printable
  charactes.  While file names on AmigaDOS \emph{file systems} may in
  principle include such code-points, patterns of the pattern matcher
  \emph{shall not} contain unprintable code points from the region {\tt
    0x00} to {\tt 0x1f} or from {\tt 0x80} to {\tt 0x9f}. These regions are
  reserved for the pattern matcher.}

\section{Scanning Directories}

The prime purpose of the pattern matcher is to scan a directory, or even a
tree of directories, identifying all \emph{file system} objects such as
files, links or directories that match a given pattern. The pattern matcher
can even descend recursively into sub-directories if instructed to do
so. This service is used by many shell commands stored in the {\tt C:}
\emph{assign}. The directory scanner requires the following steps:
\smallskip{}

First, the user shall provide an {\tt AnchorPath} structure. This structure
contains the state of the directory matcher, including the {\tt
  FileInfoBlock}\key{FileInfoBlock} structure of the matched object. This
structure is defined in section~\ref{sec:fib}. Optionally, the {\tt
  AnchorPath} structure may also contain the complete (relative) path of the
matched object. This structure shall then be initialized, setting all flags
required, see below for their definition.

\punchline{Must be Long-Word Aligned}{As the {\tt AnchorPath} structure
  embedds a {\tt FileInfoBlock} structure that requires long-word alignment,
  the {\tt AnchorPath} structure shall be aligned to long-word boundaries as
  well. The simplest way to ensure this is to allocate it with either {\tt
    AllocMem()} or {\tt AllocVec()}, see also section~\ref{sec:bptrs}.}

Then, with the initialized {\tt AnchorPath} structure, {\tt MatchFirst()}
shall be called, returning the first match of the pattern if there is
any. The {\tt AnchorPath} structure then contains all information on the
found match.
\smallskip{}

If there is any match, and the match is a directory the caller wants to
enter recursively, the {\tt APF\_DODIR} flag of the {\tt AnchorPath}
structure may be set. Then, {\tt MatchNext()} may be called to continue the
scan, potentially entering this directory. Once the end of a recursively
entered directory has been reached, {\tt MatchNext()} sets the {\tt
  APF\_DIDDIR} flag, then reverts back to the parent directory continuing
the scan there. As {\tt APF\_DIDDIR} is never cleared by the pattern
matcher, the caller should clear it once the end of a sub-directory had been
noticed.
\smallskip{}

The above iterative procedure of {\tt MatchNext()} may continue, either
until the user or the running program requests termination, or until {\tt
  MatchNext()} returns an error. Then, finally, the scan is aborted and all
resources but the {\tt AnchorPath} structure shall be released by calling
{\tt MatchNext()}.
\medskip{}

The {\tt AnchorPath} structure is defined in {\tt dos/dosasl.h} and looks as
follows:

\mkey{AnchorPath}
\begin{verbatim}
struct AnchorPath {
        struct AChain   *ap_Base;
#define ap_First ap_Base
        struct AChain   *ap_Last;
#define ap_Current ap_Last
        LONG    ap_BreakBits;
        LONG    ap_FoundBreak;
        BYTE    ap_Flags;
        BYTE    ap_Reserved;
        WORD    ap_Strlen;
        struct  FileInfoBlock ap_Info;
        UBYTE   ap_Buf[1];
};
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt ap\_Base} and {\tt ap\_Last} are pointers to an {\tt AChain} structure
that is also defined in {\tt dos/dosasl.h}. This structure is allocated and
released by the \emph{dos.library}, transparently to the caller. The {\tt
  AChain} structure describes a directory in the potentially recursive scan
through a directory tree. {\tt ap\_Base} describes the topmost directory at
which the scan started, whereas {\tt ap\_Last} describes the directory which
is currently being scanned.
\smallskip{}

The {\tt AChain} structure is also defined in {\tt dos/dosasl.h}:

\mkey{AChain}
\begin{verbatim}
struct AChain {
	struct AChain *an_Child;
	struct AChain *an_Parent;
	BPTR	an_Lock;
	struct FileInfoBlock an_Info;
	BYTE	an_Flags;
	UBYTE	an_String[1];
};
\end{verbatim}

{\tt an\_Child} and {\tt an\_Parent} are only used internally and shall not
be interpreted by the caller.
\smallskip{}

{\tt an\_Lock} is a lock to the directory described by this {\tt AChain}
structure. In particular, {\tt ap\_Last->an\_Lock} is a \emph{lock} to the
directory that is currently being scanned, and {\tt ap\_Base->an\_Lock} a
lock to the topmost directory at which the scan started. These two locks
have been obtained and will be unlocked by the \emph{dos.library}; they may
be used by the caller provided they are not unlocked manually.
\smallskip{}

{\tt an\_Info} is only used internally and is the {\tt
  FileInfoBlock}\key{FileInfoBlock} of the directory being describes by the
{\tt AChain} structure, see section~\ref{sec:fib}.
\smallskip{}

{\tt an\_Flags} is only used internally, and {\tt an\_String} can contain
potentially the path to the directory; both shall not be modified or
interreted by the caller.
\medskip{}

{\tt ap\_BreakBits} of the {\tt AnchorPath} structure shall be initialized
to the signal mask upon which {\tt MatchNext()} aborts a directory
scan. This is typically a combination of signal masks found in
{\tt dos/dos.h}, e.g. {\tt SIGBREAKF\_CTRL\_C} to abort on {\tt Ctrl-C} in
the console.
\smallskip{}

{\tt ap\_FoundBreak} contains, if {\tt MatchNext()} aborts with
{\tt ERROR\_BREAK}, the signal mask that caused the abortion.
\smallskip{}

{\tt ap\_Flags} contains multiple flags that can be set or inspected by the
caller while scanning a directory. In particular:
\smallskip{}

{\tt APF\_DOWILD} while documented, is not used nor set at all by the
pattern matcher.
\smallskip{}

{\tt APF\_ITSWILD} is set by {\tt MatchFirst()} if the pattern includes a
wildcard and more than a single \emph{file system} object may
match. Otherwise, no directory scan is performed. The user may also set this
flag to enforce a scan. This may resolve situations in which matching an
explicit path without a wildcard is not possible because the object is
locked exclusively.
\smallskip{}

{\tt APF\_DODIR} may be set or reset by the caller of {\tt MatchNext()} to
enforce entering a directory recursively, or avoid entering a
directory. This flag is cleared by {\tt MatchNext()} when entering a
directory, and it shall only be set by the caller if a match describes a
directory.
\smallskip{}

{\tt APF\_DIDDIR} is set by {\tt MatchNext()} if the end of a recursively
entered directory has been reached, and thus the parent directory is
re-entered. As this flag is never cleared by the pattern matcher, it should
be cleared by the caller.
\smallskip{}

{\tt APF\_NOMEMERR} is an internal flag that should not be interpreted; it
is set if an error is encountered while scanning a directory. It is not
necessarily restricted to memory allocation errors.
\smallskip{}

{\tt APF\_DODOT} is, even though documented, not actually used.
\smallskip{}

{\tt APF\_DirChanged} is a flag that is set by {\tt MatchNext()} if the
scanned directory changes, either by entering a directory recursively, or by
leaving a directory. It is also cleared if the directory is the same as in
the previous call.
\medskip{}

{\tt ap\_Strlen} is the size of the buffer {\tt ap\_Buf} that contains the
full path of the matched entry. This buffer shall be allocated by the user
at the end of the {\tt AnchorPath} structure. Unlike what the name suggests,
this is not a string length, but the byte size of the buffer, including the
terminating {\tt NUL} byte of a string. If the full path of the match does
not fit into this buffer, it is truncated \emph{without} proper string
termination and the error code {\tt ERROR\_BUFFER\_OVERFLOW} is returned. If
the full path is not required, this member shall be set to~$0$.
\smallskip{}

{\tt ap\_Info} contains the {\tt FileInfoBlock}\key{FileInfoBlock} of the
matched entry, including all metadata the file system has available for
it. Note that {\tt fib\_FileFile} only contains the name of the object, not
its full path.
\smallskip{}

{\tt ap\_Buf} is filled with the full path to the matched object if {\tt
  ap\_Strlen} is non-zero. This buffer shall be allocated by the caller at
the end of the {\tt AnchorPath} structure, i.e. for a buffer of $l$ bytes,
in total {\tt sizeof(AnchorPath)+l-1} bytes are required to store the
structure and the buffer. The byte size of this additional buffer shall be
placed in {\tt ap\_Strlen}. If this buffer is not required, {\tt ap\_Strlen}
shall be set to~$0$.

\section{Matching Strings against Patterns}

While the prime purpose of the pattern matcher is to scan directories, it
can also be used to check whether an arbitrary string matches a wildcard,
for example to scan for a pattern within a text document. This requires two
steps: In the first step, the wildcard is preparsed, generating a tokenized
version of the pattern. The second step checks whether a given input string
matches the pattern. You would typically tokenize the pattern once, and then
use it to match multiple strings to the pattern.
\smallskip{}

Two versions of the tokenizer and pattern matcher exist: One pair that is
case-sensitive, and the second pair is case-insensitive. Note that AmigaDOS
file names are case-insensitive, so the {\tt MatchFirst()}\key{MatchFirst()}
and {\tt MatchNext()}\key{MatchNext()} functions internally only use the
second piar.
\smallskip{}

The buffer for the tokenized version of the pattern shall be allocated by
the caller. It requires a buffer that is at least {\tt 2 + (n << 1)} bytes
large, where $n$ is the length of the input wildcard. 

\subsection{Tokenizing a Case-Sensitive Pattern}

The {\tt ParsePattern()}\mkey{ParsePattern()} function tokenizes a pattern
for case-sensitive string matching. This tokenized version is then later on
used to test a string for a match.

\begin{verbatim}
IsWild = ParsePattern(Source, Dest, DestLength)
d0                      D1     D2      D3

LONG ParsePattern(STRPTR, STRPTR, LONG)
\end{verbatim}

This function tokenizes a wildcard pattern in {\tt Source}, generating a
tokenized version of the pattern in {\tt Dest}. The size (capacity) of the
target buffer is {\tt DestLength} bytes. This size shall be at least
{\tt 2 + (n << 1)} bytes large, where {\tt n} is the length of the input
pattern. However, as future implementations can require larger buffers, the
result code shall be checked nevertheless for error conditions. The result
code {\tt IsWild} is one of the following:
\smallskip{}

{\tt 1} is returned if the source contained wildcards.
\smallskip{}

{\tt 0} is returned if the source contains no wildcards. In this case, the
tokenized pattern may still be used to match a string against the pattern,
though a simple string comparison would also work.
\smallskip{}

{\tt -1} is returned in case of an error, either because the input pattern
is ill-formed, or because {\tt DestLength} is too short. In such a case,
{\tt IoErr()} should be used to obtain the reason of the failure.

\subsection{Tokenizing a Case-Insensitive Pattern}

The {\tt ParsePatternNoCase()}\mkey{ParsePatternNoCase()} function tokenizes
a pattern for case-insensitive string matching. This tokenized version is then
later on used to test a string for a match. This version is suitable for
matching file names, but is otherwise similar to {\tt
  ParsePattern()}\key{ParsePattern()}.

\begin{verbatim}
IsWild = ParsePatternNoCase(Source, Dest, DestLength)
d0                            D1     D2      D3

LONG ParsePatternNoCase(STRPTR, STRPTR, LONG)
\end{verbatim}

This function tokenizes a wildcard pattern in {\tt Source}, generating a
tokenized version of the pattern in {\tt Dest}. The size (capacity) of the
target buffer is {\tt DestLength} bytes. This size shall be at least
{\tt 2 + (n << 1)} bytes large, where {\tt n} is the length of the input
pattern. However, as future implementations can require larger buffers, the
result code shall be checked nevertheless for error conditions. The result
code {\tt IsWild} is one of the following:
\smallskip{}

{\tt 1} is returned if the source contained wildcards.
\smallskip{}

{\tt 0} is returned if the source contains no wildcards. In this case, the
tokenized pattern may still be used to match a string against the pattern,
though a simple case-insensitive string comparison would also work.
\smallskip{}

{\tt -1} is returned in case of an error, either because the input pattern
is ill-formed, or because {\tt DestLength} is too short. In such a case,
{\tt IoErr()} should be used to obtain the reason of the failure.

\subsection{Match a String against a Pattern}

The {\tt MatchPattern()}\mkey{MatchPattern()} function matches an input
string against a tokenized pattern, in a case sensitive way.

\begin{verbatim}
match = MatchPattern(pat, str)
D0                   D1   D2

BOOL MatchPattern(STRPTR, STRPTR)
\end{verbatim}

This function matches the string {\tt str} against the tokenized pattern
{\tt pat}, returning an indicator whether the string matches the
pattern. This function is case-sensitive. The pattern {\tt pat} shall have
been tokenized by {\tt ParsePattern()}.
\smallskip{}

The result code {\tt match} is non-zero in case the string matches, or~$0$
in case either the string did not match, or the function run out of
stack. The latter two cases can be distinguished by {\tt
  IoErr()}\key{IoErr()}. In case the string did not match, {\tt IoErr()}
returns~$0$, or a non-zero error code otherwise. A possible error code is
{\tt ERROR\_TOO\_MANY\_LEVELS} indicating that the pattern matcher run out
of stack due to too many levels of recursion.
\smallskip{}

The caller shall have at least~$1500$ bytes of stack space available to
avoid race conditions, despite the function checking for out-of-stack
conditions.

\subsection{Match a String against a Pattern ignoring Case}

The {\tt MatchPatternNoCase()}\mkey{MatchPatternNoCase()} function matches
an input string against a tokenized pattern ignoring the case.

\begin{verbatim}
match = MatchPatternNoCase(pat, str)
D0                         D1   D2

BOOL MatchPatternCase(STRPTR, STRPTR)
\end{verbatim}

This function matches the string {\tt str} against the tokenized pattern
{\tt pat}, returning an indicator whether the string matches the
pattern. This function is case-insensitive. The pattern {\tt pat} shall have
been tokenized by {\tt ParsePatternNoCase()}.
\smallskip{}

The result code {\tt match} is non-zero in case the string matches, or~$0$
in case either the string did not match, or the function run out of
stack. The latter two cases can be distinguished by
{\tt IoErr()}\key{IoErr()}. In case the string did not match, {\tt IoErr()}
returns~$0$, or a non-zero error code otherwise. A possible error
code is {\tt ERROR\_TOO\_MANY\_LEVELS} indicating that the pattern matcher
run out of stack due to too many levels of recursion.
\smallskip{}

The caller shall have at least~$1500$ bytes of stack space available to
avoid race conditions, despite the function checking for out-of-stack
conditions.

\chapter{Processes} \label{sec:process}

\emph{Processes}\mkey{Process} are extensions of exec \emph{tasks}, and as
such scheduled by exec. The most important extensions are that processes
include a message port in the form of a \emph{MsgPort} structure for
inter-process communication to \emph{handlers}, a current directory to
resolve relative paths, and the last input/output error as returned by the
{\tt IoErr()}\key{IoErr()} function.
\smallskip{}

\emph{Processes} are represented by the {\tt Process} structure documented
in {\tt dos/dosextens.h}. It reads as follows:
\begin{verbatim}
struct Process {
    struct  Task    pr_Task;
    struct  MsgPort pr_MsgPort;
    WORD    pr_Pad;
    BPTR    pr_SegList;
    LONG    pr_StackSize;
    APTR    pr_GlobVec;
    LONG    pr_TaskNum;
    BPTR    pr_StackBase;
    LONG    pr_Result2;
    BPTR    pr_CurrentDir;
    BPTR    pr_CIS;
    BPTR    pr_COS;
    APTR    pr_ConsoleTask;
    APTR    pr_FileSystemTask;
    BPTR    pr_CLI;
    APTR    pr_ReturnAddr;
    APTR    pr_PktWait;	
    APTR    pr_WindowPtr;

    /* following definitions are new with 2.0 */
    BPTR    pr_HomeDir;
    LONG    pr_Flags;
    void    (*pr_ExitCode)();
    LONG    pr_ExitData;
    UBYTE   *pr_Arguments;
    struct MinList pr_LocalVars;
    ULONG   pr_ShellPrivate;
    BPTR    pr_CES;
};  /* Process */
\end{verbatim}

The members of this structure are as follows:
\smallskip{}

{\tt pr\_Task} is the exec task structure defined in {\tt exec/tasks.h}. It
is required by the exec scheduler. The only difference between an exec
{\tt Task} and a {\tt Process} is that {\tt pr\_Task.tc\_Node.ln\_Type} is set
to {\tt NT\_PROCESS} instead to {\tt NT\_TASK}. 
\smallskip{}

{\tt pr\_MsgPort} is a message port structure as defined in {\tt
  exec/ports.h}. This port is used by many functions of the
\emph{dos.library} to communicate with \emph{handlers} and \emph{file
systems}. Details of the communication protocol are given in
section~\ref{sec:handlers}.
\smallskip{}

{\tt pr\_Pad} is unused and only included in the structure to ensure that
all following members are aligned to 32-bit boundaries.
\smallskip{}

{\tt pr\_SegList} contains an array of \emph{segments} containing AmigaDOS
functions. The first entry in this array is a 32-bit integer indicating the
number of valid elements, the remaining entries are \emph{BPTRs} to segments
of AmigaDOS and the loaded binary. Some entries may be {\tt ZERO} indicating
that the corresponding entry is currently not used. Segments are explained
in more detail in section~\ref{sec:segments}. Typically, entries $1$ and $2$
are system segments containing AmigaDOS functions, entry $3$ is used for the
loaded binary, and entry $4$ the segment of the shell. This, however, only
reflects the current usage of segments, and later versions of AmigaDOS may
populate this vector differently. The segments contained in this vector are
used by the AmigaDOS runtime binder to build the \emph{Global Vector} of
processes using BCPL linkage. As BPCL is phased out, this vector is of no
particular importance today anymore, and can be ignored for almost all
purposes. The only exception is the \emph{Shell} which shall prepare this
vector to ensure that commands written in BCPL function properly. More on
this in section~\ref{sec:shell}.

{\tt pr\_StackSize} is the size of the process stack in bytes. It is always
a multiple of 4 bytes long.
\smallskip{}

{\tt pr\_GlobVec} is another BCPL legacy. It contains the \emph{Global
Vector} of the process. For binaries using the BCPL linkages, this is a
custom-build array of global data and function entry points from {\tt
  pr\_SegList}. For C and assembler binaries, the \emph{Global Vector} is
the system shared vector; it contains \emph{dos.library} global data
required by some of its functions, such as base pointers to system
libraries. As no particular advantage can be taken from this vector
(anymore) as all functions available in it are also available as
\emph{dos.library} entry points, it should be left alone.
\smallskip{}

{\tt pr\_TaskNum} is an integer allocated by the system for processes that
execute a shell, or are binaries that have been launched by the shell. The
number here corresponds to the integer printed by the {\tt Status}
command. Note that AmigaDOS does not use task numbers consistenty,
i.e. processes that are started from the workbench or have been created by
some other means are not identified by a task number. In such a case, this
member remains~$0$.
\smallskip{}

{\tt pr\_StackBase} is a \emph{BPTR} to the address of the lower end of the
stack, i.e. the end of the C or assembler stack. As the BCPL stack grows in
opposide direction, it is the start of the BCPL stack. While it is
initialized, it is not used by the \emph{dos.library} at all.
\smallskip{}

{\tt pr\_Result2} is the secondary result code set by many functions of the
\emph{dos.library}. The value stored here is delivered by {\tt IoErr()}\key{IoErr()}.
\smallskip{}

{\tt pr\_CurrentDir} is the \emph{lock} representing the current directory
of the process. All relative paths are resolved from this \emph{lock},
i.e. they are relative to {\tt pr\_CurrentDir}. If this member is {\tt ZERO},
the currrent directory is the root directory of the file system stored in
{\tt pr\_FileSystemTask}. As the latter is (unless altered) the file system
of the boot volume, this is usually identical to the directory identified by
the {\tt SYS} assign.
\smallskip{}

{\tt pr\_CIS} is \emph{file handle} of the standard input stream of the
process. It is also returned by {\tt Input()}\key{Input()}. It can be {\tt
  ZERO} in case the process does not have a standard input stream. This is
\emph{not} equivalenqt to a {\tt NIL:} input handle --- in fact, any attempt
to read from a non-existing input stream will crash. Processes started from
the workbench do not have an input stream, unless one is installed here with
{\tt SelectInput()}\key{SelectInput()}.
\smallskip{}

{\tt pr\_COS} is the \emph{file handle} of the standard output stream of the
process. It is also returned by the {\tt Output()}\key{Output()} function of
the \emph{dos.library}. It can be {\tt ZERO} in case the process does not
have a standard output stream, which is not equivalent to a {\tt NIL:} file
handle. Any attempt to output to {\tt ZERO} will crash the system. Processes
started from the workbench do not have an output stream, unless one is
installed with {\tt SelectOutput()}\key{SelectOutput()}.
\smallskip{}

{\tt pr\_ConsoleTask} is the \emph{MsgPort} of the console within which this
process is run, if such a console exists. This \emph{handler} is contacted
when opening ``{\tt *}'' or a path relative to {\tt CONSOLE:}. Processes
started from the workbench do not have a console, unless one is installed
with {\tt SetConsoleTask()}\key{SetConsoleTask()}.
\smallskip{}

{\tt pr\_FilesSystemTask} is the \emph{MsgPort} of the file system that is
contacted in case a relative path is to be resolved relative to the {\tt
  ZERO} lock. This member is initialized to the \emph{MsgPort} of the file
system the system was booted from, but can be changed by {\tt
  SetFileSysTask()}\key{SetFileSysTask()}. This member is also returned by
{\tt GetFileSysTask()}\key{SetFileSysTask()}.
\smallskip{}

{\tt pr\_CLI} is a \emph{BPTR} to the {\tt CommandLineInterface}
\key{CommandLineInterface} structure containing information on the Shell
this process is running in. If this process is not part of a Shell, this
member is {\tt ZERO}. This is for example the case for programs started from
the workbench, or \emph{handler} or \emph{file system}.
\smallskip{}

{\tt pr\_ReturnAddr} is another \emph{BCPL} legacy and should not be used by
new implementations. It points to the BCPL stack frame of the process or the
command overloading the process, and used there to restore the previous
stack frame for the {\tt Exit()}\key{Exit()} function. This is typically the
process cleanup code for processes initialized by {\tt
  CreateProc()}\key{CreateProc()} or {\tt
  CreateNewProc()}\key{CreateNewProc()}, or the shell command shutdown code
placed there by {\tt RunCommand()}. This cleanup process does not, however,
release any other resources obtained by user code. BCPL code or custom
startup code could deposit here pointer to a BCPL stack frame for a custom
shutdown mechanism.
\smallskip{}

The BCPL stack frame is described by the following (undocumented) structure:
\mkey{BCPL stack frame}
\begin{verbatim}
struct BCPLStackFrame {
       ULONG bpsf_StackSize;
       APTR  bpsf_PreviousStack;
};
\end{verbatim}
where {\tt bpsf\_StackSize} is the stack size of the current (active) stack,
and {\tt bpsf\_PreviousStack} the stack of the caller; to restore the
previous stack, this value is placed in the CPU register {\tt A7}.
\medskip{}

{\tt pr\_PktWait} is a function that is called when waiting for
inter-process communication, in particular when waiting for a returning
packet set out to a handler. If this is {\tt NULL}, the system default
function is used.  The signature of this function is
\begin{verbatim}
msg = (*pr_PktWait)(void)
D0

struct MsgPort *(*pr_PktWait)(void)
\end{verbatim}

that is, no particular arguments are delivered, the process must be obtained
from {\tt exec}, and the message received shall be delivered back into
register {\tt D0}. The returned pointer shall not be {\tt NULL}, rather,
this function shall block until a message has been received. For details,
see the {\tt DoPkt()}\key{DoPkt()} function and section~\ref{sec:handlers}.
\smallskip{}

{\tt pr\_WindowPtr} is, unlike what the name suggests, a pointer to an
\emph{intuition} {\tt Screen} structure, see {\tt intuition/screens.h}, on
which error requesters will appear. If this is {\tt NULL}, error requesters
appear on the workbench screen, and if this is set to {\tt (APTR)(-1L)},
error requesters will be suppressed at all, and the implied reponse to them
is to cancel the operation. This error requester is specified in more detail
with the {\tt ErrorReport()}\key{ErrorReport()} function.
\smallskip{}

{\tt pr\_HomeDir} is the \emph{lock} to the directory containing the binary
that is currently executed as this process, if such a directory exists. It
is {\tt ZERO} if the binary is resident. This \emph{lock} is filled in by
the Shell or the Workbench when loading and starting a process. It is used
to resolve paths relative to the {\tt PROGDIR} pseudo-assign, see
section~\ref{table:specialassigns}. If this lock is {\tt ZERO}, any attempt
to resolve a path within {\tt PROGDIR:} will create a request to inserted a
volume {\tt PROGDIR:}, which is probably not a very useful reaction of
AmigaDOS.
\smallskip{}

{\tt pr\_Flags} are system-use only flags that shall not be used or
interpreted. They are used by the system process shutdown code to identify
which resources need to be released, but future systems may find additional
uses for this member.
\smallskip{}

{\tt pr\_ExitCode()} is a pointer to a function that is called by AmigaDOS
as part of the process shutdown code, and as such quite more useful that
{\tt pr\_ReturnAddr}. Thie function prototype is as follows:

\begin{verbatim}
returncode = ExitFunc(rc,exitdata)
D0                    D0 D1

LONG ExitFunc(LONG,LONG)
\end{verbatim}

The value of {\tt rc} is the return code process, i.e. the value left in
register {\tt D0} when the code drops off the final {\tt RTS}, and {\tt
  exitdata} is taken from {\tt pr\_ExitData}. The {\tt returncode} is a
modified version of the process return code that is, however, ignored.
\smallskip{}

{\tt pr\_ExitData} is used as argument for the {\tt pr\_ExitCode()}
function, see above.
\smallskip{}

{\tt pr\_Arguments} is a pointer to the command line arguments of the
process if it corresponds to a command started from the Shell. This is a
{\tt NUL} terminated string. This argument string can also be found in
register {\tt A0} for programs started from the Shell, or in the buffer of
{\tt pr\_CIS}. The {\tt ReadArgs()}\key{ReadArgs()} function takes it from
the latter source, and not from {\tt pr\_Arguments}. Otherwise, this member
remains {\tt NULL}.
\smallskip{}

{\tt pr\_LocalVars} is a {\tt MinList} structure, as defined in {\tt
  exec/lists.h}, that contains local variables specific to the shell within
which the process is executed, if any. The structure of such variables is
defined in {\tt dos/var.h}. This structure is specified in
section~\ref{sec:shell}.
\smallskip{}

{\tt pr\_ShellPrivate} is reserved for the Shell and its value shall not be
used, modified or interpreted. It is currently unused, but can be used by
future releases.
\smallskip{}

{\tt pr\_CES} is the \emph{file handle} to be used for error output. This
stream gues usually to the console the process runs in, if such a console
exists. This handle can be changed by {\tt SelectError()}\key{SelectError()}.
If {\tt pr\_CES} is {\tt NULL}, processes should fall back to {\tt pr\_COS}
for printing errors. Preferably, processes should use the
{ErrorOutput()}\key{ErrorOutput()} function to obtain an error stream,
though.

\section{Creating and Terminating Processes}

AmigaDOS provides several functions to create functions: {\tt
  CreateNewProc()}\key{CreateNewProc()} is the revised and most flexible
function for launching a process, taking many parameters in the form of a
tag list. The legacy function{\tt CreateProc()}\key{CreateProc()} supports
less options, but available under all Os versions. Shells as created by the
{\tt System()}\key{System()} function implicitly also create processes, but
are not discussed here, but in section~\ref{sec:shell}. Therefore, {\tt
  System()} shares a couple of options with {\tt CreateNewProc()}.
\smallskip{}

There is surprisingly not a single function to delete processes. Processes
die whenever their execution drops off at the end of the {\tt main()}
function, or whenever execution reaches the final {\tt RTS} instruction of
the main program function. The {\tt Exit()}\key{Exit()} function also
terminates a process, but shall be called from within the process, and is
typically not suitable as it does not release resouces accquired by the
program itself, but only those allocated by the system itself.

\subsection{Creating a New Process from a TagList}

The {\tt CreateNewProc()}\mkey{CreateNewProc()} function takes a {\tt
  TagItem} array as defined in {\tt utility/tagitem.h} and launches a new
process from this list. The tags this function takes are defined in {\tt
  dos/dostags.h}.

\begin{verbatim}
process = CreateNewProc(tags)
D0                       D1

struct Process *CreateNewProc(struct TagItem *)

process = CreateNewProcTagList(tags)
D0                              D1

struct Process *CreateNewProcTagList(struct TagItem *)

process = CreateNewProcTags(Tag1, ...)

struct Process *CreateNewProcTags(ULONG, ...)
\end{verbatim}

The above functions are all equivalent, just the calling conventions are
different. For {\tt CreateNewProcTags()}, the {\tt TagList} is created by
the compiler on the stack and a pointer is then implicitly passed into the
function. The following tags are recognized by the function:
\smallskip{}

{\tt NP\_Seglist} takes a \emph{BPTR} to a segment list as returned by {\tt
  LoadSeg()} and launches the process at the first byte of the first segment
of the list.
\smallskip{}

{\tt NP\_FreeSeglist} is a boolean indicator that defines whether the
segment provided to {\tt NP\_Seglist} is released when the process
terminates. Unlike what the official documentation claims, the default value
of this tag is {\tt DOSFALSE}, i.e. the segment is \emph{not} released.
\smallskip{}

{\tt NP\_Entry} is mutually exclusive to {\tt NP\_Seglist} and defines an
absolute address (and not a segment) as entry point of the process to be
created. If this tag is provided, then {\tt NP\_FreeSeglist} shall
\emph{not} be set a non-zero value. Either {\tt NP\_Entry} or {\tt
  NP\_Seglist} shall be included.
\smallskip{}
     
{\tt NP\_Input} sets the input file handle, i.e. {\tt pr\_CIS} of the
process to be created. This tag takes a \emph{BPTR} to a \emph{file
handle}. The default is \emph{not} to set the input file handle, e.g. to
leave it {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseInput} selects whether the input file handle, if provided,
will be closed when the process terminates. If non-zero, the input file handle
will be closed, otherwise it remains opened. The default is to close the
input file handle.
\smallskip{}

{\tt NP\_Output} sets the output file handle, i.e. {\tt pr\_COS} of the
process to be created. This tag takes a \emph{BPTR} to a \emph{file
handle}. The default is to leave the output at {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseOutput} selects whether the output file handle, if
provided, will be closed when the process terminates. If non-zero, the
output file handle will be closed, otherwise it remains open. The default is
to close the output file handle.
\smallskip{}

{\tt NP\_Error} sets the error file handle, i.e. {\tt pr\_CES} of the
process to be created. This tag also takes a \emph{BPTR} to a \emph{file
handle}. The default is to leave the error output handle at {\tt ZERO}.
\smallskip{}

{\tt NP\_CloseError} selects whether the rror file handle, if provided, will
be closed when the process terminates. If non-zero, the error file handle
will be closed, otherwise it remains open. The default is \emph{not} to
close the error file handle. This (different) default is to ensure backwards
compatibility.
\smallskip{}

{\tt NP\_CurrentDir} sets the current directory of the process to be
created. The argument is a \emph{Lock}. The default is to duplicate the
current directory of the caller with {\tt DupLock()}\key{DupLock()} if the
caller is a process, or leave the current directory at {\tt ZERO}.
The current directory of the process, i.e. {\tt pr\_CurrentDir}, is released
when the process terminates, unless {\tt NP\_CurrentDir} is set to {\tt ZERO}. 
\smallskip{}

{\tt NP\_StackSize} sets the stack size of the process to be created in
bytes. The default is a stack size of $4000$ bytes.
\smallskip{}

{\tt NP\_Name} is a pointer to a {\tt NUL} terminated string to which the
task name of the process to be created is set. This string is copied before
the process is launched, and the copy is released automatically when the
process terminates. The default process name is ``{\tt New Process}''.
\smallskip{}

{\tt NP\_Priority} sets the priority of the process to be created. The tag
value shall be an integer in the range~$-128$ to~$127$, though useful values
are in the range of~$0$ to~$20$. The default is~$0$.
\smallskip{}

{\tt NP\_ConsoleTask} specifies a pointer to a \emph{MsgPort} to the handler
that is responsible for the console of the process to be created. That is,
if the created process opens ``{\tt *}'' or a path relative to {\tt
  CONSOLE:}, it will use the specified handler. The default is to use the
console handler if the caller is a process, or {\tt NULL} if the caller is 
only a task.
\smallskip{}

While not explicitly available as a tag, the default file system of the created
process, i.e. {\tt pr\_FileSystemTask}, is set to the default file system of
the calling process if the caller is a process, or otherwise use the default
file system from the \emph{dos.library}. This file system is contacted to
resolve paths relative to the {\tt ZERO} lock.
\smallskip{}

{\tt NP\_WindowPtr} specifies a pointer to a {\tt Screen} on which error
requesters will be displayed, $0$ to display requesters on the workbench, or
$-1$ to suppress error requesters. It will be installed in the {\tt
  pr\_WindowPtr} of the process to be created. The default is to copy the
pointer from the calling process if the window pointer of the parent is $0$
or $-1$. The tag does not copy any other value of {\tt pr\_WindowPtr} from
the parent. To set the {\tt pr\_WindowPtr} of the created process to the
value of the calling process, the tag must be explicitly provided. If called
from a task and not a process, the default is {\tt NULL}. The reason why
{\tt pr\_WindowPtr} is not explicitly copied is that the caller shall ensure
that the screen is not closed while any pointers are still pointing to its
structure.
\smallskip{}

{\tt NP\_HomeDir} sets the {\tt pr\_HomeDir} \emph{lock} which is used to
resolve paths relative to the {\tt PROGDIR:} pseudo-assign. The default is
to copy {\tt pr\_HomeDir} of the calling process, or {\tt ZERO} in case the
caller is a task. This \emph{lock} is released when the process terminates,
i.e. the \emph{lock} provided as argument here remains available to the
caller, and shall be released by the caller in one way or another.
\smallskip{}

{\tt NP\_CopyVars} determines if the local shell variables in
{\tt pr\_LocalVars} of the calling process are copied into the variables of the
process to be created. If set to non-zero, a copy of the variables of the
calling process are made, otherwise the new process does not receive any
shell variables by itself. The latter also happens if the caller is a task
and not a process. The variables are automatically released when the new
process terminates.
\smallskip{}

{\tt NP\_Cli} determines whether the new process will receive a new shell
environment in the form of a {\tt CommandLineInterface} structure. If
non-zero, a new CLI structure will be created and a \emph{BPTR} to this
structure will be filled into the {\tt pr\_CLI} member of the process to be
created. The new shell environment will be a copy of the shell environment
of the caller if one is present, or a shell environment initialized with all
defaults. This means that the prompt, the path, and the command name will be
copied over. If~$0$, no such environment will be created. The latter is also the
default.
\smallskip{}

{\tt NP\_Path} provides a chained list of \emph{locks} within which commands
are searched. This is the same list the {\tt PATH} command adjusts, see
section~\ref{sec:shell} for details on this structure. This tag only applies
if {\tt NP\_Cli} is non-zero to create a shell environment. This chained
list is \emph{not} copied, and will be released when the created process
terminates; hence, the locks provided here are \emph{no longer} available to
the caller if {\tt CreateNewProc()} succeeds. If {\tt CreateNewProc()}
fails, the entire lock list remains a property of the caller and thus needs
to be potentially released there. The default, if this tag is not provided, is
to copy the paths of the caller if the calling process has a non-zero
{\tt pr\_CLI} structure.
\smallskip{}

{\tt NP\_CommandName} provides the name of the command being executed within
the shell environment if {\tt NP\_Cli} indicates that one is to be
created. The default is to copy the command name of the shell environment of
the calling process if one exists, or to leave the command name empty if
none is provided. The command name is copied into the shell environment of
the process being created and thus remains available to the caller. More on
the shell environment is found in section~\ref{sec:shell}.
\smallskip{}

{\tt NP\_Arguments} provides command line arguments for the process to be
created. This is a {\tt NUL} terminated string that is copied into the
process to be created, and will also be released there. If provided, the
arguments are copied in {\tt pr\_Arguments} of the process to be created,
and will also be loaded into registers {\tt A0} and its length into
{\tt D0}. If {\tt NP\_Arguments} are non-zero, a non-{\tt ZERO} {\tt
  NP\_Input} file handle shall also provided. This is because the arguments
are also copied into the buffer associated to the input \emph{file handle}
to make them available to {\tt ReadArgs()}\key{ReadArgs()}, or any other
function that performs buffered read from {\tt pr\_CIS}, see
section~\ref{sec:bufferedio} for details.
\smallskip{}

{\tt NP\_ExitCode} determines a pointer to function that is called when the
created process terminates. This pointer is filled into {\tt
  pr\_ExitCode}. See section~\ref{sec:process} for the description and the
signature of this function.
\smallskip{}

{\tt NP\_ExitData} provides an argument that will be passed into the {\tt
  NP\_ExitCode} function in register {\tt D1} when the process terminates.
\smallskip{}

While the official documentation also mentiones the tags {\tt
  NP\_NotifyOnDeath} and {\tt NP\_Synchronous}, these tags are currently
ignored and do not perform any function.
\medskip{}

The {\tt CreateNewProc()} function returns on success a pointer to the
{\tt Process} structure just created. At this stage, the process has already
been launched and, depending on its priority, may already be running. On
failure, the function returns {\tt NULL}. Unfortunately, it does not set
{\tt IoErr()} consistently on failure.

\subsection{Create a Process (Legacy)}

The {\tt CreateProc()}\mkey{CreateProc()} function creates a process from a
segment list, a name, a priority and a stack size. It is a legacy call that
is not as flexible as {\tt CreateNewProc()}\key{CreateNewProc()}, and only
exists for backwards compatibility reasons.

\begin{verbatim}
process = CreateProc( name, pri, seglist, stackSize )
D0                    D1    D2   D3       D4

struct MsgPort *CreateProc(STRPTR, LONG, BPTR, LONG)
\end{verbatim}

This function creates a process of the name {\tt name} running at priority
{\tt pri}. The process starts at the first byte of the first segment of the
segment list passed in as {\tt seglist}, and a stack size of {\tt stackSize}
bytes will be allocated for the process.
\smallskip{}

The process is initialized as follows: {\tt pr\_ConsoleTask} and
{\tt pr\_WindowPtr} are copied from the calling process, or are set
to {\tt NULL} respective~$0$ if called from the task. The member
{\tt pr\_FileSysTask} is also copied from the calling process, or
is initialized from the default file system from the
\emph{dos.library} if called from a task.
\smallskip{}

Input, output and error file handles are set to {\tt ZERO}, and no shell
environment is created either. The current directory and home directory are
also left at {\tt ZERO}. No arguments are provided to the called function,
and no shell variables are copied.
\smallskip{}

If the call succeeds, the returned value {\tt process} is a pointer to the
\emph{MsgPort} of the created process. It is \emph{not} a pointer to a
process itself.
\smallskip{}

On failure, the function returns {\tt NULL}. Unfortunately, it does not set
{\tt IoErr()} consistently in case of failure, thus the cause of the problem
cannot be easily identified.

\subsection{Terminating a Process}

The {\tt Exit()}\mkey{Exit()} function terminates the calling process or the
calling command line executable. In the latter case, control is returned to
the calling shell, in the former case, the process is removed from the exec
scheduler.
\smallskip{}

However, tis function does not release any resources except those implicitly
allocated when creating the process through {\tt
  CreateNewProc()}\key{CreateNewProc()}, {\tt
  CreateProc()}\key{CreateProc()} or {\tt RunCommand()}\key{RunCommand()}
and the calling shell. As it misses to release resources allocated by you or
the compiler startup code, this function \emph{should not be used} and
rather a compiler or language specific shutdown function should be
preferred. The C standard library provides {\tt exit()} which releases
resources allocated through this library.

\begin{verbatim}
Exit( returnCode )
      D1

void Exit(LONG)
\end{verbatim}

This call either terminates the calling process, in which case the argument
is ignored, or returns to the calling shell, then delivering {\tt
  returnCode} as result code. It uses the BCPL stack frame pointed to by
{\tt pr\_ReturnAddr}, removes this stack frame, initializes the new stack
from the stack frame there and then returns to whatever created the
stack frame. This is typically either the process shutdown code of AmigaDOS, or
the shell command shutdown code installed by {\tt RunCommand()}. In the
former code, {\tt pr\_ExitCode()} may be used to implement additional
cleanup activities.
\smallskip{}

This function is a BCPL legacy function that is also part of the
\emph{Global Vector}; BCPL programs would typically overload its entry in
this vector to implement a custom shutdown mechanism.

\section{Process Properties Accessor Functions}

The most important members of the process structure described in
section~\ref{sec:process} are accessible through getter and setter
functions. They implicitly relate to the calling process, and are the
preferred way of getting access to the {\tt Process} structure. The
functions listed in this section do not touch {\tt IoErr()} except
explicitly stated.

\subsection{Retrieve the Process Input File Handle}

The {\tt Input()}\mkey{Input()} function returns the input file handle of
the calling proces if one is installed. If no input file handle is provided,
the function returns {\tt ZERO}.

\begin{verbatim}
file = Input()
D0

BPTR Input(void)
\end{verbatim}

This function returns a \emph{BPTR} to the input \emph{file handle} of the
calling process, or {\tt ZERO} if none is defined. This is approximately
identical to {\tt stdin} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectInput()}\key{SelectInput()}.

\subsection{Replace the Input File Handle}

The {\tt SelectInput()}\mkey{SelectInput()} function replaces the input
\emph{file handle} of the calling process with its argument and returns the
previously used input handle.

\begin{verbatim}
old_fh = SelectInput(fh)
D0                   D1

BPTR SelectInput(BPTR)
\end{verbatim}

This call replaces the input \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used input
\emph{file handle}.

\subsection{Retrieve the Ouput File Handle}

The {\tt Output()}\mkey{Output()} function returns the output file handle of
the calling proces if one is installed. If no output file handle is provided,
the function returns {\tt ZERO}.

\begin{verbatim}
file = Output()
D0

BPTR Output(void)
\end{verbatim}

This function returns a \emph{BPTR} to the output \emph{file handle} of the
calling process, or {\tt ZERO} if none is defined. This is approximately
identical to {\tt stdout} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectOutput()}\key{SelectOutput()}.

\subsection{Replace the Output File Handle}

The {\tt SelectOutput()}\mkey{SelectOutput()} function replaces the output
\emph{file handle} of the calling process with its argument and returns the
previously used output handle.

\begin{verbatim}
old_fh = SelectOutput(fh)
D0                    D1

BPTR SelectOutput(BPTR)
\end{verbatim}

This call replaces the output \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used output
\emph{file handle}.

\subsection{Retrieve the Error File Handle}

The {\tt ErrorOutput()}\mkey{ErrorOutput()} function returns the file handle
through which diagnostic or error outputs should be printed. It uses either
{\tt pr\_CES} if this handle is non-{\tt ZERO}, or {\tt pr\_COS} if the
former is {\tt ZERO}. If neither an error ouptut nor a regular output is
provided, this function returns {\tt ZERO}.

\begin{verbatim}
file = ErrorOutput()
D0

BPTR ErrorOutput(void)
\end{verbatim}

This function returns a \emph{BPTR} to the error \emph{file handle} of the
calling process, or falls back to the \emph{BPTR} of the output \emph{file
handle} if the former is not available. This is the file handle through
which diagnostic output should be printed and is therefore approximately
identical to {\tt stderr} of ANSI-C. Depending on process creation, this file
handle can be closed by the process shutdown code or the calling shell and
thus should in general not be closed explicitly. It can be changed through
{\tt SelectError()}\key{SelectError()}.

\subsection{Replace the Error File Handle}

The {\tt SelectError()}\mkey{SelectError()} function replaces the error
\emph{file handle} of the calling process with its argument and returns the
previously used error handle.

\begin{verbatim}
old_fh = SelectError(fh)
D0                   D1

BPTR SelectError(BPTR)
\end{verbatim}

This call replaces the error \emph{file handle} of the calling process with
the file handle given by {\tt fh} and returns the previously used error
\emph{file handle}.

\subsection{Retrieve the Current Directory}

The {\tt GetCurrentDir()}\mkey{GetCurrentDir()} function retruns the current
directory of the directory, indicated by a \emph{lock} on this object. This
\emph{lock}, and the \emph{file system} that created the lock are used to
resolve relative paths, see also section~\ref{sec:paths}.

\begin{verbatim}
lock = GetCurrentDir(void)
D0

BPTR GetCurrentDir()
\end{verbatim}

This function returns the \emph{lock} to the current directory, unlike the
{\tt CurrentDir()}\key{CurrentDir()} function which also changes it.

\subsection{Replace the Current Directory} \label{sec:currentdir}

The {\tt CurrentDir()}\mkey{CurrentDir()} selects and retrieves the current
directory of the calling process. The directory is indicated by a
\emph{lock} to this object. This \emph{lock}, and the \emph{file system}
that created the lock are used to resolve relative paths, see also
section~\ref{sec:paths}.

\begin{verbatim}
oldLock = CurrentDir( lock )
D0                    D1

BPTR CurrentDir(BPTR)
\end{verbatim}
This function sets the current directory to {\tt lock} and returns in
{\tt oldLock} the previously installed current directory. The passed in
{\tt lock} then becomes part of the process and shall not be released by
{\tt UnLock()}\key{UnLock()} until another \emph{lock} is installed as current
directory.
\smallskip{}

If the current directory is {\tt ZERO}, paths are relative to the root
directory of the \emph{file system} set in the {\tt pr\_FileSysTask} member
of the calling process. It may be changed by
{\tt SetFileSysTask()}\key{SetFileSysTask()} described in
section~\ref{sec:setfilesystask}. AmigaDOS installs there the \emph{file
system} of the boot volume, unless a user installs a different
default \emph{file system}.

\subsection{Return the Latest Error Code} \label{sec:ioerr}

The {\tt IoErr()}\mkey{IoErr()} function returns the secondary result code
of the most recent AmigaDOS operation. This code is, in case of failure,
typically an error code indicating the nature of the failure.

\begin{verbatim}
error = IoErr()
D0

LONG IoErr(void)
\end{verbatim}
This function returns the secondary result code of the last call to the
\emph{dos.library} that provides such result. Unfortunately, not all
functions set {\tt IoErr()} consistently; all unbuffered operations in
section~\ref{sec:unbuffered} provide an error code in case of failure, or
deliver~$0$ as secondary result in case of success. The buffered functions
in section~\ref{sec:bufferedio} generally only set a secondary result code
in case an I/O operation is required, but do not touch {\tt IoErr()} if the
call can be satisfied from the caller. Whether a function of the
\emph{dos.library} touches {\tt IoErr()} is stated in the description of the
corresponding function --- unfortuantely, the \emph{dos.library} does not
handle {\tt IoErr()} consistently.
\smallskip{}

Some functions provide a secondary result code different from an error code,
and thus make such additional return value available through
{\tt IoErr()}. Such additional return values are also explicitly mentioned in
the description of the corresponding function. A particular example is
{\tt DeviceProc()}\key{DeviceProc()}, which returns the (first) lock of a
regular assign in {\tt IoErr()}, but additional functions exist.
\medskip{}

Most error codes are defined in {\tt dos/dos.h}, with some additional error
codes only used by the pattern matcher (see section~\ref{sec:patternmatch})
in {\tt dos/dosasl.h}. Generally, \emph{handlers} and \emph{file systems}
can select error codes as they seem fit, the list below provides a general
indication how the codes are used by the \emph{dos.library} itself, or what
their suggested usage is:
\smallskip{}

{\tt ERROR\_NO\_FREE\_STORE}: This error code is set if the system run out
of memory. Actually, this error code is not set by the \emph{dos.library},
but rather by the \emph{exec.library} memory allocation functions.
\smallskip{}

{\tt ERROR\_TASK\_TABLE\_FULL}: This error code is no longer in
use. Previous releases of AmigaDOS created it if more than~$10$ shell
processes were about to be created. As this limitation was removed, the
error code remains currently unused.
\smallskip{}

{\tt ERROR\_BAD\_TEMPLATE}: This error code indicates that the command line
template for {\tt ReadArgs()}\key{ReadArgs()} is syntactical incorrect. It
is also set by the pattern matcher in case the pattern is syntactically
incorrect.
\smallskip{}

{\tt ERROR\_BAD\_NUMBER}: This error code indicates that a string could not
be converted to a number.
\smallskip{}

{\tt ERROR\_REQUIRED\_ARG\_MISSING}: This error code is set by
{\tt ReadArgs()}\key{ReadArgs()} if a non-optional argument is not
provided.
\smallskip{}

{\tt ERROR\_KEY\_NEEDS\_ARG}: This error code is also used by the argument
parser {\tt ReadArgs()}\key{ReadArgs()} if an argument key is provided on
the command line, but a corresponding argument value is missing.
\smallskip{}

{\tt ERROR\_TOO\_MANY\_ARGS}: This error code can also be set by
{\tt ReadArgs()}\key{ReadArgs()}; it indicates that more arguments are
provided than indicated in the template.
\smallskip{}

{\tt ERROR\_UNMATCHED\_QUOTES}: This error code indicates that a closing
quote is missing for at least one opening quote. It is also set by the
argument parser and {\tt ReadItem()}\key{ReadItem()}.
\smallskip{}

{\tt ERROR\_LINE\_TOO\_LONG}: This error code is a general indicator that a
user provided buffer is too small to buffer a string. It is for example used
again by the argument parser and the path manipulation functions in
section~\ref{sec:workpaths}.
\smallskip{}

{\tt ERROR\_FILE\_NOT\_OBJECT}: This error code is generated by the \emph{Shell}
if an attempt is made to execute a file that is neither a script, nor an
executable nor a file that can be opened by a viewer.
\smallskip{}

{\tt ERROR\_INVALID\_RESIDENT\_LIBRARY}: While this error code is not in use
by the \emph{dos.library}, several \emph{handlers} and other Os components
use it to indicate that a required library or device is not available.
\smallskip{}

{\tt ERROR\_NO\_DEFAULT\_DIR}: This is error code is also not in use. Its
intended purpose is unclear.
\smallskip{}

{\tt ERROR\_OBJECT\_IN\_USE}: This error code is used by multiple Os
components to indicate that a particular operation cannot be performed
because the object to be modified is in use. AmigaDOS uses it, for example,
to indicate that a \emph{lock} was obtained on an object that is supposed to
be modified or deleted, and thus cannot be modified or removed.
\smallskip{}

{\tt ERROR\_OBJECT\_EXISTS}: This error code is a generic error indicator
that an operation could not be performed because another object already
exists in place, and is used as such by multiple Os components. AmigaDOS
\emph{file systems} use it, for example, when attempting to create a
directory, but a file or a directory of the requested name is already
present. 
\smallskip{}

{\tt ERROR\_DIR\_NOT\_FOUND}: This error code indicates that the target
directory is not found. Of the AmigaDOS ROM components, only the shell uses
it on an attempt to change the working directory to a non-working target
directory.
\smallskip{}

{\tt ERROR\_OBJECT\_NOT\_FOUND}: This is a generic error code that indicates
that the object on which a particular operation is to be performed does not
exist. It is for example generated on an attempt to open a non-existing file
or to lock a file or directory that could not be found.
\smallskip{}

{\tt ERROR\_BAD\_STREAM\_NAME}: This error code is currently not in use by
AmigaDOS ROM components. Its purpose is unclear.
\smallskip{}

{\tt ERROR\_OBJECT\_TOO\_LARGE}: This error could be used to indicate that
an object is beyond the size a \emph{handler} or \emph{file system} is able
to handle. Note that a full disk (or full storage medium) is indicated by
{\tt ERROR\_DISK\_FULL}, and not this error. However, currently no AmigaDOS
component uses this error, even though the FFS should probably return it on
an attempt to create or access files larger than~2GB.
\smallskip{}

{\tt ERROR\_ACTION\_NOT\_KNOWN}: This is a generic error code that is
returned by many \emph{handlers} or \emph{file systems} when an action (in
the form of a \emph{packet}) is requested the handler does not support or
understand. For example, this error is created when attempting to create a
directory on a console handler.
\smallskip{}

{\tt ERROR\_INVALID\_COMPONENT\_NAME}: This is an error that is raised by
file systems when providing an invalid path, or a path that contains
components that are syntactically incorrect. For example, the colon (``{\tt
  :}'') shall only appear one in a path as separator between the device name
and the path within the device. A colon within a component is therefore a
syntactical error. Also, all Amiga ROM file systems do not accept code
points below {\tt 0x20}, i.e. ASCII control characters.
\smallskip{}

{\tt ERROR\_INVALID\_LOCK}: This error is raised if a value is passed in as
a \emph{lock} that is, in fact, not a valid lock of the target \emph{file
system}. For example, an attempt to use a \emph{file handle} as a lock will
result in such an error condition. Note, however, that \emph{file systems}
can, but do not need to check locks for validity. Passing incorrect objects
to \emph{file systems} can raise multiple error conditions of which this
error code is probably the most harmless.
\smallskip{}

{\tt ERROR\_OBJECT\_WRONG\_TYPE}: This error code indicates that a
particular operation is not applicable to a target object, even though the
target object is valid and existing. For example, an attempt to open an
existing directory for reading as a file will raise this error.
\smallskip{}

{\tt ERROR\_DISK\_NOT\_VALIDATED}: This error indicates that the inserted
medium is currently not validated, i.e. not checked for consistency. Such a
consistency check (or validation) may be currently ongoing. This error is
for example generated  if a write operation is attempted on an FFS volume
whose validation is still ongoing. In such a case, retrying the operation
later may solve the problem already.
\smallskip{}

{\tt ERROR\_DISK\_WRITE\_PROTECTED}: This indicates that an attempt was made
to write to a medium, e.g. a disk, that is write-protected, or that cannot
be written to, such as an attempt to write to a CD-ROM.
\smallskip{}

{\tt ERROR\_RENAME\_ACROSS\_DEVICES}: Generated if an attempt is made to
move an object to a target directory that is located on a different medium
or different \emph{file system} than the source directory. This cannot
succeed, instead the object (and its subobjects) need to be copied manually.
\smallskip{}

{\tt ERROR\_DIRECTORY\_NOT\_EMPTY}: Indicates that an attempt was made to
delete a directory that is not empty. First, all the files within a
directory must be deleted before the directory itself may be deleted.
\smallskip{}

{\tt ERROR\_TOO\_MANY\_LEVELS}: This error code is generated if too many
softlinks refer iteratively to other softlinks. In order to avoid an endless
indirection of softlinks refering to each other, the \emph{dos.library}
aborts following softlinks after 15 passes; application programs attempting
to resolve softlinks themselves through {\tt ReadLink()}\key{ReadLink()}
should implement a similar mechanism, see also section~\ref{sec:readlink}.
\smallskip{}

{\tt ERROR\_DEVICE\_NOT\_MOUNTED}: This error indicates that an access was
attempted to either a \emph{handler}, \emph{file system} or \emph{assign}
that is not known to the system, or to a volume that is currently not
inserted in any known drive.
\smallskip{}

{\tt ERROR\_SEEK\_ERROR}: This error is generated by an attempt to {\tt
  Seek()} to a file position that is either negative, or behind the end of
the file. It is also signalled if the mode of {\tt Seek()}\key{Seek()} or
{\tt SetFileSize()}\key{SetFileSize()} is none of the modes indicated in
table~\ref{table:seekmode}. The FFS also sets this mode if it cannot read
one of its administration blocks.
\smallskip{}

{\tt ERROR\_COMMENT\_TOO\_BIG}: This error is raised if the size of the
comment is too large to be stored in in the metadata of the \emph{file
system}. Note that while \emph{file systems} shall validate the size of the
comment, it shall silently truncate file names to the maximal size possible.
\smallskip{}

{\tt ERROR\_DISK\_FULL}: Generated by \emph{file systems} when an attempt is
made to write more data to a medium than it is possible to hold, i.e. when
the target medium is full.
\smallskip{}

{\tt ERROR\_DELETE\_PROTECTED}: This error is generated by \emph{file
systems} if an attempt is made to delete a file that is delete protected,
i.e. whose {\tt FIBB\_DELETE} protection bit is set, see
table~\ref{table:protectionbits} in section~\ref{sec:fib}.
\smallskip{}

{\tt ERROR\_WRITE\_PROTECTED}: This error is generated by \emph{file
systems} if a write is attempted  to a file that is write protected,
i.e. whose {\tt FIBB\_WRITE} bit is set.
\smallskip{}

{\tt ERROR\_READ\_PROTECTED}: This error is generated on an attempt to read
from a while whose {\t FIBB\_READ} bit is set to indicate read protection.
\smallskip{}

{\tt ERROR\_NOT\_A\_DOS\_DISK}: This error is generated by a \emph{file
system} on an attempt to read a disk that is not strutured according to the
requirements of the \emph{file system}, i.e. that is initialized by another
incompatbile \emph{file system} different from the mounted
one. Unfortunately, AmigaDOS does not have a control instance that selects
file systems according to the disk layout.
\smallskip{}

{\tt ERROR\_NO\_MORE\_ENTRIES}: This secondary result code does not really
indicate an error condition, it just reports to the caller that the end of a
directory has been reached when scanning it by
{\tt ExNext()}\key{ExNext()} or {\tt ExAll()}\key{ExAll()}.
\smallskip{}

{\tt ERROR\_IS\_SOFT\_LINK}: This error code is generated by
\emph{file systems} on an attempt to access a \emph{soft link}. For many
functions, the \emph{dos.library} recognizes this error and then resolves
the link through {\tt ReadLink()}\key{ReadLink()} within the library, not
requiring intervention of the caller. However, not all functions of the
\emph{dos.library} are aware of \emph{soft links}, see
section~\ref{sec:links} for the list.
\smallskip{}

{\tt ERROR\_OBJECT\_LINKED}: This error code is currently not used by
AmigaDOS and its intended use is not known.
\smallskip{}

{\tt ERROR\_BAD\_HUNK}: Generated by {\tt LoadSeg()}\key{LoadSeg()} and {\tt
  NewLoadSeg()}\key{NewLoadSeg()}, this error code indicates that the binary
file includes a hunk type that is not supported or recognized by
AmigaDOS. The hunk format for binary executables is documented in
section~\ref{sec:loadseg()}.
\smallskip{}

{\tt ERROR\_NOT\_IMPLEMENTED}: This error code is not used by any ROM
component, but several workbench components signal this error indicating
that the requested function is not supported by this component. For example,
the {\tt Format} command generates it on an attempt to format a disk with
long file names if the target file system does not support them.
\smallskip{}

{\tt ERROR\_RECORD\_NOT\_LOCKED}: Issued by \emph{file systems} and their
record-locking subsystem if an attempt is made to release a record that is,
actually, not locked.
\smallskip{}

{\tt ERROR\_LOCK\_COLLISION}: This error is also created by the
record-locking subsystem of \emph{file systems} if attempt is made to
exclusively lock the same region within a file by two write locks.
\smallskip{}

{\tt ERROR\_LOCK\_TIMEOUT}: Also generated by the record-locking mechanism
of \emph{file systems} if an attempt was made to exclusively lock a region
of a file that is exclusively locked already, and the attempt failed because
the region did not became available before the lock timed out.
\smallskip{}

{\tt ERROR\_UNLOCK\_ERROR}: This error is curently not generated by any
\emph{file system}, though could be used to indicate that an attempt to
unlock a record failed for an unknown reason.
\smallskip{}

{\tt ERROR\_BUFFER\_OVERFLOW}: This error is raised by the pattern matcher
and indicates that the buffer allocated in the {\tt AnchorPath} structure is
too small to keep the fully expanded matching file name, see also
section~\ref{sec:pattern}.
\smallskip{}

{\tt ERROR\_BREAK}: This error is also raised by the pattern matcher if it
received an external signal for aborting a directory scan for objects. Such
signals are raised, for example, by the user through the console by pressing
{\tt Ctrl + C} through {\tt Ctrl + F}.
\smallskip{}

{\tt ERROR\_NOT\_EXECUTABLE}: This error is generated by the workbench on an
attempt to start an application icon from a file whose {FIBB\_EXECUTE} is
set, indicating that the file is not executable. Why the workbench does not
use the same error code as the \emph{Shell} remains unclear.

\subsection{Setting IoErr}

The {\tt SetIoErr()}\mkey{SetIoErr()} function sets the value returned by
the next call to {\tt IoErr()}\key{IoErr()} and thus initializes or resets
the next IO error.

\begin{verbatim}
oldcode = SetIoErr(code)
D0                 D1

LONG SetIoErr(LONG);
\end{verbatim}

This function sets the next value returned by {\tt IoErr()}; this can be
necessary because some functions of the \emph{dos.library} do not update
this value in all cases. A particular example are the buffered I/O functions
introduced in section~\ref{sec:bufferdio} that do not touch {\tt IoErr()} in
case the input or output operation can be satisfied from the buffer. A good
practise is to call {\tt SetIoErr(0)} upfront to ensure that these functions
leave~a $0$ in {\tt IoErr()} on success.
\smallskip{}

This function returns the previous value of {\tt IoErr()}, and thus the same
value {\tt IoErr()} would return.

\subsection{Select the Console Handler}

The {\tt SetConsoleTask()}\mkey{SetConsoleTask()} function selects the
\emph{handler} responsible for the ``{\tt *}'' file name and {\tt CONSOLE:}
pseudo-device.

\begin{verbatim}
oldport = SetConsoleTask(port)
D0                        D1

struct MsgPort *SetConsoleTask(struct MsgPort *)
\end{verbatim}

This function selects the \emph{MsgPort} of the console handler. AmigaDOS
will contact this handler for opening the ``{\tt *}'' as file name, or a
file relative to the {\tt CONSOLE:} pseudo-device. Note that the argument is
not a pointer to the \emph{handler} process, but rather to a \emph{MsgPort}
through which this process can be contacted. It returns the previously used
console handler \emph{MsgPort}. 
\smallskip{}

This function is the setter function corresponding to the
{\tt GetConsoleTask()}\key{GetConsoleTask()} getter function introduced in
section~\ref{sec:getconsoletask}.

\subsection{Select the Default File System} \label{sec:setfilesystask}

The {\tt SetFileSysTask()}\mkey{SetFileSysTask()} function selects the
handler responsible for resolving paths relative to the {\tt ZERO} lock.

\begin{verbatim}
oldport = SetFileSysTask(port)
D0                        D1

struct MsgPort *SetFileSysTask(struct MsgPort *)
\end{verbatim}

This function selects the \emph{MsgPort} of the default \emph{file
system}. AmigaDOS will contact this \emph{file system} if a path relative to
the {\tt ZERO} lock is resolved, e.g. a relative path name if the current
directory is {\tt ZERO}. This \emph{file system} should be identical to the
\emph{file system} of the {\tt SYS:} assign, and should therefore not be
relaced as otherwise resolving file names may be inconsistent between
processes.
\smallskip{}

Note that the argument is not a pointer to the \emph{handler} process, but
rather to a \emph{MsgPort} through which this process can be contacted. It
returns the previously used default file system \emph{MsgPort}. This
function is the setter equivalent of {\tt
  GetFileSysTask()}\key{GetFileSysTask()} introduced in
section~\ref{sec:getfilesystask}.

\chapter{Binary File Structure} \label{sec:binary}

The AmigaDOS \emph{Hunk} format represents executable and linkable
object files. While both formats are related, they are not identical;
executables can be loaded from the shell or the workbench from disk to
RAM, and then either overload the shell process, or a new process is
created from them. Object files are created as intermediate compiler
outputs; typically, each translation unit is compiled into one object
file which are then, in a final step, linked with a startup code and
object code libraries to form an executable.
\smallskip{}

An object or executable file in this format consists of multiple
\emph{hunks} (thus, the name). Hunks define either payload data as
indivisible \emph{segments} of code or data that is initialized or
loaded from disk, or additional meta-information interpreted by the
AmigaDOS loader, the {\tt LoadSeg()}\key{LoadSeg()} function. The
meta-information is used to relocate the payload to their final
position in memory, to define the size of the sections, to select the
memory type that is allocated for the segment, or to interrupt or
terminate the loading process.
\smallskip{}

Loaded executables are represented as singly linked list of segments
in memory, by a structure that looks as follows: \mkey{LoadedSegment}
\begin{verbatim} 
struct LoadedSegment {
    BPTR  NextSegment; /* BPTR to next segment or ZERO */
    ULONG Data[1];     /* Payload data */
};
\end{verbatim}
The above structure is \emph{not} documented and is not identical to
the {\tt Segment} in {\tt dos/dosextens.h}. The latter describes a
resident executable, see section~\ref{resident}, but also contains a
\emph{BPTR} to a segment in the above sense. Each segment of a binary
is allocated through {\tt AllocVec()} which is sometimes helpful as it
allows to retrieve size of the segment from the size of the allocated
memory block.
\smallskip{}

The hunk format distinguishes three types of \emph{segments}, each
represented by a hunk: \emph{code hunks} that should contain constant
data, most notably executable machine code and constant data
associated to this code, \emph{data hunks} that contain (variable)
data, and so called \emph{BSS} hunks that contain data that is
initialized to zero. Thus, the contents of \emph{BSS} hunks is not
represented on disk.

\punchline{Const is not enforced}{While \emph{code hunks} should
  contain executable code and other constant data, and \emph{data
    hunks} should contain variable data, nothing in AmigaDOS is able
  to enforce these conventions. In principle, \emph{data hunks} may
  contain executable machine code, and \emph{code hunks} may contain
  variable data. Note, however, that some third party tools may
  require programs to follow such conventions. Many commercial
  compilers structure their object code according to these
  conventions, or at least do so in their default configuration.}

Additional \emph{hunks} describe how to relocate the loaded code and
data. Relocation means that data within the hunk is corrected
according to the addresses this and other hunks are loaded to. The
relocation process takes an offset into one hunk, and adds to the
longword at this offset the absolute address of this or any other
hunk. That is, hunks on disk are represented as if their first byte is
placed at address~0, and relocation adjusts longwords within hunks to
the final positions in memory.
\smallskip{}

An extension of the executable file format is the \emph{overlay
  format} also supported by {\tt LoadSeg()}\key{LoadSeg()}. Here, only
a part of the file is loaded into memory, while the remaining parts
are only loaded on demand, potentially releasing other already loaded
parts from memory. Overlayed executables thus take less main memory,
though requires the volume containing the executable available all the
time.
\smallskip{}

AmigaDOS also contains a simple run-time binder that is only used by
compiled BCPL code, or by code that operates under such
requirements. The purpose of this binder is to populate the BCPL
\emph{global vector} of the loaded program. While this runtime binder
implements a legacy protocol, certain parts of AmigaDOS still
expect. These are \emph{handlers} or \emph{file systems} that use the
{\tt dol\_GlobVec} value of $0$ or $-2$, or corresponding {\tt
  GlobVec} entry in the mount list. While new handlers should not use
this BCPL legacy protocol, the ROM file system (the FFS) and the
port-handler currently still depend (or require) it, despite not being
written in BCPL. A second application of this run-time binding procol
is the shell which also depends on BCPL binding.

\section{Executable File Format}

The hunk format of executable files consists of 4-byte (longword) hunk
identifiers and subsequent data that is interpreted by the AmigaDOS
loader according to the introducing hunk identifier. The syntax of
such a file, and its hunks, is here presented in a pseudo-code, in
three-column tables.
\smallskip{}

The first column identifies the number of bits a syntax element
takes. Bits within a byte are read from most significant to least
significant bit, and bytes within a structure that extends over
multiple bytes are read from most significant to least significant
bit. That is, the binary file format follows the big-endian
convention. If the first column contains a question mark (``?''), the
structure is variably-sized, and the number of removed bits is defined
by the second column, or the section it refers to. If the first column
is empty, no bits are removed from the file.
\smallskip{}

The second column either identifies the member of a structure to which
the value removed from the stream is assigned, or contains pseudo-code
that describes how to process the values parsed from the stream. These
syntax elements follow closely the convention of the C language. In
particular {\tt if ({\it cond})} formulates a condition that is only
executed if {\it cond} is true, {\tt else} describes code that is
executed following an {\tt if} clause that is executed if {\it cond}
is false, and {\tt do} $\ldots$ {\tt while({\it cond})} indicates a
loop that continues as long as {\tt cond} is non-zero, and that may
alternatively be terminated by a {\tt break} within the body of the
loop. The expression {\tt i++} increments an internal state variable
{\tt i}, and the expression {\tt -{}-j} decrements an internal state
variable. The value of {\tt i++} is the value of $i$ before the
increment, and the value of {\tt -{}-j} is the value of $j$ after
decrementing it.
\smallskip{}

The following pseudo-code describes the top-level syntax of a binary
executable file AmigaDOS is able to bring to memory:

\begin{rkrmtabular}{Regular Executable File} \label{table:executable}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
? & \tt HUNK\_HEADER & Defines all segments, see section~\ref{sec:hunk_header} for details \\ \hline
 & \tt $i = t_{\mbox{num}}$ & Start with the first hunk, $t_{\mbox{num}}$ is defined in the {\tt HUNK\_HEADER} \\ \hline
 & \tt do \{ & Repeat until all hunks done \\ \hline
2  & \tt $\quad$ $\hat{m}_t[i]$ & These two bits are unused, but some utilities set it identical to $m_t[i]$, the memory type of the hunk, see~\ref{sec:hunk_header} \\ \hline
1  & \tt $\quad$ $a_f$ & Advisory hunk flag. \\ \hline
29 & \tt $\quad$ h & This is the hunk type \\ \hline
& \tt $\quad$ if (EOF) break; & Terminate loading on end of file \\ \hline
& \tt $\quad$ if ($a_f$) \{ & Check for bit $29$, these are advisory hunks \\ \hline
32 & \tt $\quad\quad$ l & Read length of advisory hunk \\ \hline
32 $\times$ l & & $l$ long words of hunk contents ignored \\ \hline
& \tt $\quad$ \} & \\ \hline
& \tt $\quad$ else if (h == HUNK\_END) i++; & Advance to next segment, see~\ref{sec:hunk_end} \\ \hline
& \tt $\quad$ else if (h == HUNK\_BREAK) break; & Terminate loading an overlay, see~\ref{sec:hunk_break} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_NAME) parse\_NAME; & See section~\ref{sec:hunk_name} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_CODE) parse\_CODE; & See section~\ref{sec:hunk_code} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DATA) parse\_DATA; & See section~\ref{sec:hunk_data} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_BSS) parse\_BSS; & See section~\ref{sec:hunk_bss} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELOC32) parse\_RELOC32; & See section~\ref{sec:hunk_reloc32} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_SYMBOL) parse\_SYMBOL; & See section~\ref{sec:hunk_symbol} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DEBUG) parse\_DEBUG; & See section~\ref{sec:hunk_debug} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_OVERLAY) \{ parse\_OVERLAY; break \} & See section~\ref{sec:hunk_overlay} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_DREL32) parse\_RELOC32SHORT; & This is a compatibility kludge for some older versions of the \emph{dos.library}, new tools should use {\tt HUNK\_RELOC32SHORT} instead, see section~\ref{sec:hunk_reloc32short} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELOC32SHORT) parse\_RELOC32SHORT; & See section~\ref{sec:hunk_reloc32short} \\ \hline
? & \tt $\quad$ else if (h == HUNK\_RELRELOC32) parse\_RELRELOC32; & See section~\ref{sec:hunk_relreloc32} \\ \hline
& \tt $\quad$ else ERROR\_BAD\_HUNK; & Everything else is invalid \\ \hline
& \tt \} while(true) & repeat until all hunks done \\ \hline
\end{longtable}
\end{rkrmtabular}

In particular, every executable shall start with the {\tt
  HUNK\_HEADER} identifier, the big-endian long-word {\tt 0x3f3}. The
following stream contains long-word identifiers of which the first
$2$~bits are ignored and masked out. Some tools (e.g. the {\tt Atom}
tool by CBM) places there memory requirements similar to what is
indicated in the {\tt HUNK\_HEADER}. They have there, however, no
effect as the segments are allocated within the {\tt HUNK\_HEADER} and
not at times the hunk type is encountered. \key{HUNK\_HEADER}
\smallskip{}

Bit $29$ ({\tt HUNKB\_ADVISORY})\mkey{HUNKB\_ADVISORY} has a special
meaning. If this bit is set, then the hunk contents is ignored. The
size of such an \emph{advisory} hunk is defined by a long-word
following the hunk type.
\smallskip{}

Loading a binary executable terminates on three conditions. Either, if
an end of file is encountered. This closes the file handle and returns
to the caller with the loaded segment list. Or, if a {\tt
  HUNK\_BREAK}\key{HUNK\_BREAK} or {\tt HUNK\_OVERLAY} are found. This
mechanism is used for \emph{overlayed} files. In the latter two cases,
the file remains open, and for {\tt HUNK\_OVERLAY}\key{HUNK\_OVERLAY},
information on the loaded file is injected into the first hunk of the
loaded data. More information on this mechanism is provided in
section~\ref{sec:overlays}.

\subsection{HUNK\_HEADER} \label{sec:hunk_header}

The {\tt HUNK\_HEADER}\mkey{HUNK\_HEADER} is the first hunk of every
executable file. It identifies the number of segments in an
executable, and the amount of memory to reserve for each
segment.
    
\begin{rkrmtabular}{Hunk Header Syntax} \label{table:hunk_header}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
32 & \tt HUNK\_HEADER [0x3f3] & Every executable file shall start with this hunk \\ \hline
32 & \tt $0$ & Number of resident libraries, BCPL legacy, shall be zero \\ \hline
32 & \tt $t_{\mbox{size}} \in [1,2^{31}-1]$ & Number of segments in binary \\ \hline
32 & \tt $t_{\mbox{num}} \in [0,t_{\mbox{size}}-1]$ & First segment to load \\ \hline
32 & \tt $t_{\mbox{max}} \in [t_{\mbox{num}},t_{\mbox{size}}-1]$ & Last segment to load (inclusive) \\ \hline
 & \tt for(i=$t_{\mbox{num}}$;$i \le t_{\mbox{max}}$;i++) \{ & Iterate over all hunks \\ \hline
2  & \tt $\quad$ $m_t[i]$ & Read memory type of the segment as 2 bits \\ \hline
30 & \tt $\quad$ $m_s[i]$ & Read memory size in long words as 30 bits \\ \hline
 & \tt $\quad$ if ($m[i]$ == 3) \{ & if the memory type is $3$ \\ \hline
32 & $\quad \quad m_s[i]$ & Memory type is explicitly provided \\ \hline
 & \tt $\quad$ \tt \} & End of special memory condition \\ \hline
 & \tt $\quad$ $m_a[i]$ = AllocVec(sizeof(BPTR) + $m_s[i] \times$ sizeof(LONG),$m_t[i] | $ \mbox{MEMF\_PUBLIC}) + sizeof(BPTR) &
Get memory for segment \\ \hline
 & \tt \} & End of loop over segments \\ \hline
\end{tabular}
\end{rkrmtabular}

The first member of a {\tt HUNK\_HEADER} shall always be $0$; it was
used by a legacy mechanism which allowed run-time binding of the
executable with dynamic libraries. While first versions of AmigaDOS
inherited this mechanism from TRIPOS, but it was not particularly useful
as the calling conventions for such libraries did not follow the usual
conventions of AmigaDOS, i.e. with the library base in register {\tt
  a6}. Later versions of AmigaDOS, in particular its re-implementation
as of Kickstart v37, removed support for such libraries. As this
mechanism is no longer supported, it is not documented here. More
information is found in~\cite{guru}.
\smallskip{}

The second entry $t_{\mbox{size}}$ contains the number of segments the
executable consists of. In case of overlays, it is the total number of
segments that can be resident in memory at all times. See
section~\ref{sec:overlays} for more information. This value shall be
consistent for all {\tt HUNK\_HEADERS} within an overlayed file. In
regular executables, only a single {\tt HUNK\_HEADER} exists at the
beginning of the file.
\smallskip{}

The members $t_{\mbox{num}}$ and $t_{\mbox{max}}$ define the 0-based index of
the first and last segment to load within the branch of the overlay
tree described by this {\tt HUNK\_HEADER}. For a regular
(non-overlayed) file and for the root node of the overlay tree,
$t_{\mbox{num}}$ shall be $0$, that is, the first segment to load
is~$0$, the first index in the segment table. 
\smallskip{}

For regular files, $t_{\mbox{max}}$ shall be identical to
$t_{\mbox{size}}-1$, that is, the last segment to load is the last entry
in the segment table described by this {\tt HUNK\_HEADER}. For
overlayed files, the number may be smaller, i.e. not all segments may
be populated initially and loading may continue later on when
executing the binary.

\subsection{HUNK\_CODE} \label{sec:hunk_code}

This hunk should contain executable machine code and constant data. As
executables are started from the first byte of the first segment, the
first hunk of an executable should be a {\tt HUNK\_CODE}, and it should
start with a valid opcode. \mkey{HUNK\_CODE}
\smallskip{}

Compilers use typically this hunk to represent the {\tt text} segment,
i.e. compiled code and constant data.

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Code Syntax} \label{table:hunk_code}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3e9] & A hunk describing a segment of code and constant data \\ \hline
32 & \tt $l \le m_s[i]$ & Size of the payload\\ \hline
l $\times$ 32 & \tt Code & $l$ long words of payload \\ \hline
\end{tabular}
\end{rkrmtabular}

Note that the size of the payload loaded from the file may be less
than the size of the allocated segment as defined in {\tt
  HUNK\_HEADER}. In such a case, all bytes of the segment not included
in the {\tt HUNK\_CODE} are zero-initialized. Earlier versions of
AmigaDOS skipped this initialization.

\subsection{HUNK\_DATA} \label{sec:hunk_data}

This hunk should contain variable data, and it should not contain
executable code. Compilers typically use this hunk to represent
initialized data. \mkey{HUNK\_DATA}
\smallskip{}

The structure of this hunk is otherwise identical to {\tt HUNK\_CODE}:
\begin{rkrmtabular}{Hunk Data Syntax} \label{table:hunk_data}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3ea] & A hunk describing a segment of data\\ \hline
32 & \tt $l \le m_s[i]$ & Size of the payload\\ \hline
l $\times$ 32 & \tt Code & $l$ long words of payload \\ \hline
\end{tabular}
\end{rkrmtabular}

Similar to {\tt HUNK\_CODE}, the size of the payload defined by this
hunk may be less than the size of the segment allocated by {\tt
  HUNK\_HEADER}. All excess bytes are zero-initialized in all but early
versions of AmigaDOS.

\subsection{HUNK\_BSS} \label{sec:hunk_bss}

This hunk contains zero-initialized data; it does not define actual
payload. \mkey{HUNK\_BSS}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk BSS Syntax} \label{table:hunk_bss}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_CODE [0x3eb] & A hunk describing zero-initialized data\\ \hline
32 & \tt $l \le m_s[i]$ & Size of the payload\\ \hline
\end{tabular}
\end{rkrmtabular}

Note that this hunk does not contain any payload; the segment
allocated from this hunk is always zero-initialized.

\subsection{HUNK\_RELOC32} \label{sec:hunk_reloc32}

This hunk contains relocation information for the previously loaded
segment; that is, it corrects addresses within this segment by
adding the absolute address of this or other segments to long words at
indicated offsets of the previous segments. \mkey{HUNK\_RELOC32}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Reloc32 Syntax} \label{table:hunk_reloc32}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC32 [0x3ec] & A hunk containing relocation information\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
32 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
32 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
32 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j]$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
\end{longtable}
\end{rkrmtabular}

That is, the hunk consists first of a counter that indicates the
number of relocation entries, followed by the hunk index relative to
which an address should be relocated. Then relocation entries follow;
each long-word defines an offset into the previously loaded segment to
relocate, that is, to fix up the address.

\subsection{HUNK\_RELOC32SHORT} \label{sec:hunk_reloc32short}

This hunk contains relocation information for the previously loaded
segment, and is almost similar to {\tt HUNK\_RELOC32}, except that
hunk indices, counts and offsets are only 16 bits in size. To ensure
that all hunks start at long-word boundaries, the hunk contains an
optional padding field at its end to align the next hunk
appropriately. \mkey{HUNK\_RELOC32SHORT}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Reloc32Short Syntax} \label{table:hunk_reloc32short}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELOC32SHORT [0x3fc] & A hunk containing relocation information\\ \hline
   & \tt $p$=$1$ & Padding count\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
16 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
16 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ $p$ += $c$ & Update padding count \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
16 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j]$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
   & \tt if ($p$ \& $1$) \{ & check whether padding is required. \\ \hline
16 & \tt $\quad$ & dummy for long-word alignment \\ \hline
   & \tt \} & \\ \hline
\end{longtable}
\end{rkrmtabular}

Due to an oversight, some versions of AmigaDOS do not understand the
hunk type {\tt 0x3fc} not properly and use instead {\tt 0x3f7}. This
alternative (but incorrect) hunk type for the short version of the
relocation hunk is still supported currently.


\subsection{HUNK\_RELRELOC32} \label{sec:hunk_relreloc32}

This hunk contains relocation information for 32-bit relative
displacements the {\tt 68020} and later processors offer. Currently,
there does not seem to be a compiler that is able to take advantage of
this hunk. \mkey{HUNK\_RELRELOC32}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk RelReloc32 Syntax} \label{table:hunk_relreloc32}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_RELRELOC32 [0x3fd] & A hunk containing relocation information\\ \hline
   & \tt do \{ & Loop over relocation entries \\ \hline
32 & \tt $\quad$ $c$ & Number of relocation entries \\ \hline
   & \tt $\quad$ if ($c$ == 0) break; & Terminate the hunk if the count is zero \\ \hline
32 & \tt $\quad$ $j \in [0,t_{\mbox{size}}-1]$ & Read the hunk to which the relocation is relative to \\ \hline
   & \tt $\quad$ do \{ & Loop over the relocation entries \\ \hline
32 & \tt $\quad\quad$ $r_o \in [0,m_s[i] \times 4 - 4]$ & Relocation offset into this hunk as byte address \\ \hline
   & \tt $\quad\quad$ (UBYTE **)($m_a[i]+r_o$) += $m_a[j] - m_a[i] - r_o$ & Fixup this hunk by the start
address of the selected hunk \\ \hline
   & \tt $\quad$ \} while(-{}-c); & until all entries are used \\ \hline
   & \tt \} while(true); & until a zero-count is read. \\ \hline
\end{tabular}
\end{rkrmtabular}

\subsection{HUNK\_NAME} \label{sec:hunk_name}

This hunk defines a name for the current segment. The AmigaDOS loader
completely ignores this name, and it does not serve a particular
purpose for the executable file format. However, linkers that bind
object files together use the name to decide which segments to merge
together to a single segment. \mkey{HUNK\_NAME}
\smallskip{}

The structure of this hunk is as follows:
\begin{rkrmtabular}{Hunk Name Syntax} \label{table:hunk_name}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_NAME [0x3e8] & A hunk assigning a name to the current segment\\ \hline
32 & \tt l & Size of the name in long-words \\ \hline
32 $\times$ l & \tt $h_n$ & Hunk name \\ \hline
\end{tabular}
\end{rkrmtabular}

The size of the name is not given in characters, but in 32-bit
units. The name is possibly zero-padded to the next 32-bit boundary to
fill an integer number of long-words. If the name fills an entire
number of long-words already, it is \emph{not} zero-terminated.
\smallskip{}

While the specification does not define a maximum size of the name,
the AmigaDOS loader fails on names longer than 128 character, i.e. 32
long-words.

\subsection{HUNK\_SYMBOL} \label{sec:hunk_symbol}

This hunk defines symbol names and corresponding symbol offsets or
values within the currently loaded segment. Again, the AmigaDOS loader
ignores this hunk, but the linker uses it to resolve symbols with
external linkage to bind multiple object files together. If the
symbol information is retained in the executable file, it may be used
for debugging purposes. \mkey{HUNK\_SYMBOL}
\smallskip{}

The synax of this hunk reads as follows:
\begin{rkrmtabular}{Hunk Symbol Syntax} \label{table:hunk_symbol}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_SYMBOL [0x3f0] & A hunk assigning symbols to positions within a segment\\ \hline
   & \tt do \{ & Repeat $\ldots$ \\ \hline
8  & \tt $\quad$ $s_t$ & Symbol type \\ \hline
24 & \tt $\quad$ $s_l$ & Symbol length in long-words \\ \hline
   & \tt $\quad$ if ($s_l$ == 0) break & Terminate the hunk \\ \hline
32 $\times$ l & \tt $\quad$ $s_n$ & Symbol name, potentially zero-padded \\ \hline
32 & \tt $\quad$ $s_v$ & Symbol value \\ \hline
   & \tt \} while(true) & until zero-sized symbol \\ \hline
\end{tabular}
\end{rkrmtabular}

The length of the symbol name is encoded in long-words, not in
characters. If it does not fill an integer number of long-words, it is
zero-padded; the name is not zero-terminated if it does fill an
integer number of long-words, though.
\medskip{}

The symbol type $s_t$ defines the nature of the symbol. The symbol
types are defined in {\tt dos/doshunks.h} and shared with the {\tt
  HUNK\_EXT} hunk; the latter hunk type shall not appear in an
executable file, but may only appear in an object file, see
section~\ref{hunk_ext}.\key{HUNK\_EXT}
\smallskip{}

The symbol type can be roughly classified into two classes: If bit $7$
of the type is clear, a symbol is \emph{defined} that may be
referenced by another object file. If bit $7$ is set, the symbol is
\emph{referenced} and requires resolution by a symbol definition with
bit 7 cleared upon linking. Executable files, and thus symbols within
{\tt HUNK\_SYMBOL}, may only contain symbol definitions as references
had been resolved by the linker before.
\smallskip{}

The following table contains the symbol types for definitions and
those may therefore may appear in both {\tt HUNK\_SYMBOL} as part of
executables and {\tt HUNK\_EXT}\key{HUNK\_EXT} as part of object
files; actually, {\tt HUNK\_SYMBOL} will typically only include the
first type of entry, i.e. {\tt EXT\_SYMB}:
\begin{rkrmtabular}{Symbol types in HUNK\_SYMBOL and HUNK\_EXT} \label{table:symboltypes}
\begin{tabular}{|lc|p{10cm}|} \hline
\tt EXT\_SYMB & [0x00] & Definition of a symbol, $s_v + m_a[i]$ is the address of the symbol \\ \hline

\tt EXT\_DEF & [0x01] & Relocation definition, $s_v + m_a[i]$ is the
address of the symbol. References to this symbol are converted into a
relocation information to the offset $s_v$ in hunk $i$. \\ \hline

\tt EXT\_ABS & [0x02] & Absolute value, $s_v$ is the value of the
symbol which is substituted into the executable by the linker. No
relocation information is created, the absolute value is just
substituted. \\ \hline

\tt EXT\_RES & [0x03] & Not longer supported as it is part of the
obsolete dynamic library run-time binding interface, see~\cite{guru}
for more details. \\ \hline
\end{tabular}
\end{rkrmtabular}

Additional symbol types representing references used within {\tt
  HUNK\_EXT}\key{HUNK\_EXT} are documented in
section~\ref{sec:hunk_ext}.

\subsection{HUNK\_DEBUG} \label{sec:hunk_debug}

This hunk contains debug information such as function names and line
number information. Generally, the contents of this hunk is compiler
or assembler specific, and the AmigaDOS loader does not interpret the
contents of this hunk at all, it is just skipped over. \mkey{HUNK\_DEBUG}
\smallskip{}

However, the debug information emitted by the SAS/C compiler for the
``line-debug'' option is also shared by other development tools such
as the DevPac assembler and will be documented here. In this format,
the debug hunk contains for each line of the source file an offset
into the hunk to the code that was compiled from this line.
\smallskip{}

The syntax of this hunk is as follows:
\begin{rkrmtabular}{Hunk Debug Syntax} \label{table:hunk_debug}
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline    
   & HUNK\_DEBUG [0x3f1] & Hunk including debug information \\ \hline
32 & l > 3 & Size of the hunk in long-words \\ \hline
\multicolumn{3}{|l|}{Compiler- and configuration specific data for line-debug data:} \\ \hline
32 & \tt $0$ & This field shall be zero \\ \hline
32 & \tt 'LINE' & These four bytes shall contain the
ASCII characters {\tt 'L','I','N','E'} identifying the type of the
debug information \\ \hline
32 & \tt $l_n$ & Size of the source file name in long-words \\ \hline
32 $\times l_n$ & $n_f$ & source file name that compiled to the current segment in $l_n$ long-words \\ \hline
   & \tt $l -= 3 + l_n$ & Remove long-words read so far \\ \hline
   & \tt while($l$ > 0) \{ & Repeat for all entries \\ \hline
8  & \tt $\quad$ & Dummy byte \\ \hline
24 & \tt $\quad$ $l_l$ & Line number within the source file \\ \hline
8  & \tt $\quad$ & Dummy byte \\ \hline
24 & \tt $\quad$ $l_v$ & Offset into the source file. The source file
at line $l_l$ is compiled or assembled to the code at at address
$m_a[i] + l_v$ and following. \\ \hline
   & \tt $\quad$ $l -= 2$ & Remove the read data \\ \hline
   & \tt \}; & Loop over the hunk. \\ \hline
\end{longtable}
\end{rkrmtabular}

The file name $n_f$ is encoded in $l_n$ long-words, and potentially
padded with $0$-bytes to fill an integer number of long-words. If it
already is an integer number of long-words sized, it is \emph{not}
zero-terminated.

\subsection{HUNK\_END} \label{sec:hunk_end}

This hunk terminates the current segment and advances to the next
segment, if any. It does not contain any data. \mkey{HUNK\_END}

\begin{rkrmtabular}{Hunk End Syntax} \label{table:hunk_end}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
  & \tt HUNK\_END [0x3f2] & Terminate a segment\\ \hline
\end{tabular}
\end{rkrmtabular}

\section{The AmigaDOS Loader} \label{sec:loader}

The \emph{dos.library} provides service functions for loading and
releasing binary executables in the \emph{Hunk} format introduced in
section~\ref{sec:binary}. The functions discussed in this section load
such binaries into memory, constructing a segment list from the hunks
found in the files, or release such files. Overlay files are discussed
separately in section~\ref{sec:overlays} due to their additional
complexity.

A segment list is a linearly linked list as defined in
section~\ref{sec:binary}, i.e. the first four bytes of every segment
form a \emph{BPTR} to the following segment of the loaded binary, or
{\tt ZERO} for the last segment.
\smallskip{}

The {\tt seglist} returned from the loader functions may be, for
example, passed into {\tt CreateNewProc()} as argument to the {\tt
  NP\_Seglist} tag for starting a new process.

\subsection{Loading an Executable} \label{sec:loadseg}

The {\tt LoadSeg()}\mkey{LoadSeg()} function loads an executable
binary in the Hunk format and returns a \emph{BPTR} to the first
segment:

\begin{verbatim}
seglist = LoadSeg( name )
D0                 D1

BPTR LoadSeg(STRPTR)
\end{verbatim}
This function loads the binary executable named {\tt name} and returns
a \emph{BPTR} to its first segment in case of success, or {\tt ZERO}
in case of failure. The {\tt name} is passed into the {\tt
  Open()}\key{Open()} function and follows the conventions of this
function for locating the file.
\smallskip{}

The segment list shall be removed from memory via {\tt
  UnLoadSeg()}\key{UnloadSeg()}.
\smallskip{}

This function sets {\tt IoErr()}\key{IoErr()} to an error code in case
of failure, or~$0$ in case of success.

\subsection{Loading an Executable with Additional Parameters} \label{sec:newloadseg}

The {\tt NewLoadSeg()}\mkey{NewLoadSeg()} function loads an
executable providing additional data for loading.

\begin{verbatim}
seglist = NewLoadSeg(file, tags)
D0                    D1    D2

BPTR NewLoadSeg(STRPTR, struct TagItem *)

seglist = NewLoadSegTagList(file, tags)
D0                           D1    D2

BPTR NewLoadSegTagList(STRPTR, struct TagItem *)

seglist = NewLoadSegTags(file, ...)

BPTR NewLoadSegTags(STRPTR, ...)
\end{verbatim}

This function loads a binary executable from {\tt file} and returns a
\emph{BPTR} to its first segment, similar to {\tt
  LoadSeg()}\key{LoadSeg()}.
\smallskip{}

Additional parameters may be provided in the form of a TagList, passed
in as {\tt tags}. The first two functions are identical and differ
only by their naming convention; the last function prototype also
refers to the same entry within the \emph{dos.library}, though uses a
different calling convention where the second and all following
arguments form the TagList itself. This TagList is build on the stack,
and the pointer to this stack-based TagList is passed in.
\smallskip{}

While this function looks quite useful, AmigaDOS does currently not
define any tags for this function, and thus no additional
functionality over {\tt LoadSeg()} is provided.
\smallskip{}

The segment list returned by this function shall be removed from
memory via {\tt UnLoadSeg()}\key{UnloadSeg()}, a specialized unloader
function is not required for this call.

\subsection{Loading an Executable through Call-Back Functions} \label{sec:internalloadseg}

The {\tt InternalLoadSeg()}\mkey{InternalLoadSeg()} function loads a
binary executable, retrieving data and memory through call-back
functions. While {\tt LoadSeg()}\key{LoadSeg()} always goes through
the \emph{dos.library} and the \emph{exec.library} for reading data
and allocating memory, this function instead calls through
user-provided functions.

\begin{verbatim}
seglist = InternalLoadSeg(fh,table,funcs)
D0                        D0  A0   A1   

BPTR InternalLoadSeg(BPTR,BPTR,struct LoadSegFuncs *)
\end{verbatim}
This function loads a binary executable in the hunk format from an
opaque file handle {\tt fh} through functions in the {\tt funcs}. The
{\tt table} argument shall be {\tt ZERO} when loading regular binaries
or the root node of an overlay file, and shall be a \emph{BPTR} to the
array containing pointers to all segments when loading a non-root
overlay node, see section~\ref{sec:overlays}.
\smallskip{}

The {\tt LSFuncs} structure contains function pointers through which
this function loads data or retrieves memory. It looks as follows: \mkey{LoadSegFuncs}
\begin{verbatim}
struct LoadSegFuncs {
    LONG __asm ReadFunc(register __d1 BPTR fh,
                        register __a0 APTR buffer,
                        register __d0 ULONG size,
                        register __a6 struct DosLibrary *DOSBase);
    APTR __asm AllocMem(register __d0 ULONG size,
                        register __d1 ULONG flags,
                        register __a6 struct ExecBase *SysBase);
    void __asm FreeMem (register __a1 APTR mem,
                        register __d0 ULONG size,
                        register __a6 struct ExecBase *SysBase);
}
\end{verbatim}
The {\tt ReadFunc()} function retrieves {\tt d0} bytes from an opaque
file handle passed into register {\tt d1} and places the read bytes
into the buffer pointed to by register {\tt a0}, it shall return the
number of bytes read in register {\tt d0}, or a negative value in case
of error. Note that the file handle {\tt d1} need not to be a file
handle as returned by the {\tt Open()}\key{Open()} function, it is
only a copy of the {\tt fh} argument provided to {\tt
  InternalLoadSeg()}. Register {\tt a6} is loaded by a pointer to the
\emph{dos.library}.
\smallskip{}

The {\tt AllocMem()} function allocates {\tt d0} bytes of memory,
using requirement flags from {\tt exec/memory.h} such as {\tt
  MEMF\_CHIP} to require chip memory or {\tt MEMF\_FAST} for fast
memory. This function shall return a pointer to the allocated memory
in register {\tt d0}, or {\tt NULL} in case of failure. Register {\tt a6}
is loaded with a pointer to the \emph{exec.library}.
\smallskip{}

The {\tt FreeMem()} function releases a block of {\tt d0} bytes
pointed to by {\tt a0}. Register {\tt a6} is loaded with a pointer to
the \emph{exec.library}.
\medskip{}

The purpose of this function is to load a segment or a binary without
having access to a file or a \emph{file system}; for example, this
function could load binaries from ROM-space, or from the Rigit Disk
Block of a boot partition. In particular, the {\tt fh} argument does
not need to be a regular \emph{file handle}; it is rather an opaque
value identifying the source. The {\tt InternalLoadSeg()} function
does not interpret this argument, but rather passes it into {\tt
  funcs->ReadFunc()} in register {\tt d1}.
\smallskip{}

When allocating memory, the {\tt InternalLoadSeg()} function follows
the conventions of the {\tt AllocVec()} and {\tt FreeVec()} functions
and stores the number of allocated bytes in the first four bytes of
the allocated memory block. In specific, the memory allocator and
memory releaser functions provided in the {\tt LoadSegFuncs} structure
\emph{do not need} to store the memory sizes, and the exec {\tt
  AllocMem()} and {\tt FreeMem()} functions satisfy the interfaces for
{\tt InternalLoadSeg()} function already.
\smallskip{}

This function does not set {\tt IoErr()}\key{IoErr()} consistently,
unless the functions within {\tt LoadSegFuncs} do. Callers should also
call {\tt SetIoErr(0)} upfront this function to identify all errors.

\subsection{Unloading a Binary} \label{sec:unloadseg}

The {\tt UnLoadSeg()}\mkey{UnLoadSeg()} function releases a linked
list of segments as returned by {\tt LoadSeg()}\key{LoadSeg()} or {\tt
  NewLoadSeg()}\key{NewLoadSeg()}.

\begin{verbatim}
success = UnLoadSeg( seglist )
D0                     D1

BOOL UnLoadSeg(BPTR)
\end{verbatim}
This function releases all segments chained together by {\tt
  LoadSeg()} and {\tt NewLoadSeg()} and returns their memory back into
the system pool. This function \emph{also} accepts overlayed segments,
see section~\ref{sec:overlays}, and releases additional resources
accquired for them.
\smallskip{}

Segment lists loaded through {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()} require in general a more
generic unloader. They shall be be released through {\tt
  InternalUnLoadSeg()}\key{InternalUnLoadSeg()} instead,
see~\ref{sec:internalunloadseg}.
\smallskip{}

This function returns a non-zero result in case of success, or~$0$ in
case of error. Currently, the only source of error is passing in {\tt
  ZERO} as segment list, all other cases will indicate success. In
particular, this function does not attempt to check return codes of
the function calls required to release resources assoicated to
overlayed files.

\subsection{UnLoading a Binary through Call-Back Functions} \label{sec:internalunloadseg}

The {\tt InternalUnLoadSeg()}\mkey{InternalUnLoadSeg()} function
releases a segment list loaded through {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()}.

\begin{verbatim}
success = InternalUnLoadSeg(seglist,FreeFunc)
D0                          D1       A1

BOOL InternalUnLoadSeg(BPTR,
                       void __asm (*)(register __a1 APTR,
                                      register __d0 ULONG,
                                      register __a6 struct ExecBase 
                                                    *SysBase))
\end{verbatim}
This function releases a segment list created by {\tt
  InternalLoadSeg()} passed in as {\tt seglist}. To release memory, it
uses a function pointed to by {\tt a1}. This function expects the
memory block to release in register {\tt a1} and its size in register
{\tt d0}. Additionally, register {\tt a6} will be populated by a
function to the \emph{exec.library}.
\smallskip{}

This function pointer should be identical to the {\tt FreeMem}
function pointer in the {\tt LoadSegFuncs} structure provided to {\tt
  InternalAllocMem()}, or at least shall be able to release memory
allocated by the {\tt AllocMem} function pointer in this structure.
Note that the {\tt InternalLoadSeg()} stores the sizes of the
allocated memory blocks itself and that {\tt FreeFunc} does not need
to retrieve them.
\smallskip{}

This function is also able to release overlayed binaries, but then
closes the file stored in the root node of the overlay tree (see
section~\ref{sec:overlays}) through the {\tt Close()} function of the
\emph{dos.library}. It therefore can only release overlayed files that
were loaded from regular \emph{file handles} obtained through {\tt
  Open()}\key{Open()}.
\smallskip{}

This function returns a non-negative result code in case of success,
or $0$ in case of failure. Currently, the only cause of failure is to
pass in a {\tt ZERO} segment list, the function does not check of the
result code of {\tt Close()} on the file handle of overlayed files. It
therefore neither sets {\tt IoErr()} consistently in case of failure.

\section{Overlays} \label{sec:overlays}

While regular binary executables are first brought to memory in entity
and then brought to execution, overlayed binaries only keep a fraction
of the executable code in memory and then load additional code parts
as required, potentially releasing other currently unused code parts
and thus making more memory available.
\smallskip{}

Overlays are an extension of the AmigaDOS hunk format that splits the
executable into a root node that is loaded initially and stays
resident for the lifetime of the program, and one or multiple
extension or overlay nodes that are loaded and unloaded on
demand. Locating the overlay nodes, loading them to memory and
releasing unused nodes is performed by the \emph{overlay manager}, a
short piece of program.
\smallskip{}

AmigaDOS does not provide a ROM-resident overlay manager itself,
i.e. the \emph{dos.library} does not provide an overlay manager
itself, though it provides services overlay managers may use. Instead,
the overlay manager is part of the root node of an overlayed binary,
and thus overlay management is fully under control of the application.
\smallskip{}

However, the Amiga linker \emph{ALink}, the Software Distillery linker
\emph{BLink} and the SAS/C linker \emph{SLink} include a standard
overlay manager, and this manager and its properties are discussed in
greater detail in this section.

\subsection{The Overlay File Format}

A binary file making use of overlays consists of several nodes, one
root node and several overlayed nodes. Nodes contain multiple
segments, defined through {\tt HUNK\_CODE}, {\tt HUNK\_DATA} or {\tt
  HUNK\_BSS} as in regular (non-overlayed) binary files.
\smallskip{}

Each node, the root node and all overlayed nodes start with a {\tt
  HUNK\_HEADER}\key{HUNK\_HEADER} identifying which segments are
contained in the node. The root node is terminated by a {\tt
  HUNK\_OVERLAY}\key{HUNK\_OVERLAY} on which loading stops; this hunk
contains additonal data for the purpose of the overlay manager, and
therefore the data within this hunk depends on the overlay manager.
\smallskip{}

Every other overlay node terminates with a {\tt HUNK\_BREAK}, and
loading stops there as well. This hunk does not contain any data. The
overall structure of an overlayed binary therefore looks as follows:

\begin{rkrmtable}{Overlay File Format} \label{table:overlayformat}
{\bf Hunk Type}   & {\bf Description}\\ \hline \hline
\tt HUNK\_HEADER  & Defines segments for the root node \\ \hline
\tt HUNK\_CODE    & Contains the overlay manager and other resident code \\ \hline
\tt \ldots        & Other hunks, such as relocation information \\ \hline
\tt HUNK\_END     & Terminates the previous segment \\ \hline
\tt HUNK\_OVERLAY & Metadata for the overlay manager, see~\ref{sec:hunk_overlay} \\ \hline
\tt do \{         & Repeats over all overlay nodes \\ \hline
\tt $\quad$ HUNK\_HEADER  & Defines the segments in this overlay node \\ \hline
{\tt $\quad$ HUNK\_CODE} or {\tt HUNK\_DATA} & First segment of the overlay node \\ \hline
\tt $\quad$ \ldots & Other hunks of this overlay node \\ \hline
\tt $\quad$ HUNK\_END    & Terminates the last segment \\ \hline
\tt $\quad$ HUNK\_BREAK  & Terminates the first overlay node, see~\ref{sec:hunk_break} \\ \hline
\tt \} while(!end of file); & This pattern repeats until end of file \\ \hline
\end{rkrmtable}

\subsection{The Hierarchical Overlay Manager}

The overlay manager that comes with the standard Amiga linkers
\emph{ALink}, \emph{BLink} and \emph{SLink} structures overlay nodes
into a tree such as the following:

\begin{center}
\begin{forest}
  [root
    [a [b] [c [d] [e]] [f] [g]] [h] [k [l] [m]]
  ]
\end{forest}
\end{center}

Only those nodes that form a path from the root to one of the nodes of
the tree can be in memory at a time. Thus, for the above example, the
root node and nodes $a$, $c$ and $e$ can be in memory simultaneously,
or the root node, and nodes $k$ and $m$ can be loaded at the same
time, but not the nodes $a$, $g$ and $h$ because they do not form a
path from the root to one of the nodes.
\smallskip{}

Thus, in the above example, if nodes $a$ and $f$ are in memory, and
node $l$ is required, the nodes $a$ and $f$ will be removed from
memory, and nodes $k$ and $l$ are loaded. Even though $k$ is not
explicitly requested, it needs to be loaded as it is the parent of
$l$.
\medskip{}

Every node in the overlay tree is identified by two numbers: The depth
\mkey{Level (overlay)} of the node, which identifies the level within
the tree where a node is located. The root node is at level~$0$, the
nodes~$a$, $h$ and~$k$ forms level~$1$ in the above example,
nodes~$b$, $c$, $f$, $g$ and~$l$ and~$m$ form level~$2$, and nodes~$d$
and~$e$ are level~$3$.
\smallskip{}


The second number is the ordinate number of a node.\mkey{Ordinate
  (overlay)} The ordinate enumerates nodes from left to right within a
level, and it starts from~$1$ in the standard overlay manager. In the
above example, $a$ is at ordinate~$1$, $h$ at ordinate~$2$, and $k$ at
ordinate~$3$. At level~$2$, node~$b$ has ordinate~$1$, node~$c$
ordinate~$2$ and so on.


\subsection{HUNK\_OVERLAY} \label{sec:hunk_overlay}

This hunk terminates the loading process and indicates the end of the
main (first) segments. The {\tt HUNK\_OVERLAY} contains meta-data ---
the overlay table --- for the overlay manager. This table contains
information where symbols within the overlayed segments are
located. Section~\ref{sec:overlay} provides more information on
overlays. The format of the data within this hunk depends on the
overlay manager which shall be included in the first segment of the
executable itself as AmigaDOS does not contain a resident overlay
manager.\mkey{HUNK\_OVERLAY}
\smallskip{}

The standard AmigaDOS linkers, {\tt ALink} and {\tt BLink} both
include an overlay manager. Each entry in its overlay table describes
a symbol that is located in one of the overlay nodes. The format of
{\tt HUNK\_OVERLAY} reads as follows:
\begin{rkrmtabular}{Hunk Overlay Syntax} \label{table:hunk_overlay}%
\begin{longtable}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
   & \tt HUNK\_OVERLAY [0x3f5] & Overlay table definition\\ \hline
32 & \tt $l$ & Size of the overlay table, it is $l+1$ long-words large. \\ \hline
\multicolumn{3}{|l|}{Format for the standard overlay manager, $l+1$ long-words.} \\ \hline
32 & \tt $o_d$ & Number of levels in the overlay tree, including the root node \\ \hline
   & \tt for($i$ = 1;$i$ < $o_d$;i++) \{ & For all nodes, excluding the root node \\ \hline
32 & \tt $\quad$ $0$ & Currently loaded ordinate, shall be zero \\ \hline
   & \tt \} & That is, $o_d-1$ zeros \\ \hline
   & \tt $l -= o_d$ & Count removed long-words \\ \hline
   & \tt $s  = 0$   & Start with symbol $0$ \\ \hline
   & \tt while($l \ge 0$) \{ & Repeat over the overlay table \\ \hline

32 & \tt $\quad$ $o_p[s]$ & Absolute file offset of the {\tt
  HUNK\_HEADER} of the overlay node containing the symbol. \\ \hline
64 & \tt $\quad$ & Two reserved long-words. \\ \hline

32 & \tt $\quad$ $o_l[s]$ & Level of the overlay node containing the symbol,
the root level containing the overlay manager is level~$0$. \\ \hline

32 & \tt $\quad$ $o_n[s]$ & Ordinate of the overlay node, enumerating
overlay nodes of the same depth. \\ \hline

32 & \tt $\quad$ $o_h[s]$ & Hunk index of the first hunk within
the overlay node. \\ \hline

32 & \tt $\quad$ $o_s[s]$ & Hunk index of the hunk containing the symbol
described by this entry in the overlay node. \\ \hline

32 & \tt $\quad$ $o_o[s]$ & Symbol offset within hunk $o_s$ \\ \hline
   & \tt $\quad$ $l$ -=8 & Remove 8 long words. \\ \hline
   & \tt $\quad$ $s++$   & Advance to next symbol. \\ \hline
   & \tt \} & End of loop over table \\ \hline
\end{longtable}
\end{rkrmtabular}

Note that the overlay table is $l+1$ and not $l$ long-words large,
i.e. a table only defining a single symbol would be indicated by a
value of $l=7$. While the payload data of {\tt HUNK\_OVERLAY} is
always $l+1$ long-words large, with $l$ indicated in the first
long-word of the hunk, the format of the subsequent data is specific
to the overlay manager used.
\medskip{}

Irrespective of the overlay manager used, the AmigaDOS loader injects
overlay-specific data into the first segment loaded from disk, that
is, into the root-node. The data placed there is also required to
release all resources associated to overlays and is expected there by
{\tt UnLoadSeg()}\key{UnLoadSeg()} and {\tt
  InternalUnLoadSeg()}\key{InternalUnLoadSeg()}.
\smallskip{}

The first bytes of the root node shall therefore form the following
structure:
\begin{verbatim}
struct OverlayHeader {
    UWORD         oh_Jump[2];      /* Forms a branch to the startup code */
    LONG          oh_Magic;        /* Shall be 0x0000abcd                */
    BPTR          oh_FileHandle;   /* Filled by the loader with the fh   */
    struct OVTab *oh_OVTab;        /* Overlay table from HUNK_OVERLAY    */
    BPTR          oh_Segments;     /* Array of segment BPTRs             */
    BPTR          oh_GV;           /* standard Global Vector             */
};
\end{verbatim}
As said earlier, this structure is expected to be present at the start
of the first hunk of the root node. The members {\tt oh\_FileHandle}
to {\tt oh\_GV} are filled in by the AmigaDOS loader, i.e. {\tt
  LoadSeg()} and related functions, but {\tt oh\_Jump} and {\tt
  oh\_Magic} shall be part of the segment itself.
\smallskip{}

{\tt oh\_Jump} form valid {\tt 68K} opcodes, and shall contain a jump
or branch branch around this structure. This is because loaded
binaries are executed from the first byte of the first segment
loaded. Otherwise, the CPU would run into the data of the structure
which likely forms invalid or illegal opcodes. The AmigaDOS Loader
itself does not interpret the values here, just expects them to be
present.
\smallskip{}

{\tt oh\_Magic} shall contain the ``magic'' long-word {\tt
  0xabcd}. This value is neither filled or interpreted by the loader,
but nevertheless shall be present. It is, however, checked by {\tt
  UnLoadSeg()}\key{UnLoadSeg()} and used there as an identifier for
the {\tt OverlayHeader} structure. If this identifier is not present,
{\tt UnLoadSeg()} will not be able to release resources associated to
overlays.
\smallskip{}

{\tt oh\_FileHandle} will be filled by the AmigaDOS loader with a
\emph{BPTR} to the \emph{FileHandle} from which the root node has been
loaded, or with the first argument of {\tt
  InternalLoadSeg()}\key{InternalLoadSeg()}. This handle is used by
the overload manager to load all subsequent overlay nodes. Also, {\tt
  UnLoadSeg()}\key{UnLoadSeg()} and related functions call {\tt
  Close()}\key{Close()} on the handle stored here as the file needs to
stay open for the life time of the loaded program.
\smallskip{}

{\tt oh\_OVTab} is filled by the AmigaDOS loader to a pointer to the
payload data of {\tt HUNK\_OVERLAY}. The standard overlay manager
stores here for every externally referenced symbol in an overlay node
a structure that records for each tree level the ordinate of the
currently loaded overlay node, and for all externally referenced
symbols the position of the symbol within the overlay tree:
\mkey{OVTab}
\begin{verbatim}
struct OVTab {
    ULONG ot_TreeDepth;    /* Depth of the tree, including the root    */
    ULONG ot_LoadedOrd[];  /* The loaded ordinate, indexed by level-1  */
}
struct SymTab {
    ULONG ot_FilePosition; /* File position of HUNK_HEADER of the node */
    ULONG ot_Reserved[2];  /* Not in use                               */
    ULONG ot_Level;        /* Level of the overlay node                */
    ULONG ot_Ordinate;     /* Ordinate of the overlay node             */
    ULONG ot_FirstHunk;    /* First segment of the overlay node        */
    ULONG ot_SymbolHunk;   /* Segment containing the referenced symbol */
    ULONG ot_SymbolOffset; /* Offset of the segment within the segment */
} []                       /* For each symbol */
\end{verbatim}
That is, the overlay table starts with the tree depth $o_d$ and an
array of $o_d-1$ elements where each element stores the ordinate of
the currently loaded overlay node. If an entry in this array is~$0$,
no overlay node at this tree level is loaded, otherwise it is the
$1$-based ordinate of the node.
\smallskip{}

The ordinate table is followed by the symbol table. The purpose of
this structure is that it allows the overlay manager on a reference to
such an external symbol to find and load the overlay node containing
the symbol, and then resolve references to it. How exactly it does so
is explained in more detail in section~\ref{sec:stdoverlay}. The
elements of this structure are already briefly introduced in
table~\ref{table:hunk_overlay}.
\smallskip{}

{\tt oh\_Segments} is filled by the AmigaDOS loader to a \emph{BPTR}
to the segment table of the loaded binary. The size of this table is
taken from $t_{\mbox{size}}$ in the {\tt HUNK\_HEADER}\key{HUNK\_HEADER} of the root
node, see table~\ref{table:hunk_header}. Each element in this array
contains a \emph{BPTR} to a segment of the loaded binary, and it is
indexed by the segment number, counting from~$0$ for the first segment
of the root node.
\smallskip{}

When parsing a {\tt HUNK\_HEADER}, the array entries $t_{\mbox{num}}$
to $t_{\mbox{max}}$ will be populated with the \emph{BPTR}s to the
segments allocated of the node described by this hunk, and when
unloading an overlay node, the corresponding segments will be
unlinked, released and then cleared out.
\medskip{}

{\tt oh\_GV} is, finally, filled with the Global Vector of the
\emph{dos.library} containing all regular functions in the library, as
required by BCPL code. Overlay managers implemented in C or assembler
will not make use of it and instead call vectors of the
\emph{dos.library} through the \emph{dos.library} base address loaded
in register {\tt a6}.

\subsection{HUNK\_BREAK} \label{sec:hunk_break}

This hunk terminates the loading process and indicates the end of an
overlay node. The hunk itself does not contain any
data. \mkey{HUNK\_BREAK}

\begin{rkrmtabular}{Hunk Break Syntax} \label{table:hunk_break}
\begin{tabular}{|l|p{6cm}|p{6cm}|} \hline
{\bf Size} & {\bf Code} & {\bf Syntax} \\ \hline \hline
  & \tt HUNK\_BREAK [0x3f6] & Terminate a segment\\ \hline
\end{tabular}
\end{rkrmtabular}

\subsection{Loading an Overload Node} \label{sec:loadsegoverload}

The {\tt LoadSeg()}\key{LoadSeg()} function is not only able to load
the root segments of an overlayed binary, it can also be used for
loading an overlayed node and all segments within it. For that, the
file pointer shall first be placed with {\tt Seek()}\key{Seek()} to
the file offset of the {\tt HUNK\_HEADER} of the overlayed node. This
file offset may, for the standard hierarchical overlay manager, be
taken from the {\tt ot\_FilePosition} of the overlay table.

\begin{verbatim}
seglist = LoadSeg( name ,table, fh)
D0                 D1    D2     D3

BPTR LoadSeg(STRPTR ,BPTR, BPTR)
\end{verbatim}
For overlayed node loading, the first argument {\tt name} shall be
{\tt NULL}, which is used as an indicator to this function to
interpret two additional (usually hidden) arguments.
\smallskip{}

{\tt table} is a \emph{BPTR} to the segment table, and may be taken
from {\tt oh\_Segments}. It contains \emph{BPTRs} to all allocated
segments, see section~\ref{sec:hunk_overlay}.
\smallskip{}

{\tt fh} is a \emph{BPTR} to the \emph{FileHandle} from which the
overlay node is to be loaded. This handle may be taken from
{\tt oh\_FileHandle}, see section~\ref{sec:hunk_overlay}.
\smallskip{}

While this function allocates and loads the segments in the overlayed
node, it does not attempt to release already allocated segments
populating the same entries in the segment table; it is instead up to
the overlay manager to clean up the segment table upfront,
see~\ref{sec:unloadnode}. The information which segments will be
populated by an overlay node may be taken from the {\tt ot\_FirstHunk}
member of the overlay table. Due to the tree structure imposed by the
hierarhical overlay manager, it has to release all segments from {\tt
  ot\_FirstHunk} onwards up to the end of the table, unlink the
segments contained therein, and then load another overlay node through
{\tt LoadSeg()}.
\smallskip{}

Note that this function populates the same offset in the
\emph{dos.library} as the regular {\tt LoadSeg()}\key{LoadSeg()}
function; the function distinguishes loading regular binaries through
a file name from loading overlay nodes by the first argument.
\smallskip{}

As the regular {\tt LoadSeg()} call, this function returns the
\emph{BPTR} to the first segment loaded on success, links all loaded
segments together, populates the segment table, and then sets {\tt
  IoErr()}\key{IoErr()} to~$0$. On error, it returns {\tt ZERO} and
installs an error code in {\tt IoErr()}.

\subsection{Loading an Overlay Node through Call-Back Functions}

The {\tt InternalLoadSeg()}\key{InternalLoadSeg()} function can also load
an overlay node.

\begin{verbatim}
seglist = InternalLoadSeg(fh,table,funcs)
D0                        D0  A0   A1   

BPTR InternalLoadSeg(BPTR,BPTR,struct LoadSegFuncs *)
\end{verbatim}

The {\tt fh} argument is an opaque file handle that is suitable for
the {\tt ReadFunc()} provided by the {\tt funcs} structure. The
corresponding file pointer shall first be placed to the file offset of
the {\tt HUNK\_HEADER} of the overlayed node, e.g. by a functionality
similar to {\tt Seek()}\key{Seek()} for regular
\emph{FileHandles}. This file offset may, for the standard
hierarchical overlay manager, be taken from the {\tt ot\_FilePosition}
within the overlay table.
\smallskip{}

The {\tt table} shall be the \emph{BPTR} to the segment table; this
may be taken from {\tt oh\_Segments}. This argument determines whether
a regular binary load is requested, or an overlay node is to be
loaded. In the latter case, this argument is non-{\tt ZERO}.
\smallskip{}

Like {\tt LoadSeg()}\key{LoadSeg()}, this function does not release
segments in populated entries in the segment list, it is up to the
overlay manager to unload these segments. The information which
entries of the segment table will be populated by an overlay node may
be taken from the {\tt ot\_FirstHunk} member of the overlay table, see
also~\ref{sec:loadsegoverload}.
\smallskip{}

The {\tt funcs} argument points to a {\tt LoadSegFuncs} structure as
defined in section~\ref{sec:internalloadseg} and contains functions for
reading data and allocating and releasing memory.
\smallskip{}

This function does not set {\tt IoErr()} consistently, unless the
functions in the {\tt LoadSegFuncs} structure do. The function returns
the segment of the first segment of the overlay node on success, or
{\tt ZERO} on error.

\subsection{Unloading Overlay Nodes} \label{sec:unloadnode}

Unloading overlay nodes (and \emph{not} the root node) of an overlayed
binary requires some manipulation of the segment table as the
\emph{dos.library} does not provide a function for such
operation. This algorithm is part of the overlay manager, but its
implementation within the standard hierarchical overlay manager
documented here for completeness. Other custom overlay managers
perform potentially different algorithms.
\smallskip{}

First, it finds the previous segment upfront the segment to be
unloaded, and cleans there the {\tt NextSegment} pointer to unlink all
following segments.  Then these following segments are released
through {\tt FreeVec()} or whatever memory release function is
appropriate.
\smallskip{}

The following sample code releases the overlay node starting at
segment $i > 0$ from a segment table of an overlay header:
\begin{verbatim}
void UnloadOverlayNode(struct OverlayHeader *oh,ULONG i)
{
  BPTR *segtbl  = (BPTR *)BADDR(oh->oh_Segments);
  BPTR *segment = (BPTR *)BADDR(segtbl[i - 1]); 
  BPTR  next;

  /* Release the linkage from the last loaded to
  ** the first segment to release */
  *segment = NULL;

  do {
    /* Get the segment to release */
    if (segment = (BPTR *)BADDR(segtbl[i++])) {
      next      = *segment;
      FreeVec(segment);
    } else break;
    /* Repeat until the last segment */
  } while(next);
}
\end{verbatim}
Note that a previous segment always exists because the root node
populates at least entry~$0$ of the segment table. The above loop
makes use of the fact that the first long-word of a segment is a
\emph{BPTR} to the next segment, and this linkage is {\tt ZERO} for
the final node.
\smallskip{}

If a custom memory allocator has been used for loading overlay nodes
through {\tt InternalLoadSeg()}\key{InternalLoadSeg()}, the {\tt
  FreeVec()} in the above function is replaced by the corresponding
memory release function.

\subsection{Unloading Overlay Binaries}

To unload the root node, and thus unload the entire program including
all overlay nodes, {\tt UnLoadSeg()}\key{UnLoadSeg()} on the first
segment of the root node is sufficient if neither custom I/O nor a
custom memory allocator has been used to load the binary, independent
on which overlay manager has been used. {\tt UnLoadSeg()} will detect
the overlay manager from the magic value in {\tt oh\_Magic} and will
then not only release the segments, but also close the overlay file
handle and release the segment table.
\smallskip{}

If {\tt InternalLoadSeg()}\key{InternalLoadSeg()} has been used for
loading the root node through custom I/O functions or with a custom
memory allocator, {\tt InternalUnLoadSeg()}\key{InternalUnLoadSeg()}
shall be used instead to release the root node. Unfortunately, it
\emph{always} uses {\tt Close()}\key{Close()} on {\tt oh\_FileHandle},
even if {\tt oh\_FileHandle} does not correspond to a
\emph{FileHandle} as returned by {\tt Open()}\key{Open()},
e.g. because {\tt ReadFunc()} upon loading the overlay program pointed
to a custom I/O function. The best strategy in this case is probably
to close {\tt oh\_FileHandle} manually upfront with whatever method is
appropriate, then zero it out manually and then finally call into {\tt
  InternalUnLoadSeg()} to perform all the necessary cleanup steps.
This strategy works because {\tt Close()} on a {\tt ZERO}
file handle performs no operation and is legit.

\subsection{Internal Working of the Overlay Manager}

Several versions of the hierarchical overlay manager exist. The
version described here stems from the SAS/C {\tt SLink} utility and is
designed for the \emph{registerized parameters} configuration within
which some function arguments are passed in CPU registers. Earlier
versions require stack-based parameter passing.
\smallskip{}

When binding objects together to an overlay binary together, the
linker checks whether a reference to a symbol crosses a boundary of
overlay nodes. References that go to a parent node or the node itself
can be resolved by the linker by creating a relocation entry in a {\tt
  HUNK\_RELOC32} hunk as it can assume that the corresponding segment
is already loaded.
\smallskip{}

References to symbols within child nodes receive each a unique integer
identifier, and an entry in the overlay table in {\tt HUNK\_OVERLAY}
at the index given by the identifier. The actual call to a function in
a child node is then replaced to call into a trampoline function that
looks as follows:
\begin{verbatim}
@symX:
    jsr @ovlyMgr
    dc.w symbX
\end{verbatim}
where {\tt @ovlyMgr} is the entry point of the overlay manager and
{\tt symbX} is the identifier of the referenced symbol. The overlay
manager reads the return PC which points to the identifer, and from the
identifier finds the entry in the symbol table. 
\smallskip{}

The symbol table contains both the ordinate and the level of the
symbol with which the overlay manager is able to check whether the
node containing the symbol is currently loaded. If this is not the
case, it needs to unload the currently loaded node at this level and
all its children, and then progresses to loading the required node
from the file offset in the symbol table, and then progresses to
updating the overlay table.
\smallskip{}

If the overlay node containing the symbol is already loaded, or just
has been loaded, the symbol address is computed from the offset in the
symbol table and the address of the segment containing the symbol from
the segment table, and injected into the return address that contained
a pointer to the symbol identifier. Thus, when returning from the
overlay manager, the code will continue to execute from the target
symbol. Other versions of the overlay manager use a trampoline function that
loads register {\tt d0} with the symbol identifier and thus require
stack-based function calls.
\smallskip{}

Regardless of the version of the overlay
manager, only symbols corresponding to function can be resolved as the
overlay manager must be called to resolve a symbol. In particular,
data cannot be referenced across overlay nodes --- instead, an
accessor function may be used that returns the object to be accessed.
\medskip{}

The following code provides an overlay manager for register-based
calls:
\begin{verbatim}
        xdef    @ovlyMgr
;*************************************************
;** Offsets in the overlay-table                **
;*************************************************
        rsreset
ot_FilePosition:        rs.l 1          ;File position
ot_reserved:            rs.l 2          ;for whatever
ot_OverlayLevel:        rs.l 1          ;Overlay-Level
ot_Ordinate:            rs.l 1          ;Overlay-Ordinate
ot_InitialHunk:         rs.l 1          ;Initial hunk for loading
ot_SymbolHunk:          rs.l 1          ;Hunk containing symbol
ot_SymbolOffset:        rs.l 1          ;Offset of symbol
ot_len:                 rs.b 0

;*************************************************
;** Other stuff                                 **
;*************************************************
MajikLibWord    =       23456           

       section NTRYHUNK,CODE
;*************************************************
;** Manager starts here                         **
;*************************************************
Start:
        bra.w NextModule                ;Jump to the next segment...

;* This next word serves to identify the overlay
;* supervisor to 'unloader', i.e. UnLoadSeg()

        dc.l       $ABCD                ;Magic longword for UnLoadSeg

;* The next four LWs are filled by the loader (LoadSeg())
ol_FileHandle:  dc.l 0                  ;Overlay file handle (points to me)
ol_OverlayTab:  dc.l 0                  ;Overlay table as found in the overlay hunk
ol_HunkTable:   dc.l 0                  ;BPTR to Overlay hunk table
ol_GlobVec:     dc.l 0                  ;BPTR to global vector (what for ?)

                dc.l MajikLibWord       ;Majik library word as identifier
                dc.b 7,"Overlay"        ;Majik identifier

;* the following data is specific to this manger

ol_SysBase:     dc.l 0                  ;additional pointer
ol_DOSBase:     dc.l 0                  ;to libraries

                dc.b "THOR Overlay Mananger 1.0",0      ;another ID

@ovlyMgr:                               ;Entry-points
        saveregs d0-d3/a0-a4/a6         ;Saveback register

        moveq #0,d0
        move.l 10*4(a7),a0
        move.w (a0),d0                  ;get the overlay reference ID from return address

        move.l ol_OverlayTab(pc),a3     ;get pointer to overlay table
        move.l a3,a4                    ;to a4
        add.l (a3),d0                   ;add length
        lsl.l #2,d0                     ;get offset
        add.l d0,a3                     ;address of overlay entry
        move.l ot_OverlayLevel(a3),d0   ;get overlay
        lsl.l #2,d0
        adda.l d0,a4
        move.l ot_Ordinate(a3),d0       ;get required ordinate level
        cmp.l (a4),d0                   ;compare with current ordinate level
        beq.s .gotsegment
                                        ;not correct level
                                        ;clear all other entries behind this
        move.l d0,(a4)+                 ;fill with new overlay entries

        moveq #0,d1
        do                              ;macros in action! ;-)
         tst.l (a4)                     ;terminate, if end of table found
         break.s eq
         move.l d1,(a4)+                ;clear this
        loop.s

        move.l ot_InitialHunk(a3),d0    ;first hunk number to load
        add.l ol_HunkTable(pc),d0       ;plus BPTR of hunk table
        lsl.l #2,d0                     ;address of entry in hunk table
        move.l d0,a4
        move.l -4(a4),d0                ;get previous hunk
        beq.s .noprevious
        lsl.l #2,d0
        move.l d0,a2
        move.l d1,(a2)                  ;unlink fields before loading

                                        ;now free all hunks
        move.l ol_SysBase(pc),a6

        do
         move.l (a4)+,d0                ;next hunk ?
         break.s eq
         lsl.l #2,d0
         move.l d0,a1                   ;->a1
         move.l -(a1),d0                ;get length
         jsr FreeMem(a6)                ;free this hunk
        loop.s                          ;and now the next
.retry:
        move.l ol_DOSBase(pc),a6
        move.l ol_FileHandle(pc),d1     ;get our stream
        move.l ot_FilePosition(a3),d2   ;get file position
        moveq #-1,d3                    ;relative to beginning of file
        jsr Seek(a6)                    ;seek to this position
        tst.l d0                        ;found something ?
        bmi.s .loaderror                ;what to do on failure ?

                                        ;now call the loader
        move.l ol_HunkTable(pc),d2      ;hunk table
        moveq #0,d1                     ;no file (is overlay)
        move.l ol_FileHandle(pc),d3     ;filehandle
        jsr LoadSeg(a6)                 ;load this stuff
        tst.l d0                        ;found
        beq.s .loaderror
        move.l d0,(a2)                  ;add new chain

                                        ;found this stuff
.gotsegment:
        move.l ot_SymbolHunk(a3),d0     ;get hunk # containing symbol
        add.l ol_HunkTable(pc),d0
        lsl.l #2,d0                     ;get APTR to hunk
        move.l d0,a4
        move.l (a4),d0                  ;BPTR to hunk
        lsl.l #2,d0
        add.l ot_SymbolOffset(a3),d0    ;Offset

        move.l d0,10*4(a7)              ;Set RETURN-Address

        loadregs
        rts

;*************************************************
;** Go here if we find an error                	**
;*************************************************
.loaderror:
        saveregs d7/a5
        move.l ol_SysBase(pc),a6
        move.l #$0700000C,d7
        move.l $114(a6),a5
        jsr Alert(a6)                   ;Post alert
        loadregs
        bra.s .retry                    ;Retry or die

.noprevious:
        move.l ol_SysBase(pc),a6
        move.l #$8700000C,d7            ;dead end !
        move.l $114(a6),a5
        jsr Alert(a6)                   ;Post alert
        bra.s .noprevious


;*************************************************
;** NextModule                                  **
;** Open stuff absolutely necessary and         **
;** continue with main program code             **
;*************************************************
NextModule:
                                        ;why safe registers ?
        move.l a0,a2
        move.l d0,d2                    ;keep arguments (BCPL stuff is not kept)
        lea ol_SysBase(pc),a3
        move.l ExecBase,a6
        move.l a6,(a3)                  ;fill in Sysbase
        lea DOSName(pc),a1              ;get name of DOS
        moveq #33,d0                    ;at least 1.2 MUST be used (no support of antique stuff)
        jsr OpenLibrary(a6)
        move.l d0,4(a3)                 ;Save back DOS base for loader
        beq.s .nodosexit                ;exit if no DOS here

        move.l d0,a6                    ;as a service, post this to the main code
        move.l Start-4(pc),a0           ;Get BPTR of next hunk
        adda.l a0,a0
        adda.l a0,a0
        exg.l a0,a2                     ;move to a2
        move.l d2,d0                    ;restore argument
        jsr 4(a2)                       ;jump in
        move.l d0,d2                    ;Save return code

        move.l ol_SysBase(pc),a6
        move.l ol_DOSBase(pc),a1
        jsr CloseLibrary(a6)            ;Close the lib

        move.l d2,d0                    ;Returncode in d0
        rts
.nodosexit:
        move.l #$07038007,d7            ;DOS didn't open
        move.l $114(a6),a5
        jsr Alert(a6)
        moveq #30,d0                    ;Something went really wrong !
        rts

DOSName:        dc.b "dos.library",0
\end{verbatim}

\section{Structures within Hunks}

While the AmigaDOS loader, i.e. {\tt LoadSeg()}\key{LoadSeg()} and
related functions, do not care about the contents of the segments it
loaded, some other components of AmigaDOS do actually analyze their
contents.

\subsection{The Version Cookie}

The {\tt Version} command scans a ROM-resident modules or all segments
of a binary for the character sequence {\tt \$VER:} and if such a
sequence is found, the string following is scanned. The syntax of the
string consists of the following elements:

\begin{itemize}
\item[-] The version cookie {\tt \$VER:}
\item[-] one or multiple blank spaces
\item[-] a program name, which is output by the {\tt Version} command
\item[-] a decimal number, representing the \emph{version} of the program
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the \emph{revision} of the program
\item[-] one or multiple blank spaces
\item[-] an opening bracket (``{\tt (}'')
\item[-] a decimal number, representing the day of the month of the revision
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the month of the revision
\item[-] a single dot (``{\tt .}'')
\item[-] a decimal number, representing the year of the revision
\item[-] a closing bracket (``{\tt )}'')
\item[-] an optional comment that is only output if the {\tt FULL} option of the {\tt Version} is given.
\end{itemize}

If the number representing the year is below $1900$, the {\tt Version}
command assumes a two-digit year and either adds $200$ if the year is
below $78$, or $1900$ otherwise. The command then re-formats the date
according to the currently active locale and prints it to the console,
along with the program name and, optionally, the comment string.

\subsection{The Stack Cookie}

\subsection{Runtime binding for BCPL programs}

% Describe the hunk-internal format that is used to populate
% the hunks

\section{Object File Format}

% Describe how object code looks like, including additional hunks

\section{HUNK\_EXT} \label{sec:hunk_ext}

The next table includes symbol types that identify symbol references,
i.e. they are referenced within a segment of an object file, though
not defined there. These types can clearly not be contained within a
executable binary, but they may appear within an object file and are
then resolved by corresponding symbol definitions from the above table
by the linker:
\begin{rkrmtabular}{Symbol types in HUNK\_EXT} \label{table:extsymboltypes}
\begin{longtable}{|lc|p{9cm}|} \hline
\tt EXT\_REF32 & [0x81] & Reference to a 32-bit symbol that is resolved
by a corresponding {\tt EXT\_ABS} to an absolute value or by a {\tt
  EXT\_DEF} definition to a relocation information to this or another
segment. \\ \hline

\tt EXT\_COMMON & [0x82] & Reference to a 32-bit symbol that may be
resolved by a {\tt EXT\_ABS} or {\tt EXT\_DEF} definition, but if no
such definition is found, a BSS hunk of the maximal size of all
references to the symbol is created by the linker. Thus, this type
generates a zero-initialized object if no definition is found. \\ \hline

\tt EXT\_REF16 & [0x83] & Reference to a 16-bit PC relative offset within
the same segment. \\ \hline

\tt EXT\_REF8 & [0x84] & Reference to a 8-bit PC relative offset within
the same segment. \\ \hline

\tt EXT\_DREF32 & [0x85] & 32-bit reference relative to a base register
(typically {\tt a4}), resolved by the linker through an entry in a {\tt
  HUNK\_DRELOC32} hunk\key{HUNK\_DRELOC32}.\\ \hline

\tt EXT\_DREF16 & [0x86] & 16-bit reference relative to a base register,
resolved by the linker through an entry in a {\tt HUNK\_DRELOC16}
hunk\key{HUNK\_DRELOC16}.\\ \hline

\tt EXT\_DREF8 & [0x87] & 8-bit reference relative to a base register,
resolved by the linker through an entry in a {\tt HUNK\_DRELOC8} hunk
\key{HUNK\_DRELOC8}.\\ \hline

\tt EXT\_RELREF32 & [0x88] & 32-bit PC-relative reference for 32-bit
address, this will be resolved by an {\tt EXT\_DEF} definition into an
entry into a {\tt HUNK\_RELRELOC32} hunk by the linker.\\ \hline

\tt EXT\_RELCOMMON & [0x89] & 32-bit PC relative common reference for a
32-bit address. Similar to a {\tt EXT\_COMMON} definition, this will
be resolved into an {\tt HUNK\_RELRELOC32} entry where potentially
space for the symbol will be allocated in a BSS segment if no
corresponding definition is found.\\ \hline

\tt EXT\_ABSREF16 & [0x8a] & 16-bit absolute reference, resolved by
the linker to a 16-bit value by an {\tt EXT\_ABS} definition. \\ \hline

\tt EXT\_ABSREF8 & [0x8b] & 8-bit absolute reference, resolved by the
linker to an 8-bit value through an {\tt EXT\_ABS}
definition. \\ \hline
\end{longtable}
\end{rkrmtabular}

%%% For later.

\section{Miscellaneous Functions}
The {\tt DateStamp} structure reads as follows:

\begin{verbatim}
struct DateStamp {
   LONG  ds_Days;             /* Number of days since Jan. 1, 1978 */
   LONG  ds_Minute;           /* Number of minutes past midnight */
   LONG  ds_Tick;             /* Number of ticks past minute */
};
\end{verbatim}

{\tt ds\_Days} counts the number of days since January $1^{\mbox{{\tiny st}}}$ 1978.

{\tt ds\_Minute} counts the number of minutes past midnight, i.e. the start of the day.

{\tt ds\_Tick} counts the ticks since the start of the minute. A tick
is $1/50^{\mbox{\tiny th}}$ of a second, regardless whether the
machine is a PAL or NTSC system. This constant is also defined as
{\tt TICKS\_PER\_SECOND} in {\tt dos/dos.h}.




\begin{thebibliography}{99}
\bibitem{Bantam} Commodore-Amiga Inc:
{\sl AmigaDOS Manual, $3^{\mbox{\tiny rd}}$ Edition}
Random House Information Group (1991)  
\bibitem{mc030} Motorola MC68030UM/AD Rev. 2:
{\sl MC68030 Enhanced 32-Bit Microprocessor User's Manual, 3rd ed.}
Prentice Hall, Englewood Cliffs, N.J. 07632 (1990)
\bibitem{mc040} Motorola MC68040UM/AD Rev. 1:
{\sl MC68040 Microprocessor User's Manual, revised ed.}
Motorola (1992,1993)
\bibitem{mc060} Motorola MC68060UM/AD Rev. 1:
{\sl MC68060 Microprocessor User's Manual.}
Motorola (1994)
\bibitem{mcfam} Motorola MC68000PM/AD Rev. 1:
{\sl Programmer's Reference Manual.}
Motorola (1992)
\bibitem{yuchen} Yu-Cheng Liu:
{\sl The M68000 Microprocessor Family.}
Prentice-Hall Intl., Inc. (1991)
\bibitem{rkrmlib} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Libraries. 3rd. ed.}
Addison-Wesley Publishing Company (1992)
\bibitem{rkrmdev} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Devices. 3rd. ed.}
Addison-Wesley Publishing Company (1992)
\bibitem{rkrmiia} Dan Baker (Ed.):
{\sl Amiga ROM Kernal Reference Manual: Includes and Autodocs. 3rd. ed.}
Addison-Wesley Publishing Company (1991)
\bibitem{guru} Ralph Babel:
{\sl The Amiga Guru Book.}
Ralph Babel, Taunusstein (1993)
\end{thebibliography}
%\begin{theindex}
\printindex
%\end{theindex}
\end{document}


